#! /usr/bin/env janet

(comment import ./argv :prefix "")
(def av/arg-data
  {"--bash-completion" true
   "--fish-completion" true
   "--zsh-completion" true
   "--raw-all" true
   #
   "--bindings" true
   "--env-vars" true
   #
   "--doc" "-d"
   "--eval" "-e"
   "--format" "-f"
   "--grep" "-g"
   "--indent" "-i"
   "--help" "-h"
   "--macex1" "-m"
   "--pprint" "-p"
   "--repl" "-r"
   "--quiz" "-q"
   "--src" "-s"
   "--todo" "-t"
   "--usage" "-u"})

(def av/shorts-table
  (tabseq [[full short] :pairs av/arg-data
           :when short]
    short full))

(defn av/opt-to-keyword
  [opt-str]
  (def full-opt-str (get av/shorts-table opt-str opt-str))
  (when (not (string/has-prefix? "--" full-opt-str))
    (break (string/format "Unknown short option: %s" opt-str)))
  (when (not (get av/arg-data full-opt-str))
    (break (string/format "Unknown option: %s" opt-str)))
  (keyword (string/slice full-opt-str 2)))

(defn av/parse-argv
  [argv]
  (def opts @{})
  (def rest @[])
  (def errs @[])
  (def argc (length argv))
  #
  (when (> argc 1)
    (var i 1)
    (while (< i argc)
      (def arg (get argv i))
      (if (string/has-prefix? "-" arg)
        (let [res (av/opt-to-keyword arg)]
          (cond
            (string? res)
            (array/push errs res)
            #
            (keyword? res)
            (put opts res true)
            #
            (array/push errs
                        (string/format "unexpected type: %n"
                                       (type res)))))
        (array/push rest arg))
      (++ i)))
  #
  [opts rest errs])

(comment import ./colorize :prefix "")
(defn col/xform-with-process
  [a-str cmd-tup]
  (def p
    (try
      (os/spawn cmd-tup
                :px {:in :pipe :out :pipe})
      ([e]
        # XXX
        (eprintf "os/spawn failed, not coloring: %s" e)
        (break a-str))))
  #
  (ev/write (p :in) a-str)
  (ev/close (p :in))
  #
  (def buf @"")
  (try
    # XXX: this is async -- provide a timeout?
    (ev/read (p :out) :all buf)
    ([e]
      (eprintf "ev/read failed, not coloring: %s" e)
      (break a-str)))
  # in this case, following should wait as well
  (os/proc-close p)
  #
  buf)

(defn col/colorize
  [src &opt lang]
  (default lang "janet")
  (def colorizer (dyn :jref-colorizer))
  (def colorizer-style (dyn :jref-colorizer-style))
  (def colorizer-filename
    (if-let [colorizer-filename (dyn :jref-colorizer-filename)]
      colorizer-filename
      (if (= :windows (os/which))
        (string colorizer ".exe")
        colorizer)))
  (cond
    (= "bat" colorizer)
    (col/xform-with-process src
                        [colorizer-filename
                         "--style=plain"
                         "--paging=never"
                         "--force-colorization"
                         "--theme" colorizer-style
                         "-l" (if (= "janet" lang)
                                "clojure"
                                lang)])
    #
    (= "pygmentize" colorizer)
    (col/xform-with-process src
                        [colorizer-filename
                         "-P" (string "style=" colorizer-style)
                         "-l" (if (= "janet" lang)
                                "clojure"
                                lang)])
    #
    (= "rougify" colorizer)
    (col/xform-with-process src
                        [colorizer-filename
                         "highlight"
                         "--lexer" lang
                         "--theme" colorizer-style])
    #
    src))


(comment import ./completion :prefix "")
(def compl/bash-completion
  ``
  _jref_things() {
      COMPREPLY=( $(compgen -W "$(jref --raw-all)" -- ${COMP_WORDS[COMP_CWORD]}) );
  }
  complete -F _jref_things jref
  ``)

(def compl/fish-completion
  ``
  function __jref_complete_things
    if not test "$__jref_things"
      set -g __jref_things (jref --raw-all)
    end

    printf "%s\n" $__jref_things
  end

  complete -c jref -a "(__jref_complete_things)" -d 'things'
  ``)

(def compl/zsh-completion
  ``
  #compdef jref

  _jref() {
      local matches=(`jref --raw-all`)
      compadd -a matches
  }

  _jref "$@"
  ``)

(defn compl/maybe-handle-dump-completion
  [opts]
  # this makes use of the fact that print returns nil
  (not
    (cond
      (opts :bash-completion)
      (print compl/bash-completion)
      #
      (opts :fish-completion)
      (print compl/fish-completion)
      #
      (opts :zsh-completion)
      (print compl/zsh-completion)
      #
      true)))


(comment import ./doc :prefix "")
# assumes usage file for special form has certain structure
(defn doc/massage-lines-for-special
  [lines]
  (def m-lines @[])
  (var i 0)
  (var docstring-delim-cnt 0)
  (while (< i (length lines))
    (if (>= docstring-delim-cnt 2)
      (break))
    (def cur-line (get lines i))
    (if (string/has-prefix? "```" cur-line)
      (++ docstring-delim-cnt)
      (array/push m-lines cur-line))
    (++ i))
  #
  m-lines)

(defn doc/special-form-doc
  [content]
  (def lines
    (string/split "\n" content))
  #
  (doc/massage-lines-for-special lines))

(defn doc/massage-lines
  [lines]
  # figure out where first non-blank line is
  (var i 0)
  (while (< i (length lines))
    (if (not (empty? (get lines i)))
      (break)
      (++ i)))
  # i might equal (length lines) if data is not sound
  (assert (not= i (length lines))
          (string/format "Something seems odd about lines: %p"
                         lines))
  # figure out where last non-blank line is
  (var j (dec (length lines)))
  (while (<= 0 j)
    (if (not (empty? (get lines j)))
      (break)
      (-- j)))
  # find indentation of first non-blank line
  (var indent 0)
  (for k 0 (length lines)
    (let [matches
          (peg/match ~(capture :s+) (get lines k))]
      (when matches
        (set indent (length (first matches)))
        (break))))
  #
  (def m-lines @[])
  (each line (array/slice lines i (inc j))
    (if (>= (length line) indent)
      (array/push m-lines (string/slice line indent))
      (array/push m-lines line)))
  #
  m-lines)

(defn doc/thing-doc
  [thing]
  (def buf @"")
  (cond
    ((curenv) (symbol thing))
    (with-dyns [*out* buf]
      (eval-string (string/format `(doc %s)` thing)))
    #
    (with-dyns [*out* buf]
      (eval-string (string/format `(doc "%s")` thing))))
  #
  (def lines
    (string/split "\n" buf))
  #
  (doc/massage-lines lines))


(comment import ./dyns :prefix "")
(defn d/init-dyns
  []
  (def home-dir
    (os/getenv "HOME" (os/getenv "USERPOFILE")))

  (def conf-file-path
    (string home-dir "/.jref.janet"))

  (def conf
    (when (= :file (os/stat conf-file-path :mode))
      (let [conf (try
                   (eval-string (slurp conf-file-path))
                   ([e]
                     (errorf e)))]
        (assert (struct? conf)
                (string/format "expected a struct, found: %n" conf))
        conf)))

  (setdyn :jref-width 68)

  (setdyn :jref-rng
          (math/rng (os/cryptorand 8)))

  (setdyn :jref-src-path
          (os/getenv "JREF_SRC_PATH"
                     (get conf :src-path)))

  (setdyn :jref-janet-src-path
          (os/getenv "JREF_JANET_SRC_PATH"
                     (get conf :janet-src-path)))

  (setdyn :jref-repos-root
          (os/getenv "JREF_REPOS_PATH"
                     (get conf :janet-repos-path)))

  # on windows, https://github.com/adoxa/ansicon may help for
  # pygmentize and rougify
  (setdyn :jref-colorizer (os/getenv "JREF_COLORIZER"))

  # bat -- `bat --list-themes`
  # pygmentize -- `pygmentize -L styles`
  # rougify -- `ls ~/src/rouge/lib/rouge/themes`
  (setdyn :jref-colorizer-style
          (if-let [colorizer-style (os/getenv "JREF_COLORIZER_STYLE")]
            colorizer-style
            (cond
              (= "bat" (dyn :jref-colorizer))
              "gruvbox-dark" # dracula, monokai-extended-origin, OneHalfDark
              #
              (= "pygmentize" (dyn :jref-colorizer))
              "rrt" # dracula, one-dark, monokai, gruvbox-dark
              #
              (= "rougify" (dyn :jref-colorizer))
              "gruvbox" # monokai, thankful_eyes
              "oops")))

  (setdyn :jref-colorizer-filename
          (os/getenv "JREF_COLORIZER_FILENAME"))

  (setdyn :jref-editor
          (os/getenv "JREF_EDITOR"
                     (get conf :editor "nvim")))

  (setdyn :jref-editor-open-at-format
          (if-let [format (os/getenv "JREF_EDITOR_OPEN_AT_FORMAT")]
            (tuple ;(string/split " " format))
            (case (dyn :jref-editor)
              "emacs"
              ["+%d" "%s"]
              #
              "hx"
              ["+%d" "%s"]
              #
              "kak"
              ["+%d" "%s"]
              #
              "nvim"
              ["+%d" "%s"]
              #
              "subl"
              ["%s:%d"]
              #
              "vim"
              ["+%d" "%s"]
              #
              ["+%d" "%s"])))

  (setdyn :jref-editor-filename
          (os/getenv "JREF_EDITOR_FILENAME"
                     (get conf :editor-filename))))


(comment import ./env-vars :prefix "")
(def evars/docstring
  ``
  Environment Variables Related to jref

  jref's behavior is influenced by a number of environment variables.

  At the moment, what can be affected includes:

  * Color
  * Editor (for displaying source)
  * Janet Source (for displaying source)
  * Source Searching

  N.B. It's not so clear which ones will stick around, but if you
  find any useful, mentioning this might affect whether certain
  ones survive.

  Color
  -----

  jref does not directly apply color to any of its output but instead
  allows one to specify a separate program to do so.

  JREF_COLORIZER - valid values include:

  * bat
  * pygmentize
  * rougify

  If set appropriately, jref will try to send certain output through
  the selected program with an aim toward coloring the output.

  JREF_COLORIZER_STYLE - valid values depend on what was selected
  for JREF_COLORIZER.

  If set appropriately, the theme / style used by the selected
  "colorizer" will be affected.

  Some examples include:

  * bat
    * dracula
    * gruvbox-dark
    * monokai-extended-origin
    * OneHalfDark

    `bat --list-themes` enumerates some options.

  * pygmentize
    * dracula
    * gruvbox-dark
    * monokai
    * one-dark
    * rrt

    `pygmentize -L styles` enumerates some options.

  * rougify
    * gruvbox
    * monokai
    * thankful_eyes

    `ls ~/src/rouge/lib/rouge/themes` enumerates some options
    (assuming rouge source code has been fetched and placed in a
    certain location).

  JREF_COLORIZER_FILENAME - valid values might be something like:

  * bat.bat
  * pygmentize.com

  If set appropriately, this is used in the invocation of the
  colorizer.  It primarily exists to support Windows where the file
  extension is not so easy for jref's author to determine (e.g. you
  might be using a shim or a .bat script to lauch a colorizer).  If
  you're using Windows and your colorizer's filename extension is not
  ".exe", setting this might help.


  Editor
  ------

  If configured appropriately, jref's `--src` option hands off
  displaying of source code to an editor.

  JREF_EDITOR - valid values include:

  * emacs
  * kak
  * nvim
  * subl
  * vim

  If set appropriately, the editor invoked by jref to display source
  code is affected, but see JREF_EDITOR_FILENAME below for a caveat.

  The value is also used to determine arguments passed to the editor
  in order to open a certain file at a particular line, but see
  JREF_EDITOR_OPEN_AT_FORMAT below for a caveat.

  Other values may work, but then JREF_EDITOR_OPEN_AT_FORMAT likely
  needs to be set too.

  JREF_EDITOR_OPEN_AT_FORMAT - valid value might be something like:

  * "+%d %s"
  * "%s:%d"

  It set appropriately, this overrides the arguments an editor uses to
  open a file at a particular line.  If your editor is already
  supported, you probably don't need to set this.

  You can try this if you have set JREF_EDITOR to something other than
  what was listed as a valid value in the JREF_EDITOR description
  above.  It's probably better to discuss support for an editor with
  jref's author though.

  JREF_EDITOR_FILENAME - valid values might be something like:

  * edit.com
  * emacs.bat

  If set appropriately, this is used in the invocation of the editor.
  It primarily exists to support Windows where the file extension is
  not so easy for jref's author to determine (e.g. you might be using
  a shim or a .bat script to lauch an editor).  If you're using
  Windows and your editor's filename extension is not ".exe", setting
  this might help.

  Janet Source
  ------------

  In order for jref's `--src` capability to function, an index of
  janet's source code needs to be created.  Also, in order to use the
  index, the source needs to be available.

  JREF_JANET_SRC_PATH - a valid value might be something like:

  * /home/user/src/janet
  * /Users/user/Desktop/janet

  If set appropriately, this is used when creating an index for
  janet's source code.  The path is also used when displaying a
  relevant source file.

  Source Searching
  ----------------

  There is some support for searching through a collection of janet
  source code via the `--grep` option.

  JREF_REPOS_PATH - a valid value might be something like:

  * /home/user/src/janet-repos
  * /Users/user/Desktop/janet-collection

  If set appropriately, this is used as a directory to search under.

  ``)

(comment import ./format/bindings :prefix "")
(comment import ../location-with-unreadable :prefix "")
(comment import ./location :prefix "")
# bl - begin line
# bc - begin column
# el - end line
# ec - end column
(defn loc/make-attrs
  [& items]
  (zipcoll [:bl :bc :el :ec]
           items))

(defn loc/atom-node
  [node-type peg-form]
  ~(cmt (capture (sequence (line) (column)
                           ,peg-form
                           (line) (column)))
        ,|[node-type (loc/make-attrs ;(slice $& 0 -2)) (last $&)]))

(defn loc/reader-macro-node
  [node-type sigil]
  ~(cmt (capture (sequence (line) (column)
                           ,sigil
                           (any :non-form)
                           :form
                           (line) (column)))
        ,|[node-type (loc/make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
           ;(slice $& 2 -4)]))

(defn loc/collection-node
  [node-type open-delim close-delim]
  ~(cmt
     (capture
       (sequence
         (line) (column)
         ,open-delim
         (any :input)
         (choice ,close-delim
                 (error
                   (replace (sequence (line) (column))
                            ,|(string/format
                                "line: %p column: %p missing %p for %p"
                                $0 $1 close-delim node-type))))
         (line) (column)))
     ,|[node-type (loc/make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
        ;(slice $& 2 -4)]))

(def loc/loc-grammar
  ~@{:main (sequence (line) (column)
                     (some :input)
                     (line) (column))
     #
     :input (choice :non-form
                    :form)
     #
     :non-form (choice :whitespace
                       :comment)
     #
     :whitespace ,(loc/atom-node :whitespace
                             '(choice (some (set " \0\f\t\v"))
                                      (choice "\r\n"
                                              "\r"
                                              "\n")))
     # :whitespace
     # (cmt (capture (sequence (line) (column)
     #                         (choice (some (set " \0\f\t\v"))
     #                                 (choice "\r\n"
     #                                         "\r"
     #                                         "\n"))
     #                         (line) (column)))
     #      ,|[:whitespace (make-attrs ;(slice $& 0 -2)) (last $&)])
     #
     :comment ,(loc/atom-node :comment
                          '(sequence "#"
                                     (any (if-not (set "\r\n") 1))))
     #
     :form (choice # reader macros
                   :fn
                   :quasiquote
                   :quote
                   :splice
                   :unquote
                   # collections
                   :array
                   :bracket-array
                   :tuple
                   :bracket-tuple
                   :table
                   :struct
                   # atoms
                   :number
                   :constant
                   :buffer
                   :string
                   :long-buffer
                   :long-string
                   :keyword
                   :symbol)
     #
     :fn ,(loc/reader-macro-node :fn "|")
     # :fn (cmt (capture (sequence (line) (column)
     #                             "|"
     #                             (any :non-form)
     #                             :form
     #                             (line) (column)))
     #          ,|[:fn (make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
     #             ;(slice $& 2 -4)])
     #
     :quasiquote ,(loc/reader-macro-node :quasiquote "~")
     #
     :quote ,(loc/reader-macro-node :quote "'")
     #
     :splice ,(loc/reader-macro-node :splice ";")
     #
     :unquote ,(loc/reader-macro-node :unquote ",")
     #
     :array ,(loc/collection-node :array "@(" ")")
     # :array
     # (cmt
     #   (capture
     #     (sequence
     #       (line) (column)
     #       "@("
     #       (any :input)
     #       (choice ")"
     #               (error
     #                 (replace (sequence (line) (column))
     #                          ,|(string/format
     #                              "line: %p column: %p missing %p for %p"
     #                              $0 $1 ")" :array))))
     #       (line) (column)))
     #   ,|[:array (make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
     #      ;(slice $& 2 -4)])
     #
     :tuple ,(loc/collection-node :tuple "(" ")")
     #
     :bracket-array ,(loc/collection-node :bracket-array "@[" "]")
     #
     :bracket-tuple ,(loc/collection-node :bracket-tuple "[" "]")
     #
     :table ,(loc/collection-node :table "@{" "}")
     #
     :struct ,(loc/collection-node :struct "{" "}")
     #
     :number ,(loc/atom-node :number
                         ~(drop (sequence (cmt (capture (some :num-char))
                                               ,scan-number)
                                          (opt (sequence ":" (range "AZ" "az"))))))
     #
     :num-char (choice (range "09" "AZ" "az")
                       (set "&+-._"))
     #
     :constant ,(loc/atom-node :constant
                           '(sequence (choice "false" "nil" "true")
                                      (not :name-char)))
     #
     :name-char (choice (range "09" "AZ" "az" "\x80\xFF")
                        (set "!$%&*+-./:<?=>@^_"))
     #
     :buffer ,(loc/atom-node :buffer
                         '(sequence `@"`
                                    (any (choice :escape
                                                 (if-not "\"" 1)))
                                    `"`))
     #
     :escape (sequence "\\"
                       (choice (set `"'0?\abefnrtvz`)
                               (sequence "x" (2 :h))
                               (sequence "u" (4 :h))
                               (sequence "U" (6 :h))
                               (error (constant "bad escape"))))
     #
     :string ,(loc/atom-node :string
                         '(sequence `"`
                                    (any (choice :escape
                                                 (if-not "\"" 1)))
                                    `"`))
     #
     :long-string ,(loc/atom-node :long-string
                              :long-bytes)
     #
     :long-bytes {:main (drop (sequence :open
                                        (any (if-not :close 1))
                                        :close))
                  :open (capture :delim :n)
                  :delim (some "`")
                  :close (cmt (sequence (not (look -1 "`"))
                                        (backref :n)
                                        (capture (backmatch :n)))
                              ,=)}
     #
     :long-buffer ,(loc/atom-node :long-buffer
                              '(sequence "@" :long-bytes))
     #
     :keyword ,(loc/atom-node :keyword
                          '(sequence ":"
                                     (any :name-char)))
     #
     :symbol ,(loc/atom-node :symbol
                         '(some :name-char))
     })

(comment

  (get (peg/match loc/loc-grammar " ") 2)
  # =>
  '(:whitespace @{:bc 1 :bl 1 :ec 2 :el 1} " ")

  (get (peg/match loc/loc-grammar "true?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 6 :el 1} "true?")

  (get (peg/match loc/loc-grammar "nil?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 5 :el 1} "nil?")

  (get (peg/match loc/loc-grammar "false?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 7 :el 1} "false?")

  (get (peg/match loc/loc-grammar "# hi there") 2)
  # =>
  '(:comment @{:bc 1 :bl 1 :ec 11 :el 1} "# hi there")

  (get (peg/match loc/loc-grammar "1_000_000") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 10 :el 1} "1_000_000")

  (get (peg/match loc/loc-grammar "8.3") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "8.3")

  (get (peg/match loc/loc-grammar "1e2") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "1e2")

  (get (peg/match loc/loc-grammar "0xfe") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "0xfe")

  (get (peg/match loc/loc-grammar "2r01") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "2r01")

  (get (peg/match loc/loc-grammar "3r101&01") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 9 :el 1} "3r101&01")

  (get (peg/match loc/loc-grammar "2:u") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "2:u")

  (get (peg/match loc/loc-grammar "-8:s") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "-8:s")

  (get (peg/match loc/loc-grammar "1e2:n") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 6 :el 1} "1e2:n")

  (get (peg/match loc/loc-grammar "printf") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 7 :el 1} "printf")

  (get (peg/match loc/loc-grammar ":smile") 2)
  # =>
  '(:keyword @{:bc 1 :bl 1 :ec 7 :el 1} ":smile")

  (get (peg/match loc/loc-grammar `"fun"`) 2)
  # =>
  '(:string @{:bc 1 :bl 1 :ec 6 :el 1} "\"fun\"")

  (get (peg/match loc/loc-grammar "``long-fun``") 2)
  # =>
  '(:long-string @{:bc 1 :bl 1 :ec 13 :el 1} "``long-fun``")

  (get (peg/match loc/loc-grammar "@``long-buffer-fun``") 2)
  # =>
  '(:long-buffer @{:bc 1 :bl 1 :ec 21 :el 1} "@``long-buffer-fun``")

  (get (peg/match loc/loc-grammar `@"a buffer"`) 2)
  # =>
  '(:buffer @{:bc 1 :bl 1 :ec 12 :el 1} "@\"a buffer\"")

  (get (peg/match loc/loc-grammar "@[8]") 2)
  # =>
  '(:bracket-array @{:bc 1 :bl 1
                     :ec 5 :el 1}
                   (:number @{:bc 3 :bl 1
                              :ec 4 :el 1} "8"))

  (get (peg/match loc/loc-grammar "@{:a 1}") 2)
  # =>
  '(:table @{:bc 1 :bl 1
             :ec 8 :el 1}
           (:keyword @{:bc 3 :bl 1
                       :ec 5 :el 1} ":a")
           (:whitespace @{:bc 5 :bl 1
                          :ec 6 :el 1} " ")
           (:number @{:bc 6 :bl 1
                      :ec 7 :el 1} "1"))

  (get (peg/match loc/loc-grammar "~x") 2)
  # =>
  '(:quasiquote @{:bc 1 :bl 1
                  :ec 3 :el 1}
                (:symbol @{:bc 2 :bl 1
                           :ec 3 :el 1} "x"))

  (get (peg/match loc/loc-grammar "' '[:a :b]") 2)
  # =>
  '(:quote @{:bc 1 :bl 1
             :ec 11 :el 1}
           (:whitespace @{:bc 2 :bl 1
                          :ec 3 :el 1} " ")
           (:quote @{:bc 3 :bl 1
                     :ec 11 :el 1}
                   (:bracket-tuple @{:bc 4 :bl 1
                                     :ec 11 :el 1}
                                   (:keyword @{:bc 5 :bl 1
                                               :ec 7 :el 1} ":a")
                                   (:whitespace @{:bc 7 :bl 1
                                                  :ec 8 :el 1} " ")
                                   (:keyword @{:bc 8 :bl 1
                                               :ec 10 :el 1} ":b"))))

  )

(def loc/loc-top-level-ast
  (put (table ;(kvs loc/loc-grammar))
       :main ~(sequence (line) (column)
                        :input
                        (line) (column))))

(defn loc/par
  [src &opt start single]
  (default start 0)
  (if single
    (if-let [[bl bc tree el ec]
             (peg/match loc/loc-top-level-ast src start)]
      @[:code (loc/make-attrs bl bc el ec) tree]
      @[:code])
    (if-let [captures (peg/match loc/loc-grammar src start)]
      (let [[bl bc] (slice captures 0 2)
            [el ec] (slice captures -3)
            trees (array/slice captures 2 -3)]
        (array/insert trees 0
                      :code (loc/make-attrs bl bc el ec)))
      @[:code])))

# XXX: backward compatibility
(def loc/ast loc/par)

(comment

  (loc/par "(+ 1 1)")
  # =>
  '@[:code @{:bc 1 :bl 1
             :ec 8 :el 1}
     (:tuple @{:bc 1 :bl 1
               :ec 8 :el 1}
             (:symbol @{:bc 2 :bl 1
                        :ec 3 :el 1} "+")
             (:whitespace @{:bc 3 :bl 1
                            :ec 4 :el 1} " ")
             (:number @{:bc 4 :bl 1
                        :ec 5 :el 1} "1")
             (:whitespace @{:bc 5 :bl 1
                            :ec 6 :el 1} " ")
             (:number @{:bc 6 :bl 1
                        :ec 7 :el 1} "1"))]

  )

(defn loc/gen*
  [an-ast buf]
  (case (first an-ast)
    :code
    (each elt (drop 2 an-ast)
      (loc/gen* elt buf))
    #
    :buffer
    (buffer/push-string buf (in an-ast 2))
    :comment
    (buffer/push-string buf (in an-ast 2))
    :constant
    (buffer/push-string buf (in an-ast 2))
    :keyword
    (buffer/push-string buf (in an-ast 2))
    :long-buffer
    (buffer/push-string buf (in an-ast 2))
    :long-string
    (buffer/push-string buf (in an-ast 2))
    :number
    (buffer/push-string buf (in an-ast 2))
    :string
    (buffer/push-string buf (in an-ast 2))
    :symbol
    (buffer/push-string buf (in an-ast 2))
    :whitespace
    (buffer/push-string buf (in an-ast 2))
    #
    :array
    (do
      (buffer/push-string buf "@(")
      (each elt (drop 2 an-ast)
        (loc/gen* elt buf))
      (buffer/push-string buf ")"))
    :bracket-array
    (do
      (buffer/push-string buf "@[")
      (each elt (drop 2 an-ast)
        (loc/gen* elt buf))
      (buffer/push-string buf "]"))
    :bracket-tuple
    (do
      (buffer/push-string buf "[")
      (each elt (drop 2 an-ast)
        (loc/gen* elt buf))
      (buffer/push-string buf "]"))
    :tuple
    (do
      (buffer/push-string buf "(")
      (each elt (drop 2 an-ast)
        (loc/gen* elt buf))
      (buffer/push-string buf ")"))
    :struct
    (do
      (buffer/push-string buf "{")
      (each elt (drop 2 an-ast)
        (loc/gen* elt buf))
      (buffer/push-string buf "}"))
    :table
    (do
      (buffer/push-string buf "@{")
      (each elt (drop 2 an-ast)
        (loc/gen* elt buf))
      (buffer/push-string buf "}"))
    #
    :fn
    (do
      (buffer/push-string buf "|")
      (each elt (drop 2 an-ast)
        (loc/gen* elt buf)))
    :quasiquote
    (do
      (buffer/push-string buf "~")
      (each elt (drop 2 an-ast)
        (loc/gen* elt buf)))
    :quote
    (do
      (buffer/push-string buf "'")
      (each elt (drop 2 an-ast)
        (loc/gen* elt buf)))
    :splice
    (do
      (buffer/push-string buf ";")
      (each elt (drop 2 an-ast)
        (loc/gen* elt buf)))
    :unquote
    (do
      (buffer/push-string buf ",")
      (each elt (drop 2 an-ast)
        (loc/gen* elt buf)))
    ))

(defn loc/gen
  [an-ast]
  (let [buf @""]
    (loc/gen* an-ast buf)
    # XXX: leave as buffer?
    (string buf)))

# XXX: backward compatibility
(def loc/code loc/gen)

(comment

  (loc/gen
    [:code])
  # =>
  ""

  (loc/gen
    '(:whitespace @{:bc 1 :bl 1
                    :ec 2 :el 1} " "))
  # =>
  " "

  (loc/gen
    '(:buffer @{:bc 1 :bl 1
                :ec 12 :el 1} "@\"a buffer\""))
  # =>
  `@"a buffer"`

  (loc/gen
    '@[:code @{:bc 1 :bl 1
               :ec 8 :el 1}
       (:tuple @{:bc 1 :bl 1
                 :ec 8 :el 1}
               (:symbol @{:bc 2 :bl 1
                          :ec 3 :el 1} "+")
               (:whitespace @{:bc 3 :bl 1
                              :ec 4 :el 1} " ")
               (:number @{:bc 4 :bl 1
                          :ec 5 :el 1} "1")
               (:whitespace @{:bc 5 :bl 1
                              :ec 6 :el 1} " ")
               (:number @{:bc 6 :bl 1
                          :ec 7 :el 1} "1"))])
  # =>
  "(+ 1 1)"

  )

(comment

  (def src "{:x  :y \n :z  [:a  :b    :c]}")

  (loc/gen (loc/par src))
  # =>
  src

  )

(comment

  (comment

    (let [src (slurp (string (os/getenv "HOME")
                             "/src/janet/src/boot/boot.janet"))]
      (= (string src)
         (loc/gen (loc/par src))))

    )

  )


(def lwu/loc-grammar
  (do
    (put loc/loc-grammar
         :unreadable
         (loc/atom-node :unreadable
                        '(sequence "<"
                                   (between 1 32 :name-char)
                                   :s+
                                   (some (if (choice :name-char
                                                     :d)
                                           1))
                                   (look -1 ">")
                                   (look 0 (choice -1
                                                   (not (choice :name-char
                                                                :d)))))))
    (def form-value (get loc/loc-grammar :form))
    (put loc/loc-grammar
         :form (tuple 'choice
                      :unreadable
                      ;(tuple/slice form-value 1)))))

(comment

  (get (peg/match lwu/loc-grammar " ") 2)
  # =>
  '(:whitespace @{:bc 1 :bl 1 :ec 2 :el 1} " ")

  (get (peg/match lwu/loc-grammar "true?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 6 :el 1} "true?")

  (get (peg/match lwu/loc-grammar "nil?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 5 :el 1} "nil?")

  (get (peg/match lwu/loc-grammar "false?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 7 :el 1} "false?")

  (get (peg/match lwu/loc-grammar "# hi there") 2)
  # =>
  '(:comment @{:bc 1 :bl 1 :ec 11 :el 1} "# hi there")

  (get (peg/match lwu/loc-grammar "1_000_000") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 10 :el 1} "1_000_000")

  (get (peg/match lwu/loc-grammar "8.3") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "8.3")

  (get (peg/match lwu/loc-grammar "1e2") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "1e2")

  (get (peg/match lwu/loc-grammar "0xfe") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "0xfe")

  (get (peg/match lwu/loc-grammar "2r01") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "2r01")

  (get (peg/match lwu/loc-grammar "3r101&01") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 9 :el 1} "3r101&01")

  (get (peg/match lwu/loc-grammar "2:u") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "2:u")

  (get (peg/match lwu/loc-grammar "-8:s") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "-8:s")

  (get (peg/match lwu/loc-grammar "1e2:n") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 6 :el 1} "1e2:n")

  (get (peg/match lwu/loc-grammar "printf") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 7 :el 1} "printf")

  (get (peg/match lwu/loc-grammar ":smile") 2)
  # =>
  '(:keyword @{:bc 1 :bl 1 :ec 7 :el 1} ":smile")

  (get (peg/match lwu/loc-grammar `"fun"`) 2)
  # =>
  '(:string @{:bc 1 :bl 1 :ec 6 :el 1} "\"fun\"")

  (get (peg/match lwu/loc-grammar "``long-fun``") 2)
  # =>
  '(:long-string @{:bc 1 :bl 1 :ec 13 :el 1} "``long-fun``")

  (get (peg/match lwu/loc-grammar "@``long-buffer-fun``") 2)
  # =>
  '(:long-buffer @{:bc 1 :bl 1 :ec 21 :el 1} "@``long-buffer-fun``")

  (get (peg/match lwu/loc-grammar `@"a buffer"`) 2)
  # =>
  '(:buffer @{:bc 1 :bl 1 :ec 12 :el 1} "@\"a buffer\"")

  (get (peg/match lwu/loc-grammar "@[8]") 2)
  # =>
  '(:bracket-array @{:bc 1 :bl 1
                     :ec 5 :el 1}
                   (:number @{:bc 3 :bl 1
                              :ec 4 :el 1} "8"))

  (get (peg/match lwu/loc-grammar "@{:a 1}") 2)
  # =>
  '(:table @{:bc 1 :bl 1
             :ec 8 :el 1}
           (:keyword @{:bc 3 :bl 1
                       :ec 5 :el 1} ":a")
           (:whitespace @{:bc 5 :bl 1
                          :ec 6 :el 1} " ")
           (:number @{:bc 6 :bl 1
                      :ec 7 :el 1} "1"))

  (get (peg/match lwu/loc-grammar "~x") 2)
  # =>
  '(:quasiquote @{:bc 1 :bl 1
                  :ec 3 :el 1}
                (:symbol @{:bc 2 :bl 1
                           :ec 3 :el 1} "x"))

  (get (peg/match lwu/loc-grammar "<core/peg 0xdeedabba>") 2)
  # =>
  '(:unreadable @{:bc 1 :bl 1 :ec 22 :el 1} "<core/peg 0xdeedabba>")

  (get (peg/match lwu/loc-grammar "<function >>") 2)
  # =>
  '(:unreadable @{:bc 1 :bl 1 :ec 13 :el 1} "<function >>")

  (get (peg/match lwu/loc-grammar "<function ->>>") 2)
  # =>
  '(:unreadable @{:bc 1 :bl 1 :ec 15 :el 1} "<function ->>>")

  (get (peg/match lwu/loc-grammar "<core/s64 100>") 2)
  # =>
  '(:unreadable @{:bc 1 :bl 1 :ec 15 :el 1} "<core/s64 100>")

  (get (peg/match lwu/loc-grammar "(+ <core/s64 100> 1)") 2)
  # =>
  '(:tuple @{:bc 1 :bl 1 :ec 21 :el 1}
           (:symbol @{:bc 2 :bl 1 :ec 3 :el 1} "+")
           (:whitespace @{:bc 3 :bl 1 :ec 4 :el 1} " ")
           (:unreadable @{:bc 4 :bl 1 :ec 18 :el 1} "<core/s64 100>")
           (:whitespace @{:bc 18 :bl 1 :ec 19 :el 1} " ")
           (:number @{:bc 19 :bl 1 :ec 20 :el 1} "1"))

  )

(def lwu/loc-top-level-ast
  (put (table ;(kvs lwu/loc-grammar))
       :main ~(sequence (line) (column)
                        :input
                        (line) (column))))

(defn lwu/par
  [src &opt start single]
  (default start 0)
  (if single
    (if-let [[bl bc tree el ec]
             (peg/match lwu/loc-top-level-ast src start)]
      @[:code (loc/make-attrs bl bc el ec) tree]
      @[:code])
    (if-let [captures (peg/match lwu/loc-grammar src start)]
      (let [[bl bc] (slice captures 0 2)
            [el ec] (slice captures -3)
            trees (array/slice captures 2 -3)]
        (array/insert trees 0
                      :code (loc/make-attrs bl bc el ec)))
      @[:code])))

(comment

  (lwu/par "(+ 1 1)")
  # =>
  '@[:code @{:bc 1 :bl 1
             :ec 8 :el 1}
     (:tuple @{:bc 1 :bl 1
               :ec 8 :el 1}
             (:symbol @{:bc 2 :bl 1
                        :ec 3 :el 1} "+")
             (:whitespace @{:bc 3 :bl 1
                            :ec 4 :el 1} " ")
             (:number @{:bc 4 :bl 1
                        :ec 5 :el 1} "1")
             (:whitespace @{:bc 5 :bl 1
                            :ec 6 :el 1} " ")
             (:number @{:bc 6 :bl 1
                        :ec 7 :el 1} "1"))]

  )

(defn lwu/gen*
  [an-ast buf]
  (case (first an-ast)
    :code
    (each elt (drop 2 an-ast)
      (lwu/gen* elt buf))
    #
    :buffer
    (buffer/push-string buf (in an-ast 2))
    :comment
    (buffer/push-string buf (in an-ast 2))
    :constant
    (buffer/push-string buf (in an-ast 2))
    :keyword
    (buffer/push-string buf (in an-ast 2))
    :long-buffer
    (buffer/push-string buf (in an-ast 2))
    :long-string
    (buffer/push-string buf (in an-ast 2))
    :number
    (buffer/push-string buf (in an-ast 2))
    :string
    (buffer/push-string buf (in an-ast 2))
    :symbol
    (buffer/push-string buf (in an-ast 2))
    :unreadable
    (buffer/push-string buf (in an-ast 2))
    :whitespace
    (buffer/push-string buf (in an-ast 2))
    #
    :array
    (do
      (buffer/push-string buf "@(")
      (each elt (drop 2 an-ast)
        (lwu/gen* elt buf))
      (buffer/push-string buf ")"))
    :bracket-array
    (do
      (buffer/push-string buf "@[")
      (each elt (drop 2 an-ast)
        (lwu/gen* elt buf))
      (buffer/push-string buf "]"))
    :bracket-tuple
    (do
      (buffer/push-string buf "[")
      (each elt (drop 2 an-ast)
        (lwu/gen* elt buf))
      (buffer/push-string buf "]"))
    :tuple
    (do
      (buffer/push-string buf "(")
      (each elt (drop 2 an-ast)
        (lwu/gen* elt buf))
      (buffer/push-string buf ")"))
    :struct
    (do
      (buffer/push-string buf "{")
      (each elt (drop 2 an-ast)
        (lwu/gen* elt buf))
      (buffer/push-string buf "}"))
    :table
    (do
      (buffer/push-string buf "@{")
      (each elt (drop 2 an-ast)
        (lwu/gen* elt buf))
      (buffer/push-string buf "}"))
    #
    :fn
    (do
      (buffer/push-string buf "|")
      (each elt (drop 2 an-ast)
        (lwu/gen* elt buf)))
    :quasiquote
    (do
      (buffer/push-string buf "~")
      (each elt (drop 2 an-ast)
        (lwu/gen* elt buf)))
    :quote
    (do
      (buffer/push-string buf "'")
      (each elt (drop 2 an-ast)
        (lwu/gen* elt buf)))
    :splice
    (do
      (buffer/push-string buf ";")
      (each elt (drop 2 an-ast)
        (lwu/gen* elt buf)))
    :unquote
    (do
      (buffer/push-string buf ",")
      (each elt (drop 2 an-ast)
        (lwu/gen* elt buf)))
    ))

(defn lwu/gen
  [an-ast]
  (let [buf @""]
    (lwu/gen* an-ast buf)
    # XXX: leave as buffer?
    (string buf)))

(comment

  (lwu/gen
    [:code])
  # =>
  ""

  (lwu/gen
    '(:whitespace @{:bc 1 :bl 1
                    :ec 2 :el 1} " "))
  # =>
  " "

  (lwu/gen
    '(:buffer @{:bc 1 :bl 1
                :ec 12 :el 1} "@\"a buffer\""))
  # =>
  `@"a buffer"`

  (lwu/gen
    '@[:code @{:bc 1 :bl 1
               :ec 8 :el 1}
       (:tuple @{:bc 1 :bl 1
                 :ec 8 :el 1}
               (:symbol @{:bc 2 :bl 1
                          :ec 3 :el 1} "+")
               (:whitespace @{:bc 3 :bl 1
                              :ec 4 :el 1} " ")
               (:number @{:bc 4 :bl 1
                          :ec 5 :el 1} "1")
               (:whitespace @{:bc 5 :bl 1
                              :ec 6 :el 1} " ")
               (:number @{:bc 6 :bl 1
                          :ec 7 :el 1} "1"))])
  # =>
  "(+ 1 1)"

  (lwu/gen
    '@[:code @{}
       (:unreadable @{:bc 1 :bl 1 :ec 22 :el 1}
                    "<core/peg 0xdeedabba>")])
  # =>
  "<core/peg 0xdeedabba>"

  )

(comment

  (def src "{:x  :y \n :z  [:a  :b    :c]}")

  (lwu/gen (lwu/par src))
  # =>
  src

  )

(comment

  (comment

    (let [src (slurp (string (os/getenv "HOME")
                             "/src/janet/src/boot/boot.janet"))]
      (= (string src)
         (lwu/gen (lwu/par src))))

    )

  )

(comment import ../jipper :prefix "")
#! /usr/bin/env janet

(comment import ./helpers :prefix "")
# based on code by corasaurus-hex

# `slice` doesn't necessarily preserve the input type

# XXX: differs from clojure's behavior
#      e.g. (butlast [:a]) would yield nil(?!) in clojure
(defn j/h/butlast
  [indexed]
  (if (empty? indexed)
    nil
    (if (tuple? indexed)
      (tuple/slice indexed 0 -2)
      (array/slice indexed 0 -2))))

(comment

  (j/h/butlast @[:a :b :c])
  # =>
  @[:a :b]

  (j/h/butlast [:a])
  # =>
  []

  )

(defn j/h/rest
  [indexed]
  (if (empty? indexed)
    nil
    (if (tuple? indexed)
      (tuple/slice indexed 1 -1)
      (array/slice indexed 1 -1))))

(comment

  (j/h/rest [:a :b :c])
  # =>
  [:b :c]

  (j/h/rest @[:a])
  # =>
  @[]

  )

# XXX: can pass in array - will get back tuple
(defn j/h/tuple-push
  [tup x & xs]
  (if tup
    [;tup x ;xs]
    [x ;xs]))

(comment

  (j/h/tuple-push [:a :b] :c)
  # =>
  [:a :b :c]

  (j/h/tuple-push nil :a)
  # =>
  [:a]

  (j/h/tuple-push @[] :a)
  # =>
  [:a]

  )

(defn j/h/to-entries
  [val]
  (if (dictionary? val)
    (pairs val)
    val))

(comment

  (sort (j/h/to-entries {:a 1 :b 2}))
  # =>
  @[[:a 1] [:b 2]]

  (j/h/to-entries {})
  # =>
  @[]

  (j/h/to-entries @{:a 1})
  # =>
  @[[:a 1]]

  # XXX: leaving non-dictionaries alone and passing through...
  #      is this desirable over erroring?
  (j/h/to-entries [:a :b :c])
  # =>
  [:a :b :c]

  )

# XXX: when xs is empty, "all" becomes nil
(defn j/h/first-rest-maybe-all
  [xs]
  (if (or (nil? xs) (empty? xs))
    [nil nil nil]
    [(first xs) (j/h/rest xs) xs]))

(comment

  (j/h/first-rest-maybe-all [:a :b])
  # =>
  [:a [:b] [:a :b]]

  (j/h/first-rest-maybe-all @[:a])
  # =>
  [:a @[] @[:a]]

  (j/h/first-rest-maybe-all [])
  # =>
  [nil nil nil]

  # XXX: is this what we want?
  (j/h/first-rest-maybe-all nil)
  # =>
  [nil nil nil]

  )


(comment import ./location :prefix "")
# bl - begin line
# bc - begin column
# el - end line
# ec - end column
(defn j/l/make-attrs
  [& items]
  (zipcoll [:bl :bc :el :ec]
           items))

(defn j/l/atom-node
  [node-type peg-form]
  ~(cmt (capture (sequence (line) (column)
                           ,peg-form
                           (line) (column)))
        ,|[node-type (j/l/make-attrs ;(slice $& 0 -2)) (last $&)]))

(defn j/l/reader-macro-node
  [node-type sigil]
  ~(cmt (capture (sequence (line) (column)
                           ,sigil
                           (any :non-form)
                           :form
                           (line) (column)))
        ,|[node-type (j/l/make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
           ;(slice $& 2 -4)]))

(defn j/l/collection-node
  [node-type open-delim close-delim]
  ~(cmt
     (capture
       (sequence
         (line) (column)
         ,open-delim
         (any :input)
         (choice ,close-delim
                 (error
                   (replace (sequence (line) (column))
                            ,|(string/format
                                "line: %p column: %p missing %p for %p"
                                $0 $1 close-delim node-type))))
         (line) (column)))
     ,|[node-type (j/l/make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
        ;(slice $& 2 -4)]))

(def j/l/loc-grammar
  ~@{:main (sequence (line) (column)
                     (some :input)
                     (line) (column))
     #
     :input (choice :non-form
                    :form)
     #
     :non-form (choice :whitespace
                       :comment)
     #
     :whitespace ,(j/l/atom-node :whitespace
                             '(choice (some (set " \0\f\t\v"))
                                      (choice "\r\n"
                                              "\r"
                                              "\n")))
     # :whitespace
     # (cmt (capture (sequence (line) (column)
     #                         (choice (some (set " \0\f\t\v"))
     #                                 (choice "\r\n"
     #                                         "\r"
     #                                         "\n"))
     #                         (line) (column)))
     #      ,|[:whitespace (make-attrs ;(slice $& 0 -2)) (last $&)])
     #
     :comment ,(j/l/atom-node :comment
                          '(sequence "#"
                                     (any (if-not (set "\r\n") 1))))
     #
     :form (choice # reader macros
                   :fn
                   :quasiquote
                   :quote
                   :splice
                   :unquote
                   # collections
                   :array
                   :bracket-array
                   :tuple
                   :bracket-tuple
                   :table
                   :struct
                   # atoms
                   :number
                   :constant
                   :buffer
                   :string
                   :long-buffer
                   :long-string
                   :keyword
                   :symbol)
     #
     :fn ,(j/l/reader-macro-node :fn "|")
     # :fn (cmt (capture (sequence (line) (column)
     #                             "|"
     #                             (any :non-form)
     #                             :form
     #                             (line) (column)))
     #          ,|[:fn (make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
     #             ;(slice $& 2 -4)])
     #
     :quasiquote ,(j/l/reader-macro-node :quasiquote "~")
     #
     :quote ,(j/l/reader-macro-node :quote "'")
     #
     :splice ,(j/l/reader-macro-node :splice ";")
     #
     :unquote ,(j/l/reader-macro-node :unquote ",")
     #
     :array ,(j/l/collection-node :array "@(" ")")
     # :array
     # (cmt
     #   (capture
     #     (sequence
     #       (line) (column)
     #       "@("
     #       (any :input)
     #       (choice ")"
     #               (error
     #                 (replace (sequence (line) (column))
     #                          ,|(string/format
     #                              "line: %p column: %p missing %p for %p"
     #                              $0 $1 ")" :array))))
     #       (line) (column)))
     #   ,|[:array (make-attrs ;(slice $& 0 2) ;(slice $& -4 -2))
     #      ;(slice $& 2 -4)])
     #
     :tuple ,(j/l/collection-node :tuple "(" ")")
     #
     :bracket-array ,(j/l/collection-node :bracket-array "@[" "]")
     #
     :bracket-tuple ,(j/l/collection-node :bracket-tuple "[" "]")
     #
     :table ,(j/l/collection-node :table "@{" "}")
     #
     :struct ,(j/l/collection-node :struct "{" "}")
     #
     :number ,(j/l/atom-node :number
                         ~(drop (sequence (cmt (capture (some :num-char))
                                               ,scan-number)
                                          (opt (sequence ":" (range "AZ" "az"))))))
     #
     :num-char (choice (range "09" "AZ" "az")
                       (set "&+-._"))
     #
     :constant ,(j/l/atom-node :constant
                           '(sequence (choice "false" "nil" "true")
                                      (not :name-char)))
     #
     :name-char (choice (range "09" "AZ" "az" "\x80\xFF")
                        (set "!$%&*+-./:<?=>@^_"))
     #
     :buffer ,(j/l/atom-node :buffer
                         '(sequence `@"`
                                    (any (choice :escape
                                                 (if-not "\"" 1)))
                                    `"`))
     #
     :escape (sequence "\\"
                       (choice (set `"'0?\abefnrtvz`)
                               (sequence "x" (2 :h))
                               (sequence "u" (4 :h))
                               (sequence "U" (6 :h))
                               (error (constant "bad escape"))))
     #
     :string ,(j/l/atom-node :string
                         '(sequence `"`
                                    (any (choice :escape
                                                 (if-not "\"" 1)))
                                    `"`))
     #
     :long-string ,(j/l/atom-node :long-string
                              :long-bytes)
     #
     :long-bytes {:main (drop (sequence :open
                                        (any (if-not :close 1))
                                        :close))
                  :open (capture :delim :n)
                  :delim (some "`")
                  :close (cmt (sequence (not (look -1 "`"))
                                        (backref :n)
                                        (capture (backmatch :n)))
                              ,=)}
     #
     :long-buffer ,(j/l/atom-node :long-buffer
                              '(sequence "@" :long-bytes))
     #
     :keyword ,(j/l/atom-node :keyword
                          '(sequence ":"
                                     (any :name-char)))
     #
     :symbol ,(j/l/atom-node :symbol
                         '(some :name-char))
     })

(comment

  (get (peg/match j/l/loc-grammar " ") 2)
  # =>
  '(:whitespace @{:bc 1 :bl 1 :ec 2 :el 1} " ")

  (get (peg/match j/l/loc-grammar "true?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 6 :el 1} "true?")

  (get (peg/match j/l/loc-grammar "nil?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 5 :el 1} "nil?")

  (get (peg/match j/l/loc-grammar "false?") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 7 :el 1} "false?")

  (get (peg/match j/l/loc-grammar "# hi there") 2)
  # =>
  '(:comment @{:bc 1 :bl 1 :ec 11 :el 1} "# hi there")

  (get (peg/match j/l/loc-grammar "1_000_000") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 10 :el 1} "1_000_000")

  (get (peg/match j/l/loc-grammar "8.3") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "8.3")

  (get (peg/match j/l/loc-grammar "1e2") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "1e2")

  (get (peg/match j/l/loc-grammar "0xfe") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "0xfe")

  (get (peg/match j/l/loc-grammar "2r01") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "2r01")

  (get (peg/match j/l/loc-grammar "3r101&01") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 9 :el 1} "3r101&01")

  (get (peg/match j/l/loc-grammar "2:u") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 4 :el 1} "2:u")

  (get (peg/match j/l/loc-grammar "-8:s") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 5 :el 1} "-8:s")

  (get (peg/match j/l/loc-grammar "1e2:n") 2)
  # =>
  '(:number @{:bc 1 :bl 1 :ec 6 :el 1} "1e2:n")

  (get (peg/match j/l/loc-grammar "printf") 2)
  # =>
  '(:symbol @{:bc 1 :bl 1 :ec 7 :el 1} "printf")

  (get (peg/match j/l/loc-grammar ":smile") 2)
  # =>
  '(:keyword @{:bc 1 :bl 1 :ec 7 :el 1} ":smile")

  (get (peg/match j/l/loc-grammar `"fun"`) 2)
  # =>
  '(:string @{:bc 1 :bl 1 :ec 6 :el 1} "\"fun\"")

  (get (peg/match j/l/loc-grammar "``long-fun``") 2)
  # =>
  '(:long-string @{:bc 1 :bl 1 :ec 13 :el 1} "``long-fun``")

  (get (peg/match j/l/loc-grammar "@``long-buffer-fun``") 2)
  # =>
  '(:long-buffer @{:bc 1 :bl 1 :ec 21 :el 1} "@``long-buffer-fun``")

  (get (peg/match j/l/loc-grammar `@"a buffer"`) 2)
  # =>
  '(:buffer @{:bc 1 :bl 1 :ec 12 :el 1} "@\"a buffer\"")

  (get (peg/match j/l/loc-grammar "@[8]") 2)
  # =>
  '(:bracket-array @{:bc 1 :bl 1
                     :ec 5 :el 1}
                   (:number @{:bc 3 :bl 1
                              :ec 4 :el 1} "8"))

  (get (peg/match j/l/loc-grammar "@{:a 1}") 2)
  # =>
  '(:table @{:bc 1 :bl 1
             :ec 8 :el 1}
           (:keyword @{:bc 3 :bl 1
                       :ec 5 :el 1} ":a")
           (:whitespace @{:bc 5 :bl 1
                          :ec 6 :el 1} " ")
           (:number @{:bc 6 :bl 1
                      :ec 7 :el 1} "1"))

  (get (peg/match j/l/loc-grammar "~x") 2)
  # =>
  '(:quasiquote @{:bc 1 :bl 1
                  :ec 3 :el 1}
                (:symbol @{:bc 2 :bl 1
                           :ec 3 :el 1} "x"))

  (get (peg/match j/l/loc-grammar "' '[:a :b]") 2)
  # =>
  '(:quote @{:bc 1 :bl 1
             :ec 11 :el 1}
           (:whitespace @{:bc 2 :bl 1
                          :ec 3 :el 1} " ")
           (:quote @{:bc 3 :bl 1
                     :ec 11 :el 1}
                   (:bracket-tuple @{:bc 4 :bl 1
                                     :ec 11 :el 1}
                                   (:keyword @{:bc 5 :bl 1
                                               :ec 7 :el 1} ":a")
                                   (:whitespace @{:bc 7 :bl 1
                                                  :ec 8 :el 1} " ")
                                   (:keyword @{:bc 8 :bl 1
                                               :ec 10 :el 1} ":b"))))

  )

(def j/l/loc-top-level-ast
  (put (table ;(kvs j/l/loc-grammar))
       :main ~(sequence (line) (column)
                        :input
                        (line) (column))))

(defn j/l/par
  [src &opt start single]
  (default start 0)
  (if single
    (if-let [[bl bc tree el ec]
             (peg/match j/l/loc-top-level-ast src start)]
      @[:code (j/l/make-attrs bl bc el ec) tree]
      @[:code])
    (if-let [captures (peg/match j/l/loc-grammar src start)]
      (let [[bl bc] (slice captures 0 2)
            [el ec] (slice captures -3)
            trees (array/slice captures 2 -3)]
        (array/insert trees 0
                      :code (j/l/make-attrs bl bc el ec)))
      @[:code])))

# XXX: backward compatibility
(def j/l/ast j/l/par)

(comment

  (j/l/par "(+ 1 1)")
  # =>
  '@[:code @{:bc 1 :bl 1
             :ec 8 :el 1}
     (:tuple @{:bc 1 :bl 1
               :ec 8 :el 1}
             (:symbol @{:bc 2 :bl 1
                        :ec 3 :el 1} "+")
             (:whitespace @{:bc 3 :bl 1
                            :ec 4 :el 1} " ")
             (:number @{:bc 4 :bl 1
                        :ec 5 :el 1} "1")
             (:whitespace @{:bc 5 :bl 1
                            :ec 6 :el 1} " ")
             (:number @{:bc 6 :bl 1
                        :ec 7 :el 1} "1"))]

  )

(defn j/l/gen*
  [an-ast buf]
  (case (first an-ast)
    :code
    (each elt (drop 2 an-ast)
      (j/l/gen* elt buf))
    #
    :buffer
    (buffer/push-string buf (in an-ast 2))
    :comment
    (buffer/push-string buf (in an-ast 2))
    :constant
    (buffer/push-string buf (in an-ast 2))
    :keyword
    (buffer/push-string buf (in an-ast 2))
    :long-buffer
    (buffer/push-string buf (in an-ast 2))
    :long-string
    (buffer/push-string buf (in an-ast 2))
    :number
    (buffer/push-string buf (in an-ast 2))
    :string
    (buffer/push-string buf (in an-ast 2))
    :symbol
    (buffer/push-string buf (in an-ast 2))
    :whitespace
    (buffer/push-string buf (in an-ast 2))
    #
    :array
    (do
      (buffer/push-string buf "@(")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf))
      (buffer/push-string buf ")"))
    :bracket-array
    (do
      (buffer/push-string buf "@[")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf))
      (buffer/push-string buf "]"))
    :bracket-tuple
    (do
      (buffer/push-string buf "[")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf))
      (buffer/push-string buf "]"))
    :tuple
    (do
      (buffer/push-string buf "(")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf))
      (buffer/push-string buf ")"))
    :struct
    (do
      (buffer/push-string buf "{")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf))
      (buffer/push-string buf "}"))
    :table
    (do
      (buffer/push-string buf "@{")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf))
      (buffer/push-string buf "}"))
    #
    :fn
    (do
      (buffer/push-string buf "|")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf)))
    :quasiquote
    (do
      (buffer/push-string buf "~")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf)))
    :quote
    (do
      (buffer/push-string buf "'")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf)))
    :splice
    (do
      (buffer/push-string buf ";")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf)))
    :unquote
    (do
      (buffer/push-string buf ",")
      (each elt (drop 2 an-ast)
        (j/l/gen* elt buf)))
    ))

(defn j/l/gen
  [an-ast]
  (let [buf @""]
    (j/l/gen* an-ast buf)
    # XXX: leave as buffer?
    (string buf)))

# XXX: backward compatibility
(def j/l/code j/l/gen)

(comment

  (j/l/gen
    [:code])
  # =>
  ""

  (j/l/gen
    '(:whitespace @{:bc 1 :bl 1
                    :ec 2 :el 1} " "))
  # =>
  " "

  (j/l/gen
    '(:buffer @{:bc 1 :bl 1
                :ec 12 :el 1} "@\"a buffer\""))
  # =>
  `@"a buffer"`

  (j/l/gen
    '@[:code @{:bc 1 :bl 1
               :ec 8 :el 1}
       (:tuple @{:bc 1 :bl 1
                 :ec 8 :el 1}
               (:symbol @{:bc 2 :bl 1
                          :ec 3 :el 1} "+")
               (:whitespace @{:bc 3 :bl 1
                              :ec 4 :el 1} " ")
               (:number @{:bc 4 :bl 1
                          :ec 5 :el 1} "1")
               (:whitespace @{:bc 5 :bl 1
                              :ec 6 :el 1} " ")
               (:number @{:bc 6 :bl 1
                          :ec 7 :el 1} "1"))])
  # =>
  "(+ 1 1)"

  )

(comment

  (def src "{:x  :y \n :z  [:a  :b    :c]}")

  (j/l/gen (j/l/par src))
  # =>
  src

  )

(comment

  (comment

    (let [src (slurp (string (os/getenv "HOME")
                             "/src/janet/src/boot/boot.janet"))]
      (= (string src)
         (j/l/gen (j/l/par src))))

    )

  )


(def j/version "2026-01-15_14-02-34")

# exports
(def j/par j/l/par)
(def j/gen j/l/gen)

########################################################################

(defn j/zipper
  ``
  Returns a new zipper consisting of two elements:

  * `a-root` - the passed in root node.
  * `state` - table of info about node's z-location in the tree with keys:
    * `:ls` - left siblings
    * `:pnodes` - path of nodes from root to current z-location
    * `:pstate` - parent node's state
    * `:rs` - right siblings
    * `:changed?` - indicates whether "editing" has occured

  `state` has a prototype table with four functions:

  * :branch? - fn that tests if a node is a branch (has children)
  * :children - fn that returns the child nodes for the given branch.
  * :make-node - fn that takes a node + children and returns a new branch
    node with the same.
  * :make-state - fn for creating a new state
  ``
  [a-root branch?-fn children-fn make-node-fn]
  #
  (defn make-state_
    [&opt ls_ rs_ pnodes_ pstate_ changed?_]
    (table/setproto @{:ls ls_
                      :pnodes pnodes_
                      :pstate pstate_
                      :rs rs_
                      :changed? changed?_}
                    @{:branch? branch?-fn
                      :children children-fn
                      :make-node make-node-fn
                      :make-state make-state_}))
  #
  [a-root (make-state_)])

(comment

  # XXX

  )

# ds - data structure
(defn j/ds-zip
  ``
  Returns a zipper for nested data structures (tuple/array/table/struct),
  given a root data structure.
  ``
  [ds]
  (j/zipper ds
          |(or (dictionary? $) (indexed? $))
          j/h/to-entries
          (fn [p xs] xs)))

(comment

  (def a-node
    [:x [:y :z]])

  (def [the-node the-state]
    (j/ds-zip a-node))

  the-node
  # =>
  a-node

  # merge is used to "remove" the prototype table of `st`
  (merge {} the-state)
  # =>
  @{}

  )

(defn j/node
  "Returns the node at `zloc`."
  [zloc]
  (get zloc 0))

(comment

  (j/node (j/ds-zip [:a :b [:x :y]]))
  # =>
  [:a :b [:x :y]]

  )

(defn j/state
  "Returns the state for `zloc`."
  [zloc]
  (get zloc 1))

(comment

  # merge is used to "remove" the prototype table of `st`
  (merge {}
         (-> (j/ds-zip [:a [:b [:x :y]]])
             j/state))
  # =>
  @{}

  )

(defn j/branch?
  ``
  Returns true if the node at `zloc` is a branch.
  Returns false otherwise.
  ``
  [zloc]
  (((j/state zloc) :branch?) (j/node zloc)))

(comment

  (j/branch? (j/ds-zip [:a :b [:x :y]]))
  # =>
  true

  )

(defn j/children
  ``
  Returns children for a branch node at `zloc`.
  Otherwise throws an error.
  ``
  [zloc]
  (if (j/branch? zloc)
    (((j/state zloc) :children) (j/node zloc))
    (error "Called `children` on a non-branch zloc")))

(comment

  (j/children (j/ds-zip [:a :b [:x :y]]))
  # =>
  [:a :b [:x :y]]

  )

(defn j/make-state
  ``
  Convenience function for calling the :make-state function for `zloc`.
  ``
  [zloc &opt ls rs pnodes pstate changed?]
  (((j/state zloc) :make-state) ls rs pnodes pstate changed?))

(comment

  # merge is used to "remove" the prototype table of `st`
  (merge {}
         (j/make-state (j/ds-zip [:a :b [:x :y]])))
  # =>
  @{}

  )

(defn j/down
  ``
  Moves down the tree, returning the leftmost child z-location of
  `zloc`, or nil if there are no children.
  ``
  [zloc]
  (when (j/branch? zloc)
    (let [[z-node st] zloc
          [k rest-kids kids]
          (j/h/first-rest-maybe-all (j/children zloc))]
      (when kids
        [k
         (j/make-state zloc
                     []
                     rest-kids
                     (if (not (empty? st))
                       (j/h/tuple-push (get st :pnodes) z-node)
                       [z-node])
                     st
                     (get st :changed?))]))))

(comment

  (j/node (j/down (j/ds-zip [:a :b [:x :y]])))
  # =>
  :a

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/branch?)
  # =>
  false

  (try
    (-> (j/ds-zip [:a])
        j/down
        j/children)
    ([e] e))
  # =>
  "Called `children` on a non-branch zloc"

  (deep=
    #
    (merge {}
           (-> [:a [:b [:x :y]]]
               j/ds-zip
               j/down
               j/state))
    #
    '@{:ls ()
       :pnodes ((:a (:b (:x :y))))
       :pstate @{}
       :rs ((:b (:x :y)))})
  # =>
  true

  )

(defn j/right
  ``
  Returns the z-location of the right sibling of the node
  at `zloc`, or nil if there is no such sibling.
  ``
  [zloc]
  (let [[z-node st] zloc
        {:ls ls :rs rs} st
        [r rest-rs rs] (j/h/first-rest-maybe-all rs)]
    (when (and (not (empty? st)) rs)
      [r
       (j/make-state zloc
                   (j/h/tuple-push ls z-node)
                   rest-rs
                   (get st :pnodes)
                   (get st :pstate)
                   (get st :changed?))])))

(comment

  (-> (j/ds-zip [:a :b])
      j/down
      j/right
      j/node)
  # =>
  :b

  (-> (j/ds-zip [:a])
      j/down
      j/right)
  # =>
  nil

  )

(defn j/make-node
  ``
  Returns a branch node, given `zloc`, `a-node` and `kids`.
  ``
  [zloc a-node kids]
  (((j/state zloc) :make-node) a-node kids))

(comment

  (j/make-node (j/ds-zip [:a :b [:x :y]])
             [:a :b] [:x :y])
  # =>
  [:x :y]

  )

(defn j/up
  ``
  Moves up the tree, returning the parent z-location of `zloc`,
  or nil if at the root z-location.
  ``
  [zloc]
  (let [[z-node st] zloc
        {:ls ls
         :pnodes pnodes
         :pstate pstate
         :rs rs
         :changed? changed?} st]
    (when pnodes
      (let [pnode (last pnodes)]
        (if changed?
          [(j/make-node zloc pnode [;ls z-node ;rs])
           (j/make-state zloc
                       (get pstate :ls)
                       (get pstate :rs)
                       (get pstate :pnodes)
                       (get pstate :pstate)
                       true)]
          [pnode pstate])))))

(comment

  (def m-zip
    (j/ds-zip [:a :b [:x :y]]))

  (deep=
    (-> m-zip
        j/down
        j/up)
    m-zip)
  # =>
  true

  (deep=
    (-> m-zip
        j/down
        j/right
        j/right
        j/down
        j/up
        j/up)
    m-zip)
  # =>
  true

  )

# XXX: used by `root` and `df-next`
(defn j/end?
  "Returns true if `zloc` represents the end of a depth-first walk."
  [zloc]
  (= :end (j/state zloc)))

(defn j/root
  ``
  Moves all the way up the tree for `zloc` and returns the node at
  the root z-location.
  ``
  [zloc]
  (if (j/end? zloc)
    (j/node zloc)
    (if-let [p (j/up zloc)]
      (j/root p)
      (j/node zloc))))

(comment

  (def a-zip
    (j/ds-zip [:a :b [:x :y]]))

  (j/node a-zip)
  # =>
  (-> a-zip
      j/down
      j/right
      j/right
      j/down
      j/root)

  )

(defn j/df-next
  ``
  Moves to the next z-location, depth-first.  When the end is
  reached, returns a special z-location detectable via `end?`.
  Does not move if already at the end.
  ``
  [zloc]
  #
  (defn recur
    [a-loc]
    (if (j/up a-loc)
      (or (j/right (j/up a-loc))
          (recur (j/up a-loc)))
      [(j/node a-loc) :end]))
  #
  (if (j/end? zloc)
    zloc
    (or (and (j/branch? zloc) (j/down zloc))
        (j/right zloc)
        (recur zloc))))

(comment

  (def a-zip
    (j/ds-zip [:a :b [:x]]))

  (j/node (j/df-next a-zip))
  # =>
  :a

  (-> a-zip
      j/df-next
      j/df-next
      j/node)
  # =>
  :b

  (-> a-zip
      j/df-next
      j/df-next
      j/df-next
      j/df-next
      j/df-next
      j/end?)
  # =>
  true

  )

(defn j/replace
  "Replaces existing node at `zloc` with `a-node`, without moving."
  [zloc a-node]
  (let [[_ st] zloc]
    [a-node
     (j/make-state zloc
                 (get st :ls)
                 (get st :rs)
                 (get st :pnodes)
                 (get st :pstate)
                 true)]))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      (j/replace :w)
      j/root)
  # =>
  [:w :b [:x :y]]

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/right
      j/down
      (j/replace :w)
      j/root)
  # =>
  [:a :b [:w :y]]

  )

(defn j/edit
  ``
  Replaces the node at `zloc` with the value of `(f node args)`,
  where `node` is the node associated with `zloc`.
  ``
  [zloc f & args]
  (j/replace zloc
           (apply f (j/node zloc) args)))

(comment

  (-> (j/ds-zip [1 2 [8 9]])
      j/down
      (j/edit inc)
      j/root)
  # =>
  [2 2 [8 9]]

  (-> (j/ds-zip [1 2 [8 9]])
      j/down
      (j/edit inc)
      j/right
      (j/edit inc)
      j/right
      j/down
      (j/edit dec)
      j/right
      (j/edit dec)
      j/root)
  # =>
  [2 3 [7 8]]

  )

(defn j/insert-child
  ``
  Inserts `child` as the leftmost child of the node at `zloc`,
  without moving.
  ``
  [zloc child]
  (j/replace zloc
           (j/make-node zloc
                      (j/node zloc)
                      [child ;(j/children zloc)])))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      (j/insert-child :c)
      j/root)
  # =>
  [:c :a :b [:x :y]]

  )

(defn j/append-child
  ``
  Appends `child` as the rightmost child of the node at `zloc`,
  without moving.
  ``
  [zloc child]
  (j/replace zloc
           (j/make-node zloc
                      (j/node zloc)
                      [;(j/children zloc) child])))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      (j/append-child :c)
      j/root)
  # =>
  [:a :b [:x :y] :c]

  )

(defn j/rightmost
  ``
  Returns the z-location of the rightmost sibling of the node at
  `zloc`, or the current node's z-location if there are none to the
  right.
  ``
  [zloc]
  (let [[z-node st] zloc
        {:ls ls :rs rs} st]
    (if (and (not (empty? st))
             (indexed? rs)
             (not (empty? rs)))
      [(last rs)
       (j/make-state zloc
                   (j/h/tuple-push ls z-node ;(j/h/butlast rs))
                   []
                   (get st :pnodes)
                   (get st :pstate)
                   (get st :changed?))]
      zloc)))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/rightmost
      j/node)
  # =>
  [:x :y]

  )

(defn j/remove
  ``
  Removes the node at `zloc`, returning the z-location that would have
  preceded it in a depth-first walk.
  Throws an error if called at the root z-location.
  ``
  [zloc]
  (let [[z-node st] zloc
        {:ls ls
         :pnodes pnodes
         :pstate pstate
         :rs rs} st]
    #
    (defn recur
      [a-zloc]
      (if-let [child (and (j/branch? a-zloc) (j/down a-zloc))]
        (recur (j/rightmost child))
        a-zloc))
    #
    (if (not (empty? st))
      (if (pos? (length ls))
        (recur [(last ls)
                (j/make-state zloc
                            (j/h/butlast ls)
                            rs
                            pnodes
                            pstate
                            true)])
        [(j/make-node zloc (last pnodes) rs)
         (j/make-state zloc
                     (get pstate :ls)
                     (get pstate :rs)
                     (get pstate :pnodes)
                     (get pstate :pstate)
                     true)])
      (error "Called `remove` at root"))))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/remove
      j/node)
  # =>
  :a

  (try
    (j/remove (j/ds-zip [:a :b [:x :y]]))
    ([e] e))
  # =>
  "Called `remove` at root"

  )

(defn j/left
  ``
  Returns the z-location of the left sibling of the node
  at `zloc`, or nil if there is no such sibling.
  ``
  [zloc]
  (let [[z-node st] zloc
        {:ls ls :rs rs} st]
    (when (and (not (empty? st))
               (indexed? ls)
               (not (empty? ls)))
      [(last ls)
       (j/make-state zloc
                   (j/h/butlast ls)
                   [z-node ;rs]
                   (get st :pnodes)
                   (get st :pstate)
                   (get st :changed?))])))

(comment

  (-> (j/ds-zip [:a :b :c])
      j/down
      j/right
      j/right
      j/left
      j/node)
  # =>
  :b

  (-> (j/ds-zip [:a])
      j/down
      j/left)
  # =>
  nil

  )

(defn j/df-prev
  ``
  Moves to the previous z-location, depth-first.
  If already at the root, returns nil.
  ``
  [zloc]
  #
  (defn recur
    [a-zloc]
    (if-let [child (and (j/branch? a-zloc)
                        (j/down a-zloc))]
      (recur (j/rightmost child))
      a-zloc))
  #
  (if-let [left-loc (j/left zloc)]
    (recur left-loc)
    (j/up zloc)))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/df-prev
      j/node)
  # =>
  :a

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/right
      j/down
      j/df-prev
      j/node)
  # =>
  [:x :y]

  )

(defn j/insert-right
  ``
  Inserts `a-node` as the right sibling of the node at `zloc`,
  without moving.
  ``
  [zloc a-node]
  (let [[z-node st] zloc
        {:ls ls :rs rs} st]
    (if (not (empty? st))
      [z-node
       (j/make-state zloc
                   ls
                   [a-node ;rs]
                   (get st :pnodes)
                   (get st :pstate)
                   true)]
      (error "Called `insert-right` at root"))))

(comment

  (def a-zip
    (j/ds-zip [:a :b [:x :y]]))

  (-> a-zip
      j/down
      (j/insert-right :z)
      j/root)
  # =>
  [:a :z :b [:x :y]]

  (try
    (j/insert-right a-zip :e)
    ([e] e))
  # =>
  "Called `insert-right` at root"

  )

(defn j/insert-left
  ``
  Inserts `a-node` as the left sibling of the node at `zloc`,
  without moving.
  ``
  [zloc a-node]
  (let [[z-node st] zloc
        {:ls ls :rs rs} st]
    (if (not (empty? st))
      [z-node
       (j/make-state zloc
                   (j/h/tuple-push ls a-node)
                   rs
                   (get st :pnodes)
                   (get st :pstate)
                   true)]
      (error "Called `insert-left` at root"))))

(comment

  (def a-zip
    (j/ds-zip [:a :b [:x :y]]))

  (-> a-zip
      j/down
      (j/insert-left :z)
      j/root)
  # =>
  [:z :a :b [:x :y]]

  (try
    (j/insert-left a-zip :e)
    ([e] e))
  # =>
  "Called `insert-left` at root"

  )

(defn j/rights
  "Returns siblings to the right of `zloc`."
  [zloc]
  (when-let [st (j/state zloc)]
    (get st :rs)))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/rights)
  # =>
  [:b [:x :y]]

  )

(defn j/lefts
  "Returns siblings to the left of `zloc`."
  [zloc]
  (if-let [st (j/state zloc)
           ls (get st :ls)]
    ls
    []))

(comment

  (-> (j/ds-zip [:a :b])
      j/down
      j/lefts)
  # =>
  []

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/right
      j/lefts)
  # =>
  [:a :b]

  )

(defn j/leftmost
  ``
  Returns the z-location of the leftmost sibling of the node at `zloc`,
  or the current node's z-location if there are no siblings to the left.
  ``
  [zloc]
  (let [[z-node st] zloc
        {:ls ls :rs rs} st]
    (if (and (not (empty? st))
             (indexed? ls)
             (not (empty? ls)))
      [(first ls)
       (j/make-state zloc
                   []
                   [;(j/h/rest ls) z-node ;rs]
                   (get st :pnodes)
                   (get st :pstate)
                   (get st :changed?))]
      zloc)))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/leftmost
      j/node)
  # =>
  :a

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/rightmost
      j/leftmost
      j/node)
  # =>
  :a

  )

(defn j/path
  "Returns the path of nodes that lead to `zloc` from the root node."
  [zloc]
  (when-let [st (j/state zloc)]
    (get st :pnodes)))

(comment

  (j/path (j/ds-zip [:a :b [:x :y]]))
  # =>
  nil

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/path)
  # =>
  [[:a :b [:x :y]]]

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/right
      j/down
      j/path)
  # =>
  [[:a :b [:x :y]] [:x :y]]

  )

(defn j/right-until
  ``
  Try to move right from `zloc`, calling `pred` for each
  right sibling.  If the `pred` call has a truthy result,
  return the corresponding right sibling.
  Otherwise, return nil.
  ``
  [zloc pred]
  (when-let [right-sib (j/right zloc)]
    (if (pred right-sib)
      right-sib
      (j/right-until right-sib pred))))

(comment

  (-> [:code
       [:tuple
        [:comment "# hi there"] [:whitespace "\n"]
        [:symbol "+"] [:whitespace " "]
        [:number "1"] [:whitespace " "]
        [:number "2"]]]
      j/ds-zip
      j/down
      j/right
      j/down
      (j/right-until |(match (j/node $)
                      [:comment]
                      false
                      #
                      [:whitespace]
                      false
                      #
                      true))
      j/node)
  # =>
  [:symbol "+"]

  )

(defn j/left-until
  ``
  Try to move left from `zloc`, calling `pred` for each
  left sibling.  If the `pred` call has a truthy result,
  return the corresponding left sibling.
  Otherwise, return nil.
  ``
  [zloc pred]
  (when-let [left-sib (j/left zloc)]
    (if (pred left-sib)
      left-sib
      (j/left-until left-sib pred))))

(comment

  (-> [:code
       [:tuple
        [:comment "# hi there"] [:whitespace "\n"]
        [:symbol "+"] [:whitespace " "]
        [:number "1"] [:whitespace " "]
        [:number "2"]]]
      j/ds-zip
      j/down
      j/right
      j/down
      j/rightmost
      (j/left-until |(match (j/node $)
                     [:comment]
                     false
                     #
                     [:whitespace]
                     false
                     #
                     true))
      j/node)
  # =>
  [:number "1"]

  )

(defn j/search-from
  ``
  Successively call `pred` on z-locations starting at `zloc`
  in depth-first order.  If a call to `pred` returns a
  truthy value, return the corresponding z-location.
  Otherwise, return nil.
  ``
  [zloc pred]
  (if (pred zloc)
    zloc
    (when-let [next-zloc (j/df-next zloc)]
      (when (j/end? next-zloc)
        (break nil))
      (j/search-from next-zloc pred))))

(comment

  (-> (j/ds-zip [:a :b :c])
      j/down
      (j/search-from |(match (j/node $)
                      :b
                      true))
      j/node)
  # =>
  :b

  (-> (j/ds-zip [:a :b :c])
      j/down
      (j/search-from |(match (j/node $)
                      :d
                      true)))
  # =>
  nil

  (-> (j/ds-zip [:a :b :c])
      j/down
      (j/search-from |(match (j/node $)
                      :a
                      true))
      j/node)
  # =>
  :a

  )

(defn j/search-after
  ``
  Successively call `pred` on z-locations starting after
  `zloc` in depth-first order.  If a call to `pred` returns a
  truthy value, return the corresponding z-location.
  Otherwise, return nil.
  ``
  [zloc pred]
  (when (j/end? zloc)
    (break nil))
  (when-let [next-zloc (j/df-next zloc)]
    (if (pred next-zloc)
      next-zloc
      (j/search-after next-zloc pred))))

(comment

  (-> (j/ds-zip [:b :a :b])
      j/down
      (j/search-after |(match (j/node $)
                       :b
                       true))
      j/left
      j/node)
  # =>
  :a

  (-> (j/ds-zip [:b :a :b])
      j/down
      (j/search-after |(match (j/node $)
                       :d
                       true)))
  # =>
  nil

  (-> (j/ds-zip [:a [:b :c [2 [3 :smile] 5]]])
      (j/search-after |(match (j/node $)
                       [_ :smile]
                       true))
      j/down
      j/node)
  # =>
  3

  )

(defn j/unwrap
  ``
  If the node at `zloc` is a branch node, "unwrap" its children in
  place.  If `zloc`'s node is not a branch node, do nothing.

  Throws an error if `zloc` corresponds to a top-most container.
  ``
  [zloc]
  (unless (j/branch? zloc)
    (break zloc))
  #
  (when (empty? (j/state zloc))
    (error "Called `unwrap` at root"))
  #
  (def kids (j/children zloc))
  (var i (dec (length kids)))
  (var curr-zloc zloc)
  (while (<= 0 i) # right to left
    (set curr-zloc
         (j/insert-right curr-zloc (get kids i)))
    (-- i))
  # try to end up at a sensible spot
  (set curr-zloc
       (j/remove curr-zloc))
  (if-let [ret-zloc (j/right curr-zloc)]
    ret-zloc
    curr-zloc))

(comment

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/right
      j/right
      j/unwrap
      j/root)
  # =>
  [:a :b :x :y]

  (-> (j/ds-zip [:a :b [:x :y]])
      j/down
      j/unwrap
      j/root)
  # =>
  [:a :b [:x :y]]

  (-> (j/ds-zip [[:a]])
      j/down
      j/unwrap
      j/root)
  # =>
  [:a]

  (-> (j/ds-zip [[:a :b] [:x :y]])
      j/down
      j/down
      j/remove
      j/unwrap
      j/root)
  # =>
  [:b [:x :y]]

  (try
    (-> (j/ds-zip [:a :b [:x :y]])
        j/unwrap)
    ([e] e))
  # =>
  "Called `unwrap` at root"

  )

(defn j/wrap
  ``
  Replace nodes from `start-zloc` through `end-zloc` with a single
  node of the same type as `wrap-node` containing the nodes from
  `start-zloc` through `end-zloc`.

  If `end-zloc` is not specified, just wrap `start-zloc`.

  The caller is responsible for ensuring the value of `end-zloc`
  is somewhere to the right of `start-zloc`.  Throws an error if
  an inappropriate value is specified for `end-zloc`.
  ``
  [start-zloc wrap-node &opt end-zloc]
  (default end-zloc start-zloc)
  #
  # 1. collect all nodes to wrap
  #
  (def kids @[])
  (var cur-zloc start-zloc)
  (while (and cur-zloc
              # XXX: expensive?
              (not (deep= (j/node cur-zloc)
                          (j/node end-zloc)))) # left to right
    (array/push kids (j/node cur-zloc))
    (set cur-zloc (j/right cur-zloc)))
  (when (nil? cur-zloc)
    (error "Called `wrap` with invalid value for `end-zloc`."))
  # also collect the last node
  (array/push kids (j/node end-zloc))
  #
  # 2. replace locations that will be removed with non-container nodes
  #
  (def dummy-node
    (j/make-node start-zloc wrap-node (tuple)))
  (set cur-zloc start-zloc)
  # trying to do this together in step 1 is not straight-forward
  # because the desired exiting condition for the while loop depends
  # on cur-zloc becoming end-zloc -- if `replace` were to be used
  # there, the termination condition never gets fulfilled properly.
  (for i 0 (dec (length kids)) # left to right again
    (set cur-zloc
         (-> (j/replace cur-zloc dummy-node)
             j/right)))
  (set cur-zloc
       (j/replace cur-zloc dummy-node))
  #
  # 3. remove all relevant locations
  #
  (def new-node
    (j/make-node start-zloc wrap-node (tuple ;kids)))
  (for i 0 (dec (length kids)) # right to left
    (set cur-zloc
         (j/remove cur-zloc)))
  # 4. put the new container node into place
  (j/replace cur-zloc new-node))

(comment

  (def start-zloc
    (-> (j/ds-zip [:a [:b] :c :x])
        j/down
        j/right))

  (j/node start-zloc)
  # =>
  [:b]

  (-> (j/wrap start-zloc [])
      j/root)
  # =>
  [:a [[:b]] :c :x]

  (def end-zloc
    (j/right start-zloc))

  (j/node end-zloc)
  # =>
  :c

  (-> (j/wrap start-zloc [] end-zloc)
      j/root)
  # =>
  [:a [[:b] :c] :x]

  (try
    (-> (j/wrap end-zloc [] start-zloc)
        j/root)
    ([e] e))
  # =>
  "Called `wrap` with invalid value for `end-zloc`."

  )

########################################################################

(defn j/has-children?
  ``
  Returns true if `a-node` can have children.
  Returns false if `a-node` cannot have children.
  ``
  [a-node]
  (when-let [[head] a-node]
    (truthy? (get {:code true
                   :fn true
                   :quasiquote true
                   :quote true
                   :splice true
                   :unquote true
                   :array true
                   :tuple true
                   :bracket-array true
                   :bracket-tuple true
                   :table true
                   :struct true}
                  head))))

(comment

  (j/has-children?
    [:tuple @{}
     [:symbol @{} "+"] [:whitespace @{} " "]
     [:number @{} "1"] [:whitespace @{} " "]
     [:number @{} "2"]])
  # =>
  true

  (j/has-children? [:number @{} "8"])
  # =>
  false

  )

(defn j/zip
  ``
  Returns a zipper location (zloc or z-location) for a tree
  representing Janet code.
  ``
  [a-tree]
  (defn branch?_
    [a-node]
    (truthy? (and (indexed? a-node)
                  (not (empty? a-node))
                  (j/has-children? a-node))))
  #
  (defn children_
    [a-node]
    (if (branch?_ a-node)
      (slice a-node 2)
      (error "Called `children` on a non-branch node")))
  #
  (defn make-node_
    [a-node kids]
    [(first a-node) (get a-node 1) ;kids])
  #
  (j/zipper a-tree branch?_ children_ make-node_))

(comment

  (def root-node
    @[:code @{} [:number @{} "8"]])

  (def [the-node the-state]
    (j/zip root-node))

  the-node
  # =>
  root-node

  # merge is used to "remove" the prototype table of `st`
  (merge {} the-state)
  # =>
  @{}

  )

(defn j/attrs
  ``
  Return the attributes table for the node of a z-location.  The
  attributes table contains at least bounds of the node by 1-based line
  and column numbers.
  ``
  [zloc]
  (get (j/node zloc) 1))

(comment

  (-> (j/par "(+ 1 3)")
      j/zip
      j/down
      j/attrs)
  # =>
  @{:bc 1 :bl 1 :ec 8 :el 1}

  )

(defn j/zip-down
  ``
  Convenience function that returns a zipper which has
  already had `down` called on it.
  ``
  [a-tree]
  (-> (j/zip a-tree)
      j/down))

(comment

  (-> (j/par "(+ 1 3)")
      j/zip-down
      j/node)
  # =>
  [:tuple @{:bc 1 :bl 1 :ec 8 :el 1}
   [:symbol @{:bc 2 :bl 1 :ec 3 :el 1} "+"]
   [:whitespace @{:bc 3 :bl 1 :ec 4 :el 1} " "]
   [:number @{:bc 4 :bl 1 :ec 5 :el 1} "1"]
   [:whitespace @{:bc 5 :bl 1 :ec 6 :el 1} " "]
   [:number @{:bc 6 :bl 1 :ec 7 :el 1} "3"]]

  (-> (j/par "(/ 1 8)")
      j/zip-down
      j/root)
  # =>
  @[:code @{:bc 1 :bl 1 :ec 8 :el 1}
    [:tuple @{:bc 1 :bl 1 :ec 8 :el 1}
            [:symbol @{:bc 2 :bl 1 :ec 3 :el 1} "/"]
            [:whitespace @{:bc 3 :bl 1 :ec 4 :el 1} " "]
            [:number @{:bc 4 :bl 1 :ec 5 :el 1} "1"]
            [:whitespace @{:bc 5 :bl 1 :ec 6 :el 1} " "]
            [:number @{:bc 6 :bl 1 :ec 7 :el 1} "8"]]]

  )

# wsc == whitespace, comment
(defn j/right-skip-wsc
  ``
  Try to move right from `zloc`, skipping over whitespace
  and comment nodes.

  When at least one right move succeeds, return the z-location
  for the last successful right move destination.  Otherwise,
  return nil.
  ``
  [zloc]
  (j/right-until zloc
               |(match (j/node $)
                  [:whitespace]
                  false
                  #
                  [:comment]
                  false
                  #
                  true)))

(comment

  (-> (j/par (string "(# hi there\n"
                   "+ 1 2)"))
      j/zip-down
      j/down
      j/right-skip-wsc
      j/node)
  # =>
  [:symbol @{:bc 1 :bl 2 :ec 2 :el 2} "+"]

  (-> (j/par "(:a)")
      j/zip-down
      j/down
      j/right-skip-wsc)
  # =>
  nil

  )

(defn j/left-skip-wsc
  ``
  Try to move left from `zloc`, skipping over whitespace
  and comment nodes.

  When at least one left move succeeds, return the z-location
  for the last successful left move destination.  Otherwise,
  return nil.
  ``
  [zloc]
  (j/left-until zloc
              |(match (j/node $)
                 [:whitespace]
                 false
                 #
                 [:comment]
                 false
                 #
                 true)))

(comment

  (-> (j/par (string "(# hi there\n"
                   "+ 1 2)"))
      j/zip-down
      j/down
      j/right-skip-wsc
      j/right-skip-wsc
      j/left-skip-wsc
      j/node)
  # =>
  [:symbol @{:bc 1 :bl 2 :ec 2 :el 2} "+"]

  (-> (j/par "(:a)")
      j/zip-down
      j/down
      j/left-skip-wsc)
  # =>
  nil

  )

# ws == whitespace
(defn j/right-skip-ws
  ``
  Try to move right from `zloc`, skipping over whitespace
  nodes.

  When at least one right move succeeds, return the z-location
  for the last successful right move destination.  Otherwise,
  return nil.
  ``
  [zloc]
  (j/right-until zloc
               |(match (j/node $)
                  [:whitespace]
                  false
                  #
                  true)))

(comment

  (-> (j/par (string "( # hi there\n"
                   "+ 1 2)"))
      j/zip-down
      j/down
      j/right-skip-ws
      j/node)
  # =>
  [:comment @{:bc 3 :bl 1 :ec 13 :el 1} "# hi there"]

  (-> (j/par "(:a)")
      j/zip-down
      j/down
      j/right-skip-ws)
  # =>
  nil

  )

(defn j/left-skip-ws
  ``
  Try to move left from `zloc`, skipping over whitespace
  nodes.

  When at least one left move succeeds, return the z-location
  for the last successful left move destination.  Otherwise,
  return nil.
  ``
  [zloc]
  (j/left-until zloc
              |(match (j/node $)
                 [:whitespace]
                 false
                 #
                 true)))

(comment

  (-> (j/par (string "(# hi there\n"
                   "+ 1 2)"))
      j/zip-down
      j/down
      j/right
      j/right
      j/left-skip-ws
      j/node)
  # =>
  [:comment @{:bc 2 :bl 1 :ec 12 :el 1} "# hi there"]

  (-> (j/par "(:a)")
      j/zip-down
      j/down
      j/left-skip-ws)
  # =>
  nil

  )



(defn bind/deprintf
  [fmt & args]
  (when (os/getenv "JREF_VERBOSE")
    (eprintf fmt ;args)))

(def bind/form-table
  {"if-let" true
   "let" true
   "when-let" true})

(comment

  (def src
    ``
    (let [x 1 y 2] (+ x y))
    ``)

  (def zloc
    (-> (lwu/par src)
        j/zip-down))

  (def let-zloc
    (j/search-from zloc
                   |(match (j/node $)
                      [:symbol _ "let"]
                      true)))

  (def binding-zloc
    (j/right-skip-wsc let-zloc))

  (j/node binding-zloc)
  # =>
  '(:bracket-tuple @{:bc 6 :bl 1 :ec 15 :el 1}
                   (:symbol @{:bc 7 :bl 1 :ec 8 :el 1} "x")
                   (:whitespace @{:bc 8 :bl 1 :ec 9 :el 1} " ")
                   (:number @{:bc 9 :bl 1 :ec 10 :el 1} "1")
                   (:whitespace @{:bc 10 :bl 1 :ec 11 :el 1} " ")
                   (:symbol @{:bc 11 :bl 1 :ec 12 :el 1} "y")
                   (:whitespace @{:bc 12 :bl 1 :ec 13 :el 1} " ")
                   (:number @{:bc 13 :bl 1 :ec 14 :el 1} "2"))

  (-> binding-zloc
      j/down
      j/right
      j/right
      j/right
      # should be whitespace
      (j/edit |(let [original-item (get $ 2)]
                 [:whitespace @{} "\n"]))
      j/root
      lwu/gen)
  # =>
  ``
  (let [x 1
  y 2] (+ x y))
  ``

  (def src-2
    ``
    (let [x 1 y 2 z 3] (+ x y z))
    ``)

  (def zloc-2
    (-> (lwu/par src-2)
        j/zip-down))

  (def let-zloc-2
    (j/search-from zloc-2
                   |(match (j/node $)
                      [:symbol _ "let"]
                      true)))

  (def binding-zloc-2
    (j/right-skip-wsc let-zloc-2))

  (j/node binding-zloc-2)
  # =>
  '(:bracket-tuple @{:bc 6 :bl 1 :ec 19 :el 1}
                   (:symbol @{:bc 7 :bl 1 :ec 8 :el 1} "x")
                   (:whitespace @{:bc 8 :bl 1 :ec 9 :el 1} " ")
                   (:number @{:bc 9 :bl 1 :ec 10 :el 1} "1")
                   (:whitespace @{:bc 10 :bl 1 :ec 11 :el 1} " ")
                   (:symbol @{:bc 11 :bl 1 :ec 12 :el 1} "y")
                   (:whitespace @{:bc 12 :bl 1 :ec 13 :el 1} " ")
                   (:number @{:bc 13 :bl 1 :ec 14 :el 1} "2")
                   (:whitespace @{:bc 14 :bl 1 :ec 15 :el 1} " ")
                   (:symbol @{:bc 15 :bl 1 :ec 16 :el 1} "z")
                   (:whitespace @{:bc 16 :bl 1 :ec 17 :el 1} " ")
                   (:number @{:bc 17 :bl 1 :ec 18 :el 1} "3"))

  (-> binding-zloc-2
      j/down
      j/right
      j/right
      j/right
      # should be one target whitespace
      (j/replace [:whitespace @{:message "hello"} "\n"])
      j/right
      j/right
      j/right
      j/right
      # should be another target whitespace
      (j/replace [:whitespace @{:message "smile!"} "\n"])
      j/up
      j/node)
  # =>
  '(:bracket-tuple @{:bc 6 :bl 1 :ec 19 :el 1}
                   (:symbol @{:bc 7 :bl 1 :ec 8 :el 1} "x")
                   (:whitespace @{:bc 8 :bl 1 :ec 9 :el 1} " ")
                   (:number @{:bc 9 :bl 1 :ec 10 :el 1} "1")
                   (:whitespace @{:message "hello"} "\n")
                   (:symbol @{:bc 11 :bl 1 :ec 12 :el 1} "y")
                   (:whitespace @{:bc 12 :bl 1 :ec 13 :el 1} " ")
                   (:number @{:bc 13 :bl 1 :ec 14 :el 1} "2")
                   (:whitespace @{:message "smile!"} "\n")
                   (:symbol @{:bc 15 :bl 1 :ec 16 :el 1} "z")
                   (:whitespace @{:bc 16 :bl 1 :ec 17 :el 1} " ")
                   (:number @{:bc 17 :bl 1 :ec 18 :el 1} "3"))

  (-> binding-zloc-2
      j/down
      j/right
      j/right
      j/right
      # should be one target whitespace
      (j/edit |(let [[_ tbl _] $]
                 [:whitespace (put tbl :message "hello") "\n"]))
      j/right
      j/right
      j/right
      j/right
      # should be another target whitespace
      (j/edit |(let [[_ tbl _] $]
                 [:whitespace (put tbl :message "smile!") "\n"]))
      j/up
      j/node)
  # =>
  '(:bracket-tuple @{:bc 6 :bl 1 :ec 19 :el 1}
                   (:symbol @{:bc 7 :bl 1 :ec 8 :el 1} "x")
                   (:whitespace @{:bc 8 :bl 1 :ec 9 :el 1} " ")
                   (:number @{:bc 9 :bl 1 :ec 10 :el 1} "1")
                   (:whitespace
                     @{:bc 10 :bl 1 :ec 11 :el 1 :message "hello"} "\n")
                   (:symbol @{:bc 11 :bl 1 :ec 12 :el 1} "y")
                   (:whitespace @{:bc 12 :bl 1 :ec 13 :el 1} " ")
                   (:number @{:bc 13 :bl 1 :ec 14 :el 1} "2")
                   (:whitespace
                     @{:bc 14 :bl 1 :ec 15 :el 1 :message "smile!"} "\n")
                   (:symbol @{:bc 15 :bl 1 :ec 16 :el 1} "z")
                   (:whitespace @{:bc 16 :bl 1 :ec 17 :el 1} " ")
                   (:number @{:bc 17 :bl 1 :ec 18 :el 1} "3"))

  )

# XXX: assuming code is not unusual
(defn bind/handle-binding-form
  [binding-zloc]
  (assert (match (j/node binding-zloc)
            [the-type]
            (get {:array true
                  :bracket-array true
                  :bracket-tuple true
                  :tuple true}
                 the-type))
          (string/format "Unexpected node: %p"
                         (j/node binding-zloc)))
  # count how many nodes
  (def n-nodes
    (length (drop 2 (j/node binding-zloc))))
  # move down into the collection
  (var curr-zloc
    (->> binding-zloc
         j/down))
  (assert curr-zloc
          (string/format "Unexpected empty binding collection: %p"
                         (j/node binding-zloc)))
  # every 4th node is target whitespace.  the last 3 nodes should be
  # ignored as they are right before the closing delim and thus should
  # not have a newline placed after them
  (for i 0 (/ (- n-nodes 3) 4)
    (set curr-zloc
         (-> curr-zloc
             j/right
             j/right
             j/right
             (j/edit |(let [[_ tbl _] $]
                        [:whitespace tbl "\n"]))
             j/right)))
  # return the rightmost node
  (j/rightmost curr-zloc))

(comment

  (def src-2
    ``
    (let [x 1 y 2 z 3] (+ x y z))
    ``)

  (def zloc-2
    (-> (lwu/par src-2)
        j/zip-down))

  (def let-zloc-2
    (j/search-from zloc-2
                   |(match (j/node $)
                      [:symbol _ "let"]
                      true)))

  (def binding-zloc-2
    (j/right-skip-wsc let-zloc-2))

  (def handled-zloc
    (bind/handle-binding-form binding-zloc-2))

  (j/node handled-zloc)
  # =>
  '(:number @{:bc 17 :bl 1 :ec 18 :el 1} "3")

  )

(defn bind/inject-newlines
  [form-zloc]
  (var curr-zloc form-zloc)
  (while (not (j/end? curr-zloc))
    (def result
      (match (j/node curr-zloc)
        [:symbol _ name]
        (when (get bind/form-table name)
          (bind/handle-binding-form (j/right-skip-wsc curr-zloc)))))
    (set curr-zloc
         (if result
           (j/df-next result)
           (j/df-next curr-zloc))))
  #
  curr-zloc)

(comment

  (def src-2
    ``
    (let [x 1 y 2 z 3] (+ x y z))
    ``)

  (def zloc-2
    (-> (lwu/par src-2)
        j/zip-down))

  (def result-2
    (bind/inject-newlines zloc-2))

  (lwu/gen (j/root result-2))
  # =>
  ``
  (let [x 1
  y 2
  z 3] (+ x y z))
  ``

  (def src-3
    ``
    (do
      (let [x 1 y 2 z 3] (+ x y z))
      (let [a :x b :y] (string a b)))
    ``)

  (def zloc-3
    (-> (lwu/par src-3)
        j/zip-down))

  (def result-3
    (bind/inject-newlines zloc-3))

  (->> result-3
       j/root
       lwu/gen)
  # =>
  ``
  (do
    (let [x 1
  y 2
  z 3] (+ x y z))
    (let [a :x
  b :y] (string a b)))
  ``

  )

(defn bind/process-binding-forms
  [src]
  (def form-zloc
    (-> (lwu/par src)
        j/zip-down))
  (def result
    (bind/inject-newlines form-zloc))
  #
  (-> result
      j/root
      lwu/gen))

(comment

  (bind/process-binding-forms
    ``
    (let [_0000c2 (<cfunction fiber/new> (fn []
                                           (do-your-best)) :ie) _0000c3 (<function resume> _0000c2)]
      (if (<function => (<cfunction fiber/status> _0000c2) :error)
        (do
          (def e
            _0000c3)
          (def fib
            _0000c2)
          (debug/stacktrace fib e ""))
        _0000c3))
    ``)
  # =>
  ``
  (let [_0000c2 (<cfunction fiber/new> (fn []
                                         (do-your-best)) :ie)
  _0000c3 (<function resume> _0000c2)]
    (if (<function => (<cfunction fiber/status> _0000c2) :error)
      (do
        (def e
          _0000c3)
        (def fib
          _0000c2)
        (debug/stacktrace fib e ""))
      _0000c3))
  ``

  )

(comment import ./format/code :prefix "")
(comment import ../location-with-unreadable :prefix "")


# keys are numbers that represent which element of a call (involving
# the symbol associatated with the name) is the first one to have a
# newline after it.  all subsequent things have newlines after them
# for simplicity.
#
# e.g. "do" is associated with 0 because in a "do" form:
#
#      (do
#        form-1
#        form-2
#        ...
#        form-n)
#
#      the 0-th item ("do") is the first element of the call (tuple)
#      with a newline after it, and all subsequent elements have
#      newlines after them.
(def code/nl-things
  {0 ["comment" "cond" "coro"
      "do"
      "forever"
      "protect"
      "try"
      "upscope"]
   1 ["accumulate" "and" "assert"
      "case" "count"
      "def" "defdyn" "defer" "defn" "drop-until" "drop-while"
      "edefer"
      "filter" "find" "find-index" "fn"
      "generate"
      "if" "if-let" "if-not" "if-with"
      "keep"
      "label" "let" "loop"
      "map" "mapcat"
      "nan?"
      "or"
      "prompt"
      "reduce" "repeat"
      "seq" "set"
      "tabseq" "take-until" "take-while"
      "unless"
      "var"
      "when" "when-let" "when-with" "while" "with" "with-syms"]
   2 ["each" "eachk" "eachp"]
   3 ["for" "forv"]
   # means don't use newlines -- here for book-keeping
   -1 ["%=" "*=" "++" "+=" "--" "-=" "/="
       "array/concat" "array?" "asm"
       "boolean?" "break" "buffer?" "bytes?"
       "cfunction?" "chr" "comp" "compare" "complement"
       "dec" "default" "dictionary?" "drop"
       # XXX
       "errorf" "even?" "extreme"
       "fiber?" "first" "function?"
       "identity" "inc" "index-of" "indexed?" "interpose"
       # XXX
       "juxt" "juxt*"
       "keyword?"
       "last"
       # XXX
       #"mapcat"
       "max" "max-of" "mean" "min" "min-of"
       "neg?" "number?"
       "odd?" "one?" "os/strftime"
       "pos?"
       "product"
       "quasiquote" "quote"
       "range" "return"
       "sort" "sort-by" "sorted" "splice" "string?" "struct?" "sum"
       "symbol?"
       "table?" "take" "toggle" "tuple?"
       "unquote"
       "zero?"]})

(def code/nl-tbl
  (let [tbl @{}]
    (eachp [num names] code/nl-things
      (when (>= num 0)
        (each name names
          (put tbl
               name (fn [i] (>= i num))))))
    tbl))

(defn code/fmt
  [src]
  (def buf @"")
  (def an-ast (lwu/par src))
  (def indt-stack @[""])
  (var cur-col 0)
  #
  (defn fmt*
    [an-ast buf]
    (def the-type (first an-ast))
    (cond
      (= :code the-type)
      (let [items (filter |(and (not= :whitespace (first $))
                                (not= :comment (first $)))
                          (drop 2 an-ast))]
        (each elt items
          (fmt* elt buf)
          (buffer/push-string buf "\n\n"))
        (when (string/has-suffix? "\n\n" buf)
          (buffer/popn buf 2)))
      #
      (= :tuple the-type)
      (let [open-delim "("
            close-delim ")"
            items (filter |(and (not= :whitespace (first $))
                                (not= :comment (first $)))
                          (drop 2 an-ast))
            has-dict? (find |(or (= :struct (first $))
                                 (= :table (first $)))
                            items)]
        (+= cur-col (length open-delim))
        (buffer/push-string buf open-delim)
        (array/push indt-stack
                    (string/repeat " " cur-col))
        # different strategy if any dictionaries are elements
        (if has-dict?
          (do
            (each elt items
              (fmt* elt buf)
              #
              (set cur-col (length (array/peek indt-stack)))
              (buffer/push-string buf "\n")
              (buffer/push-string buf (array/peek indt-stack)))
            (when (string/has-suffix? (string "\n" (array/peek indt-stack))
                                      buf)
              (buffer/popn buf (+ 1 (length (array/peek indt-stack))))))
          (do
            (when (pos? (length items))
              (def [_ _ name-of-first]
                (first items))
              (def nl-fn
                (get code/nl-tbl name-of-first
                     (fn [i] false)))
              (for i 0 (length items)
                (fmt* (get items i) buf)
                (if (nl-fn i)
                  (buffer/push-string buf "\n")
                  (buffer/push-string buf " "))
                # XXX: is this right?
                (set cur-col (length (array/peek indt-stack))))
              (when (or (string/has-suffix? "\n" buf)
                        (string/has-suffix? " " buf))
                (buffer/popn buf 1)))))
          # XXX: is this correct?
        (set cur-col (length (array/peek indt-stack)))
        (array/pop indt-stack)
        (buffer/push-string buf close-delim))
      #
      (get {:unreadable true
            #
            :whitespace true
            :comment true
            #
            :buffer true
            :constant true
            :keyword true
            :long-buffer true
            :long-string true
            :number true
            :string true
            :symbol true}
           the-type)
      (let [item (in an-ast 2)]
        (+= cur-col (length item))
        (buffer/push-string buf item))
      #
      (get {:array true
            :bracket-array true
            :bracket-tuple true}
           the-type)
      (let [[open-delim close-delim]
            (case the-type
              :array ["@(" ")"]
              :bracket-array ["@[" "]"]
              :bracket-tuple ["[" "]"])
            items (filter |(and (not= :whitespace (first $))
                                (not= :comment (first $)))
                          (drop 2 an-ast))
            has-dict? (find |(or (= :struct (first $))
                                 (= :table (first $)))
                            items)]
        (+= cur-col (length open-delim))
        (buffer/push-string buf open-delim)
        (array/push indt-stack
                    (string/repeat " " cur-col))
        # different strategy if any dictionaries are elements
        (if has-dict?
          (do
            (each elt items
              (fmt* elt buf)
              #
              (set cur-col (length (array/peek indt-stack)))
              (buffer/push-string buf "\n")
              (buffer/push-string buf (array/peek indt-stack)))
            (when (string/has-suffix? (string "\n" (array/peek indt-stack))
                                      buf)
              (buffer/popn buf (+ 1 (length (array/peek indt-stack))))))
          (do
            (each elt items
              (fmt* elt buf)
              #
              (set cur-col (length (array/peek indt-stack)))
              (buffer/push-string buf " "))
            (when (string/has-suffix? " " buf)
              (buffer/popn buf 1))))
        # XXX: is this correct?
        (set cur-col (length (array/peek indt-stack)))
        (array/pop indt-stack)
        (buffer/push-string buf close-delim))
      #
      (get {:struct true
            :table true}
           the-type)
      (let [[open-delim close-delim]
            (case the-type
              :struct ["{" "}"]
              :table ["@{" "}"])
            items (filter |(and (not= :whitespace (first $))
                                (not= :comment (first $)))
                          (drop 2 an-ast))]
        (+= cur-col (length open-delim))
        (buffer/push-string buf open-delim)
        (array/push indt-stack
                    (string/repeat " " cur-col))
        # format elements
        (for i 0 (/ (length items) 2)
          (def idx (* i 2))
          (fmt* (get items idx) buf)
          #
          (+= cur-col 1)
          (buffer/push-string buf " ")
          #
          (fmt* (get items (inc idx)) buf)
          #
          (set cur-col (length (array/peek indt-stack)))
          (buffer/push-string buf "\n")
          (buffer/push-string buf (array/peek indt-stack)))
        # XXX: is 0 correct, here?
        (set cur-col 0)
        (when (string/has-suffix? (string "\n" (array/peek indt-stack))
                                  buf)
          (buffer/popn buf (+ 1 (length (array/peek indt-stack)))))
        (array/pop indt-stack)
        (buffer/push-string buf close-delim))
      # XXX: janet itself won't print things with any of the following?
      (get {:fn true
            :quasiquote true
            :quote true
            :splice true
            :unquote true}
           the-type)
      (let [sigil
            (case the-type
              :fn "|"
              :quasiquote "~"
              :quote "'"
              :splice ";"
              :unquote ",")
            # XXX: should only be one thing left?
            items (filter |(and (not= :whitespace (first $))
                                (not= :comment (first $)))
                          (drop 2 an-ast))]
        (+= cur-col (length sigil))
        (buffer/push-string buf sigil)
        (each elt items
          (fmt* elt buf)))
      #
      (errorf "Unexpected type: %s" the-type)
      )
    buf)
  #
  (fmt* an-ast buf))

(comment

  (def src-0
    ``
    (if true (do (print)))
    ``)

  (code/fmt src-0)
  # =>
  @``
   (if true
   (do
   (print)))
   ``

  (def src-1
    ``
    (def a 1)
    ``)

  (code/fmt src-1)
  # =>
  @``
   (def a
   1)
   ``

  (def src-2
    ``
    (var b 2)
    ``)

  (code/fmt src-2)
  # =>
  @``
   (var b
   2)
   ``

  (def src-3
    ``
    (while true (++ i) i)
    ``)

  (code/fmt src-3)
  # =>
  @``
   (while true
   (++ i)
   i)
   ``

  (def src-4
    ``
    (let [x 1] (+ x 2))
    ``)

  (code/fmt src-4)
  # =>
  @``
   (let [x 1]
   (+ x 2))
   ``

  (def src-5
    ``
    (if true :smile :jump)
    ``)

  (code/fmt src-5)
  # =>
  @``
   (if true
   :smile
   :jump)
   ``

  (def src-6
    ``
    (fn [x] (+ x 1))
    ``)

  (code/fmt src-6)
  # =>
  @``
   (fn [x]
   (+ x 1))
   ``

  (def src-7
    ``
    (def a 1) (while true (break))
    ``)

  (code/fmt src-7)
  # =>
  @``
   (def a
   1)

   (while true
   (break))
   ``

  )

(comment import ./format/data :prefix "")
(comment import ../location-with-unreadable :prefix "")


(defn data/fmt
  [src]
  (def buf @"")
  (def an-ast (lwu/par src))
  (def indt-stack @[""])
  (var cur-col 0)
  #
  (defn fmt*
    [an-ast buf]
    (def the-type (first an-ast))
    (cond
      (= :code the-type)
      (each elt (drop 2 an-ast)
        (fmt* elt buf))
      #
      (get {:unreadable true
            #
            :whitespace true
            :comment true
            #
            :buffer true
            :constant true
            :keyword true
            :long-buffer true
            :long-string true
            :number true
            :string true
            :symbol true}
           the-type)
      (let [item (in an-ast 2)]
        (+= cur-col (length item))
        (buffer/push-string buf item))
      #
      (get {:array true
            :bracket-array true
            :bracket-tuple true
            :tuple true}
           the-type)
      (let [[open-delim close-delim]
            (case the-type
              :array ["@(" ")"]
              :bracket-array ["@[" "]"]
              :bracket-tuple ["[" "]"]
              :tuple ["(" ")"])
            items (filter |(and (not= :whitespace (first $))
                                (not= :comment (first $)))
                          (drop 2 an-ast))
            has-dict? (find |(or (= :struct (first $))
                                 (= :table (first $)))
                            items)]
        (+= cur-col (length open-delim))
        (buffer/push-string buf open-delim)
        (array/push indt-stack
                    (string/repeat " " cur-col))
        # different strategy if any dictionaries are elements
        (if has-dict?
          (do
            (each elt items
              (fmt* elt buf)
              #
              (set cur-col (length (array/peek indt-stack)))
              (buffer/push-string buf "\n")
              (buffer/push-string buf (array/peek indt-stack)))
            (when (string/has-suffix? (string "\n" (array/peek indt-stack))
                                      buf)
              (buffer/popn buf (+ 1 (length (array/peek indt-stack))))))
          (do
            (each elt items
              (fmt* elt buf)
              #
              (set cur-col (length (array/peek indt-stack)))
              (buffer/push-string buf " "))
            (when (string/has-suffix? " " buf)
              (buffer/popn buf 1))))
        # XXX: is this correct?
        (set cur-col (length (array/peek indt-stack)))
        (array/pop indt-stack)
        (buffer/push-string buf close-delim))
      #
      (get {:struct true
            :table true}
           the-type)
      (let [[open-delim close-delim]
            (case the-type
              :struct ["{" "}"]
              :table ["@{" "}"])
            items (filter |(and (not= :whitespace (first $))
                                (not= :comment (first $)))
                          (drop 2 an-ast))]
        (+= cur-col (length open-delim))
        (buffer/push-string buf open-delim)
        (array/push indt-stack
                    (string/repeat " " cur-col))
        # format elements
        (for i 0 (/ (length items) 2)
          (def idx (* i 2))
          (fmt* (get items idx) buf)
          #
          (+= cur-col 1)
          (buffer/push-string buf " ")
          #
          (fmt* (get items (inc idx)) buf)
          #
          (set cur-col (length (array/peek indt-stack)))
          (buffer/push-string buf "\n")
          (buffer/push-string buf (array/peek indt-stack)))
        # XXX: is 0 correct, here?
        (set cur-col 0)
        (when (string/has-suffix? (string "\n" (array/peek indt-stack))
                                  buf)
          (buffer/popn buf (+ 1 (length (array/peek indt-stack)))))
        (array/pop indt-stack)
        (buffer/push-string buf close-delim))
      # XXX: janet itself won't print things with any of the following?
      (get {:fn true
            :quasiquote true
            :quote true
            :splice true
            :unquote true}
           the-type)
      (let [sigil
            (case the-type
              :fn "|"
              :quasiquote "~"
              :quote "'"
              :splice ";"
              :unquote ",")
            # XXX: should only be one thing left?
            items (filter |(and (not= :whitespace (first $))
                                (not= :comment (first $)))
                          (drop 2 an-ast))]
        (+= cur-col (length sigil))
        (buffer/push-string buf sigil)
        (each elt items
          (fmt* elt buf)))
      #
      (errorf "Unexpected type: %s" the-type)
      )
    buf)
  #
  (fmt* an-ast buf))

(comment

  (def src-0
    ``
    @{main @{:doc "(main)\n\n" :source-map ("dogs.janet" 11 1) :value <function main>} odin @{:source-map ("dogs.janet" 1 1) :value @{:name "Odin" :type "German Shepherd"}} people @{:source-map ("dogs.janet" 4 1) :value ({:dogs (@{:name "Skadi" :type "German Shepherd"} @{:name "Odin" :type "German Shepherd"}) :name "ian"} {:dogs (@{:name "Skadi" :type "German Shepherd"} @{:name "Odin" :type "German Shepherd"}) :name "kelsey"} {:dogs () :name "jeffrey"})} skadi @{:source-map ("dogs.janet" 2 1) :value @{:name "Skadi" :type "German Shepherd"}} :current-file "dogs.janet" :macro-lints @[] :source "dogs.janet"}
    ``)

  (data/fmt src-0)
  # =>
  @``
   @{main @{:doc "(main)\n\n"
            :source-map ("dogs.janet" 11 1)
            :value <function main>}
     odin @{:source-map ("dogs.janet" 1 1)
            :value @{:name "Odin"
                     :type "German Shepherd"}}
     people @{:source-map ("dogs.janet" 4 1)
              :value ({:dogs (@{:name "Skadi"
                                :type "German Shepherd"}
                              @{:name "Odin"
                                :type "German Shepherd"})
                       :name "ian"}
                      {:dogs (@{:name "Skadi"
                                :type "German Shepherd"}
                              @{:name "Odin"
                                :type "German Shepherd"})
                       :name "kelsey"}
                      {:dogs ()
                       :name "jeffrey"})}
     skadi @{:source-map ("dogs.janet" 2 1)
             :value @{:name "Skadi"
                      :type "German Shepherd"}}
     :current-file "dogs.janet"
     :macro-lints @[]
     :source "dogs.janet"}
   ``

  (def src-1
    ``
    @{main @{:doc "(main)\n\n" :val "hello"} odin @{:value @{:name "Odin" :type "German Shepherd" :smell "good"}} skadi @{:value @{:name "Skadi" :type "German Shepherd"}} :current-file "dogs.janet" :source "dogs.janet"}
    ``)

  (data/fmt src-1)
  # =>
  @``
   @{main @{:doc "(main)\n\n"
            :val "hello"}
     odin @{:value @{:name "Odin"
                     :type "German Shepherd"
                     :smell "good"}}
     skadi @{:value @{:name "Skadi"
                      :type "German Shepherd"}}
     :current-file "dogs.janet"
     :source "dogs.janet"}
   ``

  (def src-2
    "{:a 1 :b 2 :c 3}")

  (data/fmt src-2)
  # =>
  @``
   {:a 1
    :b 2
    :c 3}
   ``

  (def src-3
    "{:a {:x 8 :y 9} :b 2 :c 3}")

  (data/fmt src-3)
  # =>
  @``
   {:a {:x 8
        :y 9}
    :b 2
    :c 3}
   ``

  (def src-4
    "@{:a 1 :b 2 :c 3}")

  (data/fmt src-4)
  # =>
  @``
   @{:a 1
     :b 2
     :c 3}
   ``

  (def src-5
    "@{:a @{:x 8 :y 9} :b 2 :c 3}")

  (data/fmt src-5)
  # =>
  @``
   @{:a @{:x 8
          :y 9}
     :b 2
     :c 3}
   ``

  (def src-6
    "{:a {:x 8 :y {:ant 1 :bee 2}} :b 2 :c 3}")

  (data/fmt src-6)
  # =>
  @``
   {:a {:x 8
        :y {:ant 1
            :bee 2}}
    :b 2
    :c 3}
   ``

  )

(comment import ./idx :prefix "")
#! /usr/bin/env janet

(comment import ./index-c :prefix "")
(comment import ./index :prefix "")
(defn idx/idx/get-first-lines-and-offsets!
  [src-str filtered key-name]
  (var cur-line 1)
  (var pos 0)
  # XXX: will \n work on all platforms?
  (def eol "\n")
  (def eol-len (length eol))
  (each entry filtered
    (def {key-name name} entry)
    (def [_ attrs _] name)
    (def line-no (get attrs :bl))
    (def line-diff
      (- line-no cur-line))
    (repeat line-diff
      (set pos
           (+ (string/find eol src-str pos)
              eol-len)))
    (put entry
         :offset pos)
    (def end-pos
      (+ (string/find eol src-str pos)
         eol-len))
    (put entry
         :first-line
         (string/slice src-str
                       pos (- end-pos eol-len)))
    (set pos end-pos)
    (set cur-line (inc line-no)))
  #
  filtered)

(defn idx/idx/get-all-pieces
  [src-str captures]
  (def results @[])
  (var cur-line 1)
  (var pos 0)
  # XXX: will \n work on all platforms?
  (def eol "\n")
  (def eol-len (length eol))
  (each entry captures
    # XXX: have position here, but ignoring
    (def [line-no _ _ id] entry)
    # XXX: hack to capture all ids in an array
    (array/push (dyn :all-ids) id)
    (def line-diff
      (- line-no cur-line))
    (repeat line-diff
      (set pos
           (+ (string/find eol src-str pos)
              eol-len)))
    (def end-pos
      (+ (string/find eol src-str pos)
         eol-len))
    (array/push results
                [(string/slice src-str
                               pos (- end-pos eol-len))
                 id
                 (string line-no)
                 (string pos)])
    (set pos end-pos)
    (set cur-line (inc line-no)))
  #
  results)

(defn idx/idx/index-file!
  [src path tags-fn out-buf]
  (def form-feed
    (string/from-bytes 0x0C))
  (def start-of-heading
    (string/from-bytes 0x01))
  (def delete
    (string/from-bytes 0x7F))
  # XXX
  #(def start (os/clock))
  (def tags
    (tags-fn src))
  #(printf "tags-fn: %p" (- (os/clock) start))
  (when (not (empty? tags))
    # XXX: will this eol always be "\n" on every platform?
    (def eol "\n")
    (var tags-byte-count 0)
    (+= tags-byte-count
        (reduce (fn [acc [first-line id line-no file-offset]]
                  (+ acc
                     (length first-line)
                     # delete
                     1
                     (length id)
                     # start of heading
                     1
                     (length line-no)
                     # comma
                     1
                     # XXX: char- vs byte- offset issue
                     #(length file-offset)
                     # XXX: eol
                     1))
                0
                tags))
    #
    (buffer/push out-buf
                 form-feed eol)
    (buffer/push out-buf
                 path ","
                 # total size of what follows -- assumes eol is one byte?
                 (string tags-byte-count)
                 eol)
    (each [first-line id line-no file-offset] tags
      (buffer/push out-buf
                   # first line of text without line-ending
                   first-line
                   delete
                   # identifier name
                   id
                   start-of-heading
                   # line
                   line-no
                   ","
                   # XXX: char- vs byte- offset issue
                   # offset from start of file
                   #file-offset
                   eol)))
  #
  out-buf)


# capture part of these things, but recognize them so they
# can be navigated "over"
#
# #define JANET_DEFINE_MATH2OP(name, fop, signature, doc)\
# JANET_CORE_FN(janet_##name, signature, doc) {\
#     janet_fixarity(argc, 2); \
#     double lhs = janet_getnumber(argv, 0); \
#     double rhs = janet_getnumber(argv, 1); \
#     return janet_wrap_number(fop(lhs, rhs)); \
# }
#
# #define OPMETHOD(T, type, name, oper) \
# static Janet cfun_it_##type##_##name(int32_t argc, Janet *argv) { \
#     janet_arity(argc, 2, -1); \
#     T *box = janet_abstract(&janet_##type##_type, sizeof(T)); \
#     *box = janet_unwrap_##type(argv[0]); \
#     for (int32_t i = 1; i < argc; i++) \
#         /* This avoids undefined behavior. See above for why. */ \
#         *box = (T) ((uint64_t) (*box)) oper ((uint64_t) janet_unwrap_##type(argv[i])); \
#     return janet_wrap_abstract(box); \
# } \

(def idx/ic/col-one
  ~{:main (some (choice :comment
                        :macro-define
                        :non-macro-match
                        :not-match))
    :non-macro-match (cmt (sequence (look -1 "\n")
                                    (not :s)
                                    (not "#")
                                    (not "}")
                                    (not :label)
                                    (line) (column) (position)
                                    (capture (to "\n"))
                                    "\n")
                          ,|@{:bl $0
                              :bc $1
                              :bp $2
                              :text $3})
    :label (sequence :id ":")
    :id (some (choice :a :d "_"))
    :comment (choice (sequence "//"
                               (any (if-not (set "\r\n") 1)))
                     (sequence "/*"
                               (any (if-not `*/` 1))
                               "*/"))
    :macro-define (choice (cmt (sequence (line) (column) (position)
                                         (capture (sequence "#define" (to "\n")))
                                         "\n")
                               ,|@{:bl $0
                                   :bc $1
                                   :bp $2
                                   :text $3})
                          (cmt (sequence (line) (column) (position)
                                         (capture (sequence "#define" (to `\`)))
                                         `\` "\n"
                                         (some (sequence (thru `\`) "\n"))
                                         # sometimes this is not how it ends
                                         (opt "\n}"))
                               ,|@{:bl $0
                                   :bc $1
                                   :bp $2
                                   :text $3}))
    :not-match 1})

# see comment form below for concrete examples
(defn idx/ic/find-id-for-td-en-st-line
  [line position src]
  (def rev
    (string/reverse line))
  # remember to think backwards as the matching is happening from
  # what was originally the "right" side of the string
  (def g
    '(choice (sequence (choice ";)"
                               ",")
                       (thru "(")
                       (choice (sequence ")"
                                         (capture (choice (to "*")
                                                          (to "("))))
                               (capture (to (set " *")))))
             (sequence ";"
                       (capture (to (set " *"))))
             (sequence "{"
                       :s+
                       (choice (sequence "="
                                         :s+
                                         "]"
                                         (thru "[")
                                         (capture (to (set " *"))))
                               (sequence ")"
                                         (thru "(")
                                         (capture (to (set " *"))))
                               # mune is enum reversed
                               # tcurts is struct reversed
                               (sequence (not "mune")
                                         (not "tcurts")
                                         (capture (to " ")))
                               (constant :reparse)))))
  (def m
    (peg/match g rev))
  # this peg is not for the reversed string
  (def g2
    ~{:main (sequence (some (sequence :id :s+))
                      :curlies
                      :s+ (capture :id) ";")
      :id (some (choice :a :d "_"))
      # XXX: might work with nested because of the source's formatting
      :curlies (sequence "{"
                         (to "\n}")
                         "\n}")})
  #
  (when-let [capture (first m)]
    (if (= :reparse capture)
      (when-let [m2 (peg/match g2 src position)
                 capture-2 (first m2)]
        capture-2)
      # XXX
      #:reparse
      (string/reverse capture))))

(comment

  (idx/ic/find-id-for-td-en-st-line
    "typedef double (win64_variant_f_ffff)(double, double, double, double);"
    nil nil)
  # =>
  "win64_variant_f_ffff"

  (idx/ic/find-id-for-td-en-st-line
    (string "typedef sysv64_sseint_return "
            "janet_sysv64_variant_4(uint64_t a, uint64_t b, uint64_t c, "
            "uint64_t d, uint64_t e, uint64_t f,")
    nil nil)
  # =>
  "janet_sysv64_variant_4"

  (idx/ic/find-id-for-td-en-st-line
    "typedef struct _stat jstat_t;"
    nil nil)
  # =>
  "jstat_t"

  (idx/ic/find-id-for-td-en-st-line
    "enum JanetInstructionType janet_instructions[JOP_INSTRUCTION_COUNT] = {"
    nil nil)
  # =>
  "janet_instructions"

  (idx/ic/find-id-for-td-en-st-line
    "enum JanetParserStatus janet_parser_status(JanetParser *parser) {"
    nil nil)
  # =>
  "janet_parser_status"

  (idx/ic/find-id-for-td-en-st-line
    "enum JanetMemoryType {" nil nil)
  # =>
  "JanetMemoryType"

  (idx/ic/find-id-for-td-en-st-line
    "struct BigNat {" nil nil)
  # =>
  "BigNat"

  (idx/ic/find-id-for-td-en-st-line
    "typedef struct JanetEnvRef {" nil nil)
  # =>
  "JanetEnvRef"

  (idx/ic/find-id-for-td-en-st-line
    "typedef void (*Special)(Builder *b, int32_t argc, const Janet *argv);"
    nil nil)
  # =>
  "Special"

  (def src
    ``
    enum {
        LB_REAL = 200,
        LB_NIL, /* 201 */
        LB_FALSE, /* 202 */
        LB_TRUE,  /* 203 */
        LB_FIBER, /* 204 */
        LB_INTEGER, /* 205 */
        LB_STRING, /* 206 */
        LB_SYMBOL, /* 207 */
        LB_KEYWORD, /* 208 */
        LB_ARRAY, /* 209 */
        LB_TUPLE, /* 210 */
        LB_TABLE, /* 211 */
        LB_TABLE_PROTO, /* 212 */
        LB_STRUCT, /* 213 */
        LB_BUFFER, /* 214 */
        LB_FUNCTION, /* 215 */
        LB_REGISTRY, /* 216 */
        LB_ABSTRACT, /* 217 */
        LB_REFERENCE, /* 218 */
        LB_FUNCENV_REF, /* 219 */
        LB_FUNCDEF_REF, /* 220 */
        LB_UNSAFE_CFUNCTION, /* 221 */
        LB_UNSAFE_POINTER, /* 222 */
        LB_STRUCT_PROTO, /* 223 */
    #ifdef JANET_EV
        LB_THREADED_ABSTRACT, /* 224 */
        LB_POINTER_BUFFER, /* 224 */
    #endif
    } LeadBytes;
    ``)

  (idx/ic/find-id-for-td-en-st-line
    "enum {" 0 src)
  # =>
  "LeadBytes"

  (def src
    ``
    typedef enum {
        JANET_ASYNC_WRITEMODE_WRITE,
        JANET_ASYNC_WRITEMODE_SEND,
        JANET_ASYNC_WRITEMODE_SENDTO
    } JanetWriteMode;
    ``)

  (idx/ic/find-id-for-td-en-st-line
    "typedef enum {" 0 src)
  # =>
  "JanetWriteMode"

  (def src
    ``
    typedef struct {
        JanetEVGenericMessage msg;
        JanetThreadedCallback cb;
        JanetThreadedSubroutine subr;
        JanetHandle write_pipe;
    } JanetEVThreadInit;
    ``)

  (idx/ic/find-id-for-td-en-st-line
    "typedef struct {" 0 src)
  # =>
  "JanetEVThreadInit"

  (def src
    ``
    typedef struct {
        const uint8_t *text_start;
        const uint8_t *text_end;
        const uint32_t *bytecode;
        const Janet *constants;
        JanetArray *captures;
        JanetBuffer *scratch;
        JanetBuffer *tags;
        JanetArray *tagged_captures;
        const Janet *extrav;
        int32_t *linemap;
        int32_t extrac;
        int32_t depth;
        int32_t linemaplen;
        int32_t has_backref;
        enum {
            PEG_MODE_NORMAL,
            PEG_MODE_ACCUMULATE
        } mode;
    } PegState;
    ``)

  (idx/ic/find-id-for-td-en-st-line
    "typedef struct {" 0 src)
  # =>
  "PegState"

  )

(defn idx/ic/find-id-for-rest
  [line]
  (def rev
    (string/reverse line))
  (def has-equals
    (string/find "=" rev))
  (def start
    (inc (or has-equals
             -1)))
  (defn dprintf
    [fmt & args]
    (when (os/getenv "VERBOSE")
      (printf fmt ;args)))
  # XXX
  (dprintf "start: %d" start)
  (dprintf "rev from start: %s" (string/slice rev start))
  (def g
    ~(sequence
       :s*
       # XXX: not the most general
       (any (choice (sequence "/*" (thru `*/`))
                    (sequence (thru "//"))))
       :s*
       (choice
         (sequence ","
                   (thru "(")
                   (cmt (capture (to (set " *")))
                        ,|(do
                            (dprintf ",")
                            $)))
         (sequence "]"
                   (thru "[")
                   (cmt (capture (to (set " *")))
                        ,|(do
                            (dprintf "]")
                            $)))
         (sequence ";"
                   (choice (sequence "]"
                                     (thru "[")
                                     (cmt (capture (to (set " *")))
                                          ,|(do
                                              (dprintf ";]")
                                              $)))
                           (sequence ")"
                                     (constant :declaration))
                           (cmt (capture (to (set " *")))
                                ,|(do
                                    (dprintf "; default")
                                    $))))
         (sequence "{" :s+
                   (choice
                     (sequence ")"
                               (thru "(")
                               (choice (sequence ")"
                                                 (cmt (capture (to (set "*(")))
                                                      ,|(do
                                                          (dprintf "{) up")
                                                          $)))
                                       (cmt (capture (to (choice (set " *")
                                                                 -1)))
                                            ,|(do
                                                (dprintf "{) down")
                                                $))))
                     (cmt (capture (to (set " *")))
                          ,|(do
                              (dprintf "{ default")
                              $))))
         (sequence "("
                   (cmt (capture (to (set " *")))
                        ,|(do
                            (dprintf "(")
                            $)))
         (cmt (capture (to (set " *")))
              ,|(do
                  (dprintf "default")
                  $)))))
  #
  (def m
    (peg/match g rev start))
  # XXX
  (dprintf "%p" m)
  #
  (when-let [capture (first m)]
    (if (= :declaration capture)
      :declaration
      (string/reverse capture))))

(comment

  #(os/setenv "VERBOSE" "1")

  (idx/ic/find-id-for-rest
    "const char *const janet_signal_names[14] = {")
  # =>
  "janet_signal_names"

  (idx/ic/find-id-for-rest
    "static char error_clib_buf[256];")
  # =>
  "error_clib_buf"

  (idx/ic/find-id-for-rest
    "static int cfun_io_gc(void *p, size_t len);")
  # =>
  :declaration

  (idx/ic/find-id-for-rest
    "JANET_THREAD_LOCAL JanetVM janet_vm;")
  # =>
  "janet_vm"

  (idx/ic/find-id-for-rest
    "double (janet_unwrap_number)(Janet x) {")
  # =>
  "janet_unwrap_number"

  (idx/ic/find-id-for-rest
    "const Janet *(janet_unwrap_tuple)(Janet x) {")
  # =>
  "janet_unwrap_tuple"

  (idx/ic/find-id-for-rest
    "os_proc_wait_impl(JanetProc *proc) {")
  # =>
  "os_proc_wait_impl"

  (idx/ic/find-id-for-rest
    "const void *janet_strbinsearch(")
  # =>
  "janet_strbinsearch"

  (idx/ic/find-id-for-rest
    "static const JanetAbstractType janet_struct_type = {")
  # =>
  "janet_struct_type"

  (idx/ic/find-id-for-rest
    "static void janetc_movenear(JanetCompiler *c,")
  # =>
  "janetc_movenear"

  )

(defn idx/ic/find-id-for-macro-define
  [line]
  (def g
    ~(sequence "#define" :s+
               (capture (to (set " (")))))
  (def m
    (peg/match g line))

  (first m))

(comment

  (idx/ic/find-id-for-macro-define
    "#define A ((*pc >> 8)  & 0xFF)")
  # =>
  "A"

  (idx/ic/find-id-for-macro-define
    (string "#define janet_v_free(v)         "
            "(((v) != NULL) ? (janet_sfree(janet_v__raw(v)), 0) : 0)"))
  # =>
  "janet_v_free"

  (idx/ic/find-id-for-macro-define
    "#define vm_throw(e) do { vm_commit(); janet_panic(e); } while (0)")
  # =>
  "vm_throw"

  (idx/ic/find-id-for-macro-define
    "#define JANET_EMIT_H")
  # =>
  nil

  )

(defn idx/ic/separate-lines
  [samples]
  (def scan-from-right @[])
  # typedef, enum, struct
  (def td-en-st @[])
  (def macro-defines @[])
  (def unmatched @[])
  (loop [i :in samples]
    (def s (get i :text))
    (when (not (or (string/has-prefix? "extern " s)
                   (peg/match '(sequence (some (range "AZ" "09" "__"))
                                         "(")
                              s)))
      (cond
        (or (string/has-prefix? "typedef " s)
            (string/has-prefix? "enum " s)
            (string/has-prefix? "struct " s))
        (array/push td-en-st i)
        #
        (string/has-prefix? "#define" s)
        (array/push macro-defines i)
        #
        (not (peg/match '(some (choice :a :d "_"))
                        (string/reverse s)))
        (array/push scan-from-right i)
        # for introspection
        (array/push unmatched i))))
  #
  [scan-from-right td-en-st macro-defines unmatched])

(comment

  (def dir
    (string (os/getenv "HOME")
            "/src/janet/src/core"))

  (def samples
    (seq [path :in (os/dir dir)
          :let [full-path (string dir "/" path)
                src (slurp full-path)]
          item :in (peg/match idx/ic/col-one src)]
      # XXX: src or path?
      (put item :src src)))

  (def [scan-from-right td-en-st macro-defines unmatched]
    (idx/ic/separate-lines samples))

  (var cnt 0)

  (each i (sort-by |(get $ :text) td-en-st)
    (def s
      (get i :text))
    (def position
      (get i :bp))
    (def src
      (get i :src))
    (def result
      (idx/ic/find-id-for-td-en-st-line s position src))
    (when (string? result)
      (++ cnt))
    (printf "%p" result))

  (each i (sort-by |(get $ :text) scan-from-right)
    (def s
      (get i :text))
    (def result (idx/ic/find-id-for-rest s))
    (when (string? result)
      (++ cnt))
    (printf "%p" result))

  (each i (sort-by |(get $ :text) macro-defines)
    (def s
      (get i :text))
    (def result
      (idx/ic/find-id-for-macro-define s))
    (when (string? result)
      (++ cnt))
    (printf "%p" result))

  # 1293, 1629
  cnt

  )

########################################################################

(defn idx/ic/find-c-tags
  [src]

  (def results @[])

  '(def src
     (slurp
       (string (os/getenv "HOME") "/src/janet/src/core/math.c")))

  '(def src
     (slurp
       (string (os/getenv "HOME") "/src/janet/src/core/ev.c")))

  '(def src
     (slurp
       (string (os/getenv "HOME") "/src/janet/src/core/vector.h")))

  (def caps
    (peg/match idx/ic/col-one src))

  (def [scan-from-right td-en-st macro-defines unmatched]
    (idx/ic/separate-lines caps))

  # XXX: what about duplicates?
  (each item scan-from-right
    (def line
      (get item :text))
    (def id-maybe
      (idx/ic/find-id-for-rest line))
    (when (string? id-maybe)
      (def line-no
        (get item :bl))
      (def pos
        (get item :bp))
      (array/push results
                  [line
                   id-maybe
                   (string line-no)
                   (string pos)])))
  # XXX: what about duplicates?
  (each item td-en-st
    (def line
      (get item :text))
    (def pos
      (get item :bp))
    (def id-maybe
      (idx/ic/find-id-for-td-en-st-line line pos src))
    (when (string? id-maybe)
      (def line-no
        (get item :bl))
      (array/push results
                  [line
                   id-maybe
                   (string line-no)
                   (string pos)])))
  # XXX: what about duplicates?
  (each item macro-defines
    (def line
      (get item :text))
    (def pos
      (get item :bp))
    (def id-maybe
      (idx/ic/find-id-for-macro-define line))
    (when (string? id-maybe)
      (def line-no
        (get item :bl))
      (array/push results
                  [line
                   id-maybe
                   (string line-no)
                   (string pos)])))
  # enum constants
  (each item td-en-st
    (def line
      (get item :text))
    (def pos
      (get item :bp))
    (when (or (and (string/has-prefix? "enum " line)
                   (string/has-suffix? "{" line))
              (and (string/has-prefix? "typedef enum " line)
                   (string/has-suffix? "{" line)))
      (def m
        (peg/match
          ~{:main (sequence (opt (sequence "typedef" :s+))
                            "enum" :s+
                            (opt (sequence :id :s+))
                            "{" "\n"
                            (some (cmt (sequence (not "}")
                                                 (line) (column) (position)
                                                 (capture (to "\n")) "\n")
                                       ,|@{:bl $0
                                           :bc $1
                                           :bp $2
                                           :text $3})))
            :id (some (choice :a :d "_"))}
          src pos))
      (when m
        (each item m
          (def line-no
            (get item :bl))
          (def pos
            (get item :bp))
          (def line
            (get item :text))
          (def trimmed
            (string/trim line))
          (def id
            (string/slice trimmed
                          0 (or (string/find "," trimmed)
                                -1)))
          (array/push results
                      [line
                       id
                       (string line-no)
                       (string pos)])))))
  #
  results)

########################################################################

(defn idx/ic/index-c!
  [src path out-buf]
  (idx/idx/index-file! src path idx/ic/find-c-tags out-buf))


(comment import ./index-j2c :prefix "")
(comment import ./index :prefix "")


########################################################################

(defn idx/ij2c/find-math-c-tags
  [src]

  '(def src
    (slurp
      (string (os/getenv "HOME") "/src/janet/src/core/math.c")))

  # JANET_DEFINE_MATHOP(acos, "Returns the arccosine of x.")
  # ...
  # JANET_DEFINE_NAMED_MATHOP("log-gamma", lgamma, "Returns log-gamma(x).")
  # ...
  # JANET_DEFINE_MATH2OP(pow, pow, "(math/pow a x)", "Returns a to the power of x.")
  # ...

  (def query-peg
    ~{:main (some (choice :match
                          :non-match))
      :id (some (choice :a :d "_"))
      :match
      (sequence "\n"
                (choice (sequence "JANET_DEFINE_NAMED_MATHOP" "("
                                  (cmt (sequence `"`
                                                 (line) (column) (position)
                                                 (capture (to `"`)))
                                       ,|[$0 $1 $2 (string "math/" $3)]))
                        #
                        (sequence "JANET_DEFINE_MATH2OP" "("
                                  :id "," :s+
                                  :id "," :s+
                                  (cmt (sequence `"(`
                                                 (line) (column) (position)
                                                 (capture (to (set " )"))))
                                       ,|[$0 $1 $2 $3]))
                        #
                        (sequence "JANET_DEFINE_MATHOP" "("
                                  (cmt (sequence (line) (column) (position)
                                                 (capture :id))
                                       ,|[$0 $1 $2 (string "math/" $3)]))))
      :non-match 1})

  (def caps
    (peg/match query-peg src))

  (idx/idx/get-all-pieces src caps))

(defn idx/ij2c/find-specials-c-tags
  [src]

  '(def src
    (slurp
      (string (os/getenv "HOME") "/src/janet/src/core/specials.c")))

  # static JanetSlot janetc_quote(JanetFopts opts, int32_t argn, const Janet *argv) {
  # ...
  # static JanetSlot janetc_varset(JanetFopts opts, int32_t argn, const Janet *argv) {
  # ...

  (def query-peg
    ~{:main (some (choice :match
                          :non-match))
      :id (some (choice :a :d "_"))
      :match (sequence "\n" "static JanetSlot" :s+
                       (cmt (sequence (line) (column) (position)
                                      (capture :id))
                            ,(fn [l c p id]
                               (def prefix "janetc_")
                               (when (string/has-prefix? prefix id)
                                 (def short-name
                                   (string/slice id (length prefix)))
                                 (def real-name
                                   (if (= "varset" short-name)
                                     "set"
                                     short-name))
                                 [l c p real-name]))))
      :non-match 1})

  (def caps
    (peg/match query-peg src))

  (idx/idx/get-all-pieces src caps))

(defn idx/ij2c/find-corelib-c-tags
  [src]

  '(def src
    (slurp
      (string (os/getenv "HOME") "/src/janet/src/core/corelib.c")))

  # janet_quick_asm(env, JANET_FUN_APPLY | JANET_FUNCDEF_FLAG_VARARG,
  #                 "apply", 1, 1, INT32_MAX, 6, apply_asm, sizeof(apply_asm),
  # ...
  # janet_quick_asm(env, JANET_FUN_MODULO,
  #                 "mod", 2, 2, 2, 2, modulo_asm, sizeof(modulo_asm),
  #                 JDOC("(mod dividend divisor)\n\n"
  #                      "Returns the modulo of dividend / divisor."));
  # ...
  # templatize_varop(env, JANET_FUN_MULTIPLY, "*", 1, 1, JOP_MULTIPLY,
  #                  JDOC("(* & xs)\n\n"
  #                       "Returns the product ... returns 1."));
  # ...
  # templatize_comparator(env, JANET_FUN_GT, ">", 0, JOP_GREATER_THAN,
  #                       JDOC("(> & xs)\n\n"
  #                       "Check if xs is in ... Returns a boolean."));
  # ...
  # janet_def(env, "janet/version", janet_cstringv(JANET_VERSION),
  #           JDOC("The version number of the running janet program."));

  (def query-peg
    ~{:main (some (choice :match
                          :non-match))
      :id (some (choice :a :d "_"))
      :match
      (sequence
        ";\n"
        # * the /* ... */ part is for +, >, janet/version, root-env
        (opt (sequence :s+
                       "/*"
                       (some (if-not "*/" 1))
                       "*/"))
        :s+
        (choice (sequence (choice "janet_quick_asm"
                                  "templatize_varop"
                                  "templatize_comparator")
                          "("
                          :id
                          "," :s+
                          :id (opt (sequence :s+ "|" :s+ :id)) # opt for apply
                          "," :s+
                          (cmt (sequence `"`
                                         (line) (column) (position)
                                         (capture (to `"`))
                                         `"`)
                               ,|[$0 $1 $2 $3]))
                (sequence "janet_def"
                          "("
                          :id "," :s+
                          (cmt (sequence `"`
                                         (line) (column) (position)
                                         (capture (to `"`))
                                         `"`)
                               ,|[$0 $1 $2 $3]))))
      :non-match 1})

  (def caps
    (peg/match query-peg src))

  (idx/idx/get-all-pieces src caps))

# JANET_CORE_DEF
# * io.c
# * math.c
(defn idx/ij2c/find-janet-core-def-tags
  [src]

  '(def src
    (slurp
      (string (os/getenv "HOME") "/src/janet/src/core/io.c")))

  '(def src
    (slurp
      (string (os/getenv "HOME") "/src/janet/src/core/math.c")))

  # #ifdef JANET_BOOTSTRAP
  #     JANET_CORE_DEF(env, "math/pi", janet_wrap_number(3.1415926535897931),
  #                    ...);
  # ...
  #
  # note that leading whitespace is elided from sample of io.c below
  #
  # int default_flags = JANET_FILE_NOT_CLOSEABLE | JANET_FILE_SERIALIZABLE;
  # /* stdout */
  # JANET_CORE_DEF(env, "stdout",
  #                ...);
  # /* stderr */
  # JANET_CORE_DEF(env, "stderr",
  #                ...);

  (def query-peg
    ~{:main (some (choice :match
                          :non-match))
      :id (some (choice :a :d "_"))
      :match (sequence (choice ";" :id)
                       (opt (sequence :s+
                                      "/*"
                                      (some (if-not "*/" 1))
                                      "*/"))
                       :s+
                       "JANET_CORE_DEF"
                       "("
                       :id "," :s+
                       (cmt (sequence `"`
                                      (line) (column) (position)
                                      (capture (to `"`))
                                      `"`)
                            ,|[$0 $1 $2 $3]))
      :non-match 1})

  (def caps
    (peg/match query-peg src))

  (idx/idx/get-all-pieces src caps))

# JANET_CORE_FN
# * many
(defn idx/ij2c/find-janet-core-fn-tags
  [src]

  '(def src
     (slurp
       (string (os/getenv "HOME") "/src/janet/src/core/ffi.c")))

  '(def src
     (slurp
       (string (os/getenv "HOME") "/src/janet/src/core/math.c")))

  # JANET_CORE_FN(cfun_peg_compile,
  #              "(peg/compile peg)", ...)

  (def query-peg
    ~{:main (some (choice :match
                          :non-match))
      :id (some (choice :a :d "_"))
      :match (sequence (choice ";"  # parser/state, etc.
                               ")"  # math/pow, etc.
                               "}"  # ev/acquire-lock, etc.
                               "*/" # module/expand-path, etc.
                               :id) # ffi/signature, etc.
                       (choice (sequence :s+
                                         "/*"
                                         (some (if-not "*/" 1))
                                         "*/"
                                         :s+)
                               :s+)
                       "JANET_CORE_FN" "(" :id "," :s+
                       # e.g. "(file/temp)" or "(peg/compile peg)"
                       (cmt (sequence `"(`
                                      (line) (column) (position)
                                      (capture (to (choice (set ` )`)
                                                           # janet 1.17.0 has
                                                           # an error in doc
                                                           # for
                                                           # fiber/last-value
                                                           `"`))))
                            ,|[$0 $1 $2 $3]))
      :non-match 1})

  (def caps
    (peg/match query-peg src))

  (idx/idx/get-all-pieces src caps))

# const JanetAbstractType janet... = {
# * many
(defn idx/ij2c/find-janet-abstract-type-tags
  [src]

  '(def src
     (slurp
       (string (os/getenv "HOME") "/src/janet/src/core/ev.c")))

  '(def src
     (slurp
       (string (os/getenv "HOME") "/src/janet/src/core/ffi.c")))

  # const JanetAbstractType janet... = {
  #     "core/file",
  #     ...
  # };

  (def query-peg
    ~{:main (some (choice :match
                          :non-match))
      :id (some (choice :a :d "_"))
      :match (sequence "const" :s+
                       "JanetAbstractType" :s+
                       :id :s+ "="
                       :s+ "{" :s+
                       (cmt (sequence `"`
                                      (line) (column) (position)
                                      (capture (some (if-not `"` 1)))
                                      `"`)
                            ,|[$0 $1 $2 $3]))
      :non-match 1})

  (def caps
    (peg/match query-peg src))

  (idx/idx/get-all-pieces src caps))

########################################################################

(defn idx/ij2c/index-math-c!
  [src path out-buf]
  (idx/idx/index-file! src path idx/ij2c/find-math-c-tags out-buf))

(defn idx/ij2c/index-specials-c!
  [src path out-buf]
  (idx/idx/index-file! src path idx/ij2c/find-specials-c-tags out-buf))

(defn idx/ij2c/index-corelib-c!
  [src path out-buf]
  (idx/idx/index-file! src path idx/ij2c/find-corelib-c-tags out-buf))

(defn idx/ij2c/index-janet-core-def-c!
  [src path out-buf]
  (idx/idx/index-file! src path idx/ij2c/find-janet-core-def-tags out-buf))

(defn idx/ij2c/index-generic-c!
  [src path out-buf]
  (try
    (idx/idx/index-file! src path idx/ij2c/find-janet-abstract-type-tags out-buf)
    ([e]
      (eprintf "%s: abstract - %p" path e)))
  (try
    (idx/idx/index-file! src path idx/ij2c/find-janet-core-fn-tags out-buf)
    ([e]
      (eprintf "%s: core-fn - %p" path e))))


(comment import ./index-janet :prefix "")
(comment import ./index :prefix "")

(comment import ./janet-cursor :prefix "")
(comment import ./janet-peg :prefix "")
(comment import ./loc :prefix "")
# bl - begin line
# bc - begin column
# bp - begin position
# el - end line
# ec - end column
# ep - end position
(defn idx/l/make-attrs
  [& args]
  (zipcoll [:bl :bc :bp :el :ec :ep]
           args))

(comment

  (idx/l/make-attrs 1 1 0
              10 20 50)
  # =>
  @{:bc 1 :bl 1 :bp 0 :ec 20 :el 10 :ep 50}

  )

(comment

  (defn opaque-node
    [the-type peg-form]
    ~(cmt (capture (sequence (line) (column) (position)
                             ,peg-form
                             (line) (column) (position)))
          ,|[the-type
             (idx/l/make-attrs ;(tuple/slice $& 0 3)
                         ;(tuple/slice $& (- (- 3) 2) -2))
             (last $&)]))

  (defn delim-node
    [the-type open close]
    ~(cmt
       (capture
         (sequence
           (line) (column) (position)
           ,open
           (any :input)
           (choice ,close
                   (error
                     (replace (sequence (line) (column) (position))
                              ,|(string/format
                                  (string "line: %d column: %d pos: %d "
                                          "missing %s for %s")
                                  $0 $1 $2 close the-type))))
           (line) (column) (position)))
       ,|[the-type
          (idx/l/make-attrs ;(tuple/slice $& 0 3)
                      ;(tuple/slice $& (- (- 3) 2) -2))
          ;(tuple/slice $& 3 (- (- 3 ) 2))]))

  (def t-grammar
    ~{:main (some :input)
      :input (choice :ws :str :dl)
      :ws ,(opaque-node :ws '(set " \n"))
      :str ,(opaque-node :str
                         '(sequence `"`
                                    (any (if-not `"` 1))
                                    `"`))
      :dl ,(delim-node :dl `(` `)`)})

  (peg/match t-grammar `"hi there"`)
  # =>
  '@[(:str @{:bc 1 :bl 1 :bp 0 :ec 11 :el 1 :ep 10} "\"hi there\"")]

  (peg/match t-grammar `("alice" "bob")`)
  # =>
  '@[(:dl @{:bc 1 :bl 1 :bp 0 :ec 16 :el 1 :ep 15}
          (:str @{:bc 2 :bl 1 :bp 1 :ec 9 :el 1 :ep 8} "\"alice\"")
          (:ws @{:bc 9 :bl 1 :bp 8 :ec 10 :el 1 :ep 9} " ")
          (:str @{:bc 10 :bl 1 :bp 9 :ec 15 :el 1 :ep 14} "\"bob\""))]

  )



(defn idx/jp/make-grammar
  [&opt opts]
  #
  (def opaque-node
    (or (get opts :opaque-node)
        (fn [the-type peg-form]
          ~(cmt (capture (sequence (line) (column) (position)
                                   ,peg-form
                                   (line) (column) (position)))
                ,|[the-type
                   (idx/l/make-attrs ;(tuple/slice $& 0 3)
                                 ;(tuple/slice $& (- (- 3) 2) -2))
                   (last $&)]))))
  #
  (def delim-node
    (or (get opts :delim-node)
        (fn [the-type open close]
          ~(cmt
             (capture
               (sequence
                 (line) (column) (position)
                 ,open
                 (any :input)
                 (choice ,close
                         (error
                           (replace (sequence (line) (column) (position))
                                    ,|(string/format
                                        (string "line: %d column: %d pos: %d "
                                                "missing %s for %s")
                                        $0 $1 $2 close the-type))))
                 (line) (column) (position)))
             ,|[the-type
                (idx/l/make-attrs ;(tuple/slice $& 0 3)
                              ;(tuple/slice $& (- (- 3) 2) -2))
                ;(tuple/slice $& 3 (- (- 3 ) 2))]))))
  #
  ~{:main (sequence (line) (column) (position)
                    (some :input)
                    (line) (column) (position))
    #
    :input (choice :ws
                   :cmt
                   :form)
    #
    :ws (choice :ws/horiz
                :ws/eol)
    #
    :ws/horiz ,(opaque-node :ws/horiz
                            '(some (set " \0\f\t\v")))
    #
    :ws/eol ,(opaque-node :ws/eol
                          '(choice "\r\n"
                                   "\r"
                                   "\n"))
    #
    :cmt :cmt/line
    #
    :cmt/line
    ,(opaque-node :cmt/line
                  '(sequence "#"
                             (any (if-not (set "\r\n") 1))))
    #
    :form (choice :str
                  :blob
                  :dl)
    #
    :str (choice :str/dq
                 :str/bt)
    #
    :str/dq
    ,(opaque-node :str/dq
                  '(sequence `"`
                             (any (choice :escape
                                          (if-not `"` 1)))
                             `"`))
    #
    :escape (sequence `\`
                      (choice (set `"'0?\abefnrtvz`)
                              (sequence "x" (2 :h))
                              (sequence "u" (4 :h))
                              (sequence "U" (6 :h))
                              (error (constant "bad escape"))))
    #
    :str/bt
    ,(opaque-node :str/bt
                  ~{:main (drop (sequence :open
                                          (any (if-not :close 1))
                                          :close))
                    :open (capture :delim :n)
                    :delim (some "`")
                    :close (cmt (sequence (not (look -1 "`"))
                                          (backref :n)
                                          (capture (backmatch :n)))
                                ,=)})
    #
    :blob
    ,(opaque-node
       :blob
       '(some (choice (range "09" "AZ" "az" "\x80\xFF")
                      (set "!$%&*+-./:<=>?^_")
                      # XXX: what to do about mutable collections...
                      "@"
                      # XXX: possibly separate...
                      (set "|~';,"))))
    #
    :dl (choice :dl/round
                :dl/square
                :dl/curly)
    #
    :dl/round ,(delim-node :dl/round "(" ")")
    #
    :dl/square ,(delim-node :dl/square "[" "]")
    #
    :dl/curly ,(delim-node :dl/curly "{" "}")})

(comment

  (def grammar (idx/jp/make-grammar))

  (get (peg/match grammar `2`) 3)
  # =>
  '(:blob @{:bc 1 :bl 1 :bp 0
            :ec 2 :el 1 :ep 1}
          "2")

  (get (peg/match grammar `(+ 1 1)`) 3)
  # =>
  '(:dl/round @{:bc 1 :bl 1 :bp 0 :ec 8 :el 1 :ep 7}
              (:blob @{:bc 2 :bl 1 :bp 1 :ec 3 :el 1 :ep 2} "+")
              (:ws/horiz @{:bc 3 :bl 1 :bp 2 :ec 4 :el 1 :ep 3} " ")
              (:blob @{:bc 4 :bl 1 :bp 3 :ec 5 :el 1 :ep 4} "1")
              (:ws/horiz @{:bc 5 :bl 1 :bp 4 :ec 6 :el 1 :ep 5} " ")
              (:blob @{:bc 6 :bl 1 :bp 5 :ec 7 :el 1 :ep 6} "1"))

  (-> (peg/match grammar `@[:a :b :c]`)
      (array/slice 3 (dec (- 3))))
  # =>
  '@[(:blob @{:bc 1 :bl 1 :bp 0 :ec 2 :el 1 :ep 1} "@")
     (:dl/square @{:bc 2 :bl 1 :bp 1 :ec 12 :el 1 :ep 11}
                 (:blob @{:bc 3 :bl 1 :bp 2 :ec 5 :el 1 :ep 4} ":a")
                 (:ws/horiz @{:bc 5 :bl 1 :bp 4 :ec 6 :el 1 :ep 5} " ")
                 (:blob @{:bc 6 :bl 1 :bp 5 :ec 8 :el 1 :ep 7} ":b")
                 (:ws/horiz @{:bc 8 :bl 1 :bp 7 :ec 9 :el 1 :ep 8} " ")
                 (:blob @{:bc 9 :bl 1 :bp 8 :ec 11 :el 1 :ep 10} ":c"))]

  (get (peg/match grammar
                  ``
                  (defn fun
                    [x]
                    (+ x 1))
                  ``)
       3)
  # =>
  '(:dl/round
     @{:bc 1 :bl 1 :bp 0 :ec 11 :el 3 :ep 26}
     (:blob @{:bc 2 :bl 1 :bp 1 :ec 6 :el 1 :ep 5} "defn")
     (:ws/horiz @{:bc 6 :bl 1 :bp 5 :ec 7 :el 1 :ep 6} " ")
     (:blob @{:bc 7 :bl 1 :bp 6 :ec 10 :el 1 :ep 9} "fun")
     (:ws/eol @{:bc 10 :bl 1 :bp 9 :ec 1 :el 2 :ep 10} "\n")
     (:ws/horiz @{:bc 1 :bl 2 :bp 10 :ec 3 :el 2 :ep 12} "  ")
     (:dl/square @{:bc 3 :bl 2 :bp 12 :ec 6 :el 2 :ep 15}
                 (:blob @{:bc 4 :bl 2 :bp 13 :ec 5 :el 2 :ep 14} "x"))
     (:ws/eol @{:bc 6 :bl 2 :bp 15 :ec 1 :el 3 :ep 16} "\n")
     (:ws/horiz @{:bc 1 :bl 3 :bp 16 :ec 3 :el 3 :ep 18} "  ")
     (:dl/round @{:bc 3 :bl 3 :bp 18 :ec 10 :el 3 :ep 25}
                (:blob @{:bc 4 :bl 3 :bp 19 :ec 5 :el 3 :ep 20} "+")
                (:ws/horiz @{:bc 5 :bl 3 :bp 20 :ec 6 :el 3 :ep 21} " ")
                (:blob @{:bc 6 :bl 3 :bp 21 :ec 7 :el 3 :ep 22} "x")
                (:ws/horiz @{:bc 7 :bl 3 :bp 22 :ec 8 :el 3 :ep 23} " ")
                (:blob @{:bc 8 :bl 3 :bp 23 :ec 9 :el 3 :ep 24} "1")))

  (get (peg/match grammar
                  ``
                  (print # nice comment
                    "hello")
                  ``)
       3)
  # =>
  '(:dl/round
     @{:bc 1 :bl 1 :bp 0 :ec 11 :el 2 :ep 32}
     (:blob @{:bc 2 :bl 1 :bp 1 :ec 7 :el 1 :ep 6} "print")
     (:ws/horiz @{:bc 7 :bl 1 :bp 6 :ec 8 :el 1 :ep 7} " ")
     (:cmt/line @{:bc 8 :bl 1 :bp 7 :ec 22 :el 1 :ep 21} "# nice comment")
     (:ws/eol @{:bc 22 :bl 1 :bp 21 :ec 1 :el 2 :ep 22} "\n")
     (:ws/horiz @{:bc 1 :bl 2 :bp 22 :ec 3 :el 2 :ep 24} "  ")
     (:str/dq @{:bc 3 :bl 2 :bp 24 :ec 10 :el 2 :ep 31} "\"hello\""))

  )


# to make generic cursor functions available
#(import ./cursor :prefix "" :export true)
(comment import ./cursor :prefix "")
(comment import ./loc :prefix "")


(defn idx/c/init-infra
  [make-grammar]
  (var counter 0)

  (defn issue-id
    []
    (++ counter))

  (def id->node @{})

  (def loc->id @{})

  (defn reset
    []
    (set counter 0)
    (table/clear id->node)
    (table/clear loc->id))

  (defn opaque-node
    [node-type peg-form]
    ~(cmt (capture (sequence (line) (column) (position)
                             ,peg-form
                             (line) (column) (position)))
          ,|(let [id (issue-id)
                  attrs (idx/l/make-attrs ;(tuple/slice $& 0 -2))
                  _ (put loc->id (freeze attrs) id)
                  node [node-type
                        (put attrs :id id)
                        (last $&)]]
              (put id->node id node)
              node)))

  (defn delim-node
    [node-type open-delim close-delim]
    ~(cmt
       (capture
         (sequence
           (line) (column) (position)
           ,open-delim
           (any :input)
           (choice ,close-delim
                   (error
                     (replace (sequence (line) (column) (position))
                              ,|(string/format
                                  (string "line: %p column: %p pos: %p "
                                          "missing %p for %p")
                                  $0 $1 $2 close-delim node-type))))
           (line) (column) (position)))
       ,|(let [id (issue-id)
               attrs (idx/l/make-attrs ;(tuple/slice $& 0 3)
                                   ;(tuple/slice $& (- (- 3) 2) -2))
               _ (put loc->id (freeze attrs) id)
               # add the index position and parent id for each child
               [_ children]
               (reduce (fn add-idx-and-pid
                         [[counter kids] child]
                         # XXX
                         #(d/deprintf "counter: %n" counter)
                         #(d/deprintf "kids: %n" kids)
                         #(d/deprintf "child: %n" child)
                         (def [_ attrs _] child)
                         # XXX
                         #(d/deprintf "type: %n" (type attrs))
                         (unless (= :table (type attrs))
                           (eprintf "child: %n" child)
                           (eprintf "$&: %n" $&))
                         (put attrs :idx counter)
                         (put attrs :pid id)
                         [(inc counter)
                          (array/push kids child)])
                       # index and to-be-filled-with-children
                       [0 @[]]
                       # children before
                       (tuple/slice $& 3 (- (- 3) 2)))
               node [node-type
                     (put attrs :id id)
                     ;children]]
           (put id->node id node)
           node)))

  (def loc-grammar
    (make-grammar {:opaque-node opaque-node
                   :delim-node delim-node}))

  #
  (defn par
    [src &opt start single]
    (default start 0)
    (def top-id 0)
    (def loc-top-level-ast
      (let [ltla (table ;(kvs loc-grammar))]
        (put ltla
             :main ~(sequence (line) (column) (position)
                              :input
                              (line) (column) (position)))
        (table/to-struct ltla)))
    #
    (def top-node
      (if single
        (if-let [[bl bc bp tree el ec ep]
                 (peg/match loc-top-level-ast src start)]
          @[:code
            (put (idx/l/make-attrs bl bc bp el ec ep)
                 :id top-id)
            tree]
          @[:code])
        (if-let [captures (peg/match loc-grammar src start)]
          (let [[bl bc bp] (array/slice captures 0 3)
                [el ec ep] (array/slice captures (dec -3))
                [_ trees] (reduce (fn [[counter kids] child]
                                    (def [_ attrs _] child)
                                    (put attrs :idx counter)
                                    (put attrs :pid top-id)
                                    [(inc counter)
                                     (array/push kids child)])
                                  [0 @[]]
                                  (array/slice captures 3 (dec -3)))]
            (array/insert trees 0
                          :code (put (idx/l/make-attrs bl bc bp el ec ep)
                                     :id top-id)))
          @[:code])))
    #
    (put id->node top-id top-node)
    #
    top-node)
  #
  {:grammar loc-grammar
   :node-table id->node
   :loc-table loc->id
   :issuer issue-id
   :reset reset
   :parse par})

(defn idx/c/make-cursor
  [node-table &opt node]
  (default node (get node-table 0))
  {:node node
   :table node-table})

(defn idx/c/right
  [{:node n :table n-tbl}]
  (def [_ attrs _] n)
  (when-let [pid (get attrs :pid)
             idx (get attrs :idx)
             [_ _ & rest] (get n-tbl pid)]
    (when (tuple? rest)
      (when-let [next-sibling (get rest (inc idx))]
        {:node next-sibling
         :table n-tbl}))))

(defn idx/c/up
  [{:node n :table n-tbl}]
  (def [_ attrs _] n)
  (when-let [pid (get attrs :pid)]
    {:node (get n-tbl pid)
     :table n-tbl}))

(defn idx/c/down
  [{:node n :table n-tbl}]
  (def [_ _ & rest] n)
  (when (tuple? rest)
    (when-let [first-elt (first rest)]
      (when (tuple? first-elt)
        {:node first-elt
         :table n-tbl}))))

(defn idx/c/df-next
  [crs]
  #
  (defn helper
    [a-crs]
    (if-let [up-cand (idx/c/up a-crs)]
      (or (idx/c/right up-cand)
          (helper up-cand))
      :back-at-top))
  # XXX: this part might be off a bit
  (or (idx/c/down crs)
      (idx/c/right crs)
      (helper crs)))

(defn idx/c/rightmost
  [{:node node :table node-table}]
  (def [_ attrs _] node)
  (when-let [pid (get attrs :pid)
             [_ _ & rest] (get node-table pid)]
    (when (tuple? rest) # should not fail
      (when-let [last-sibling (last rest)]
        {:node last-sibling
         :table node-table}))))

(defn idx/c/left
  [{:node n :table n-tbl}]
  (def [_ attrs _] n)
  (when-let [pid (get attrs :pid)
             idx (get attrs :idx)
             [_ _ & rest] (get n-tbl pid)]
    (when (tuple? rest)
      (when-let [prev-sibling (get rest (dec idx))]
        {:node prev-sibling
         :table n-tbl}))))

(defn idx/c/df-prev
  [crs]
  #
  (defn helper
    [a-crs]
    (if-let [down-cand (idx/c/down a-crs)]
      (helper (idx/c/rightmost down-cand))
      a-crs))
  #
  (if-let [left-cand (idx/c/left crs)]
    (helper left-cand)
    (idx/c/up crs)))



(def idx/jc/init-infra idx/c/init-infra)

(def idx/jc/make-cursor idx/c/make-cursor)

(def idx/jc/right idx/c/right)

(def idx/jc/up idx/c/up)

(def idx/jc/down idx/c/down)

(def idx/jc/df-next idx/c/df-next)

(def idx/jc/rightmost idx/c/rightmost)

(def idx/jc/left idx/c/left)

(def idx/jc/df-prev idx/c/df-prev)

(defn idx/jc/make-infra
  []
  (idx/jc/init-infra idx/jp/make-grammar))

(comment

  (def {:grammar loc-grammar
        :issuer issue-id
        :node-table id->node
        :loc-table loc->id
        :reset reset}
    (idx/jc/make-infra))

  (reset)

  (get (peg/match loc-grammar "1") 3)
  # =>
  '(:blob @{:bc 1 :bl 1 :bp 0
            :ec 2 :el 1 :ep 1
            :id 1}
          "1")

  (get (peg/match loc-grammar "[1]") 3)
  # =>
  '(:dl/square @{:bc 1 :bl 1 :bp 0
                 :ec 4 :el 1 :ep 3
                 :id 3}
               (:blob @{:bc 2 :bl 1 :bp 1
                        :ec 3 :el 1 :ep 2
                        :id 2 :idx 0 :pid 3}
                      "1"))

  id->node
  # =>
  '@{1
     (:blob @{:bc 1 :bl 1 :bp 0
              :ec 2 :el 1 :ep 1
              :id 1}
            "1")
     2
     (:blob @{:bc 2 :bl 1 :bp 1
              :ec 3 :el 1 :ep 2
              :id 2 :idx 0 :pid 3}
            "1")
     3
     (:dl/square @{:bc 1 :bl 1 :bp 0
                   :ec 4 :el 1 :ep 3
                   :id 3}
                 (:blob @{:bc 2 :bl 1 :bp 1
                          :ec 3 :el 1 :ep 2
                          :id 2 :idx 0 :pid 3}
                        "1"))}

  loc->id
  # =>
  '@{{:bc 2 :bl 1 :bp 1 :ec 3 :el 1 :ep 2} 2
     {:bc 1 :bl 1 :bp 0 :ec 4 :el 1 :ep 3} 3
     {:bc 1 :bl 1 :bp 0 :ec 2 :el 1 :ep 1} 1}

  (array/slice (peg/match loc-grammar "|[2 3]")
               3 (dec (- 3)))
  # =>
  '@[(:blob @{:bc 1 :bl 1 :bp 0
              :ec 2 :el 1 :ep 1 :id 4} "|")
     (:dl/square @{:bc 2 :bl 1 :bp 1 :ec 7 :el 1 :ep 6 :id 8}
                 (:blob @{:bc 3 :bl 1 :bp 2
                          :ec 4 :el 1 :ep 3 :id 5 :idx 0 :pid 8} "2")
                 (:ws/horiz @{:bc 4 :bl 1 :bp 3
                              :ec 5 :el 1 :ep 4 :id 6 :idx 1 :pid 8} " ")
                 (:blob @{:bc 5 :bl 1 :bp 4
                          :ec 6 :el 1 :ep 5 :id 7 :idx 2 :pid 8} "3"))]

  )




(comment import ./janet-query :prefix "")
(comment import ./loc :prefix "")

(comment import ./janet-peg :prefix "")

(comment import ./debug :prefix "")
(defn idx/d/deprintf
  [fmt & args]
  (when (dyn :ij-debug)
    (eprintf fmt ;args)))

(defn idx/d/deprint
  [msg]
  (when (dyn :ij-debug)
    (eprint msg)))


# options should be a dictionary with things such as:
#
# * blank delimiter safe character info
#   * single delim for both sides
#   * left delim diff from right delim
#   * open-delim / close-delim fixed chars?
#   * raw-string like delimiting?
# * string escape character info
# * blob character info
# * possibly other things eventually
#   * line comment info
#   * multi-line comment info
#   * whitespace info
#   * raw string info
#
# XXX: could "lint" the options, e.g. conflict in blob char with
#      blank delims
(defn idx/jq/make-infra
  [&opt opts]

  (def safe-delim
    (if-let [bd (get opts :safe-delim)]
      bd
      `\`))

  (def loc->node @{})

  (def n-safe-delims @[])

  (defn opaque-node
    [the-type peg-form]
    ~(cmt (capture (sequence (line) (column) (position)
                             ,peg-form
                             (line) (column) (position)))
          # XXX: ;(tuple/slice $& 0 -2) might work here
          ,|(let [attrs (idx/l/make-attrs ;(tuple/slice $& 0 3)
                                      ;(tuple/slice $& (- (- 3) 2) -2))
                  node [the-type attrs (last $&)]]
              (put loc->node (freeze attrs) node)
              node)))

  (defn delim-node
    [the-type open close]
    ~(cmt
       (capture
         (sequence
           (line) (column) (position)
           ,open
           (any :input)
           (choice ,close
                   (error
                     (replace (sequence (line) (column) (position))
                              ,|(string/format
                                  (string "line: %d column: %d pos: %d "
                                          "missing %s for %s")
                                  $0 $1 $2 close the-type))))
           (line) (column) (position)))
       ,|(let [attrs (idx/l/make-attrs ;(tuple/slice $& 0 3)
                                   ;(tuple/slice $& (- (- 3) 2) -2))
               node [the-type attrs ;(tuple/slice $& 3 (- (- 3 ) 2))]]
           (put loc->node (freeze attrs) node)
           node)))

  (def lang-grammar
    (idx/jp/make-grammar {:opaque-node opaque-node
                      :delim-node delim-node}))

  (def query-grammar
    (-> (struct/to-table lang-grammar)
        (put
          :form (let [old-form (get lang-grammar :form)]
                  (tuple 'choice
                         :blank
                         ;(tuple/slice old-form 1))))
        (put :... '(any :input))
        (put
          :blank
          ~(cmt (capture
                  (sequence (line) (column) (position)
                            (capture :blank-internal)
                            (line) (column) (position)))
                ,|(let [attrs
                        (idx/l/make-attrs ;(tuple/slice $& 0 3)
                                      ;(tuple/slice $& (- (- 3) 2) -2))
                        n (array/pop n-safe-delims)
                        [value] (slice $& 3 (- (- 3) 2))]
                    # XXX
                    (idx/d/deprintf "$&: %n" $&)
                    (idx/d/deprintf "attrs: %n" attrs)
                    (idx/d/deprintf "value: %n" value)
                    (idx/d/deprintf "n: %d" n)
                    # discard the surrounding blank delimiters
                    [:blank attrs (string/slice value n (dec (- n)))])))
        (put
          :blank-internal
          ~{:main (drop (sequence :open
                                  (any (if-not :close 1))
                                  :close))
            :open (capture :delim :n)
            # use "safe" delimiters, e.g. $, if possible?
            :delim (some ,safe-delim)
            :close (cmt (sequence (not (look -1 ,safe-delim))
                                  (backref :n)
                                  (capture (backmatch :n)))
                        ,(fn [left right]
                           (when (= left right)
                             # hack to pass back number of safe-delims
                             (array/push n-safe-delims
                                         (length left))
                             true)))})))
  #
  (defn parse-query
    [src &opt start single]
    (default start 0)
    (def top-level-ast
      (let [tla (table ;(kvs query-grammar))]
        (put tla
             :main ~(sequence (line) (column) (position)
                              :input
                              (line) (column) (position)))
        (table/to-struct tla)))
    #
    (def top-node
      (if single
        (if-let [[bl bc bp tree el ec ep]
                 (peg/match top-level-ast src start)]
          @[:code (idx/l/make-attrs bl bc bp el ec ep) tree]
          @[:code])
        (if-let [captures (peg/match query-grammar src start)]
          (let [[bl bc bp] (slice captures 0 3)
                [el ec ep] (slice captures (dec -3))
                trees (array/slice captures 3 (dec -3))]
            (array/insert trees 0
                          :code (idx/l/make-attrs bl bc bp el ec ep)))
          @[:code])))
    #
    top-node)
  # must start with ::
  (defn blank-sym-name?
    [cand]
    (peg/match
      '(sequence "::"
                 (some (choice (range "09" "AZ" "az" "\x80\xFF")
                               (set "!$%&*+-./:<?=>@^_")))
                 -1)
      cand))

  (defn parse-blank-data
    [blank-data]
    # special name meaning to match (but don't capture) 0 or more :input
    (when (= ":..." blank-data)
      (break [~(drop ,(get query-grammar :...))]))
    #
    (def parse-results (parse-all blank-data))
    (def n-results (length parse-results))
    (assert (pos? n-results)
            (string/format "Failed to parse: %n" blank-data))
    (def [head neck] parse-results)
    #
    (case n-results
      1
      (cond
        # only ~ something and ' something
        (and (tuple? head)
             (or (= 'quasiquote (first head))
                 (= 'quote (first head))))
        # drop is here to ensure no captures happen
        [~(drop ,(eval head))]
        #
        (or (number? head) (string? head))
        # numbers and strings cannot capture so no drop needed
        [head]
        # keyword from grammar means to match
        (and (keyword? head)
             (get lang-grammar head))
        [~(drop ,head)]
        #
        (errorf "Unrecognized first item: %n in blank-data: %n"
                head blank-data))
      2
      (do
        (assert (and (keyword? head)
                     (blank-sym-name? (string ":" head)))
                (string/format "Not a valid blank name: %s in blank-data: %s"
                               head blank-data))
        (def the-capture
          (cond
            # only ~ something and ' something
            (and (tuple? neck)
                 (or (= 'quasiquote (first neck))
                     (= 'quote (first neck))))
            (eval neck)
            #
            (or (number? neck) (string? neck))
            (errorf "numbers and strings don't capture: %n" neck)
            #
            (keyword? neck)
            (if (get lang-grammar neck)
              neck
              (errorf "Keyword %n not in grammar" neck))
            #
            (errorf "Unrecognized second item: %n in blank-data: %n"
                    neck blank-data)))
        [(tuple 'constant head)
         the-capture])
      #
      (errorf "Too many items, should only be 1 or 2: %n"
              (length parse-results))))
  #
  (defn make-query-peg
    [an-ast arr]
    (var saw-ws-last-time nil)
    (defn gen*
      [an-ast arr]
      (def head (first an-ast))
      (when (and (or (not= :ws/eol head)
                     (not= :ws/horiz head))
                 saw-ws-last-time)
        (set saw-ws-last-time false))
      (case head
        :code
        (each elt (drop 2 an-ast)
          (gen* elt arr))
        #
        :blob
        (array/push arr (in an-ast 2))
        :cmt/line
        (array/push arr (in an-ast 2))
        :str/dq
        (array/push arr (in an-ast 2))
        :str/bt
        (array/push arr (in an-ast 2))
        :ws/eol
        (when (not saw-ws-last-time)
          (set saw-ws-last-time true)
          (array/push arr :s+))
        :ws/horiz
        (when (not saw-ws-last-time)
          (set saw-ws-last-time true)
          (array/push arr :s+))
        #
        :blank
        (array/concat arr (parse-blank-data (in an-ast 2)))
        #
        :dl/square
        (do
          (array/push arr "[")
          (each elt (drop 2 an-ast)
            (gen* elt arr))
          (array/push arr "]"))
        :dl/round
        (do
          (array/push arr "(")
          (each elt (drop 2 an-ast)
            (gen* elt arr))
          (array/push arr ")"))
        :dl/curly
        (do
          (array/push arr "{")
          (each elt (drop 2 an-ast)
            (gen* elt arr))
          (array/push arr "}"))
        )
      #
      arr)
    #
    (gen* an-ast arr))
  #
  {:lang-grammar lang-grammar
   :loc-table loc->node
   :parse-query parse-query
   :query-grammar query-grammar
   :make-query-peg make-query-peg
   :parse-blank-data parse-blank-data})

(comment

  (def {:lang-grammar l-grammar
        :query-grammar q-grammar
        :parse-query parse-query}
    (idx/jq/make-infra {:safe-delim `\`}))

  (get (peg/match l-grammar `2`) 3)
  # =>
  '(:blob @{:bc 1 :bl 1 :bp 0 :ec 2 :el 1 :ep 1} "2")

  (array/slice (peg/match q-grammar `(+ \a\ 2)`)
               3 (dec (- 3)))
  # =>
  '@[(:dl/round @{:bc 1 :bl 1 :bp 0 :ec 10 :el 1 :ep 9}
                (:blob @{:bc 2 :bl 1 :bp 1 :ec 3 :el 1 :ep 2} "+")
                (:ws/horiz @{:bc 3 :bl 1 :bp 2 :ec 4 :el 1 :ep 3} " ")
                (:blank @{:bc 4 :bl 1 :bp 3 :ec 7 :el 1 :ep 6} "a")
                (:ws/horiz @{:bc 7 :bl 1 :bp 6 :ec 8 :el 1 :ep 7} " ")
                (:blob @{:bc 8 :bl 1 :bp 7 :ec 9 :el 1 :ep 8} "2"))]

  (parse-query `(+ \a\ 2)`)
  # =>
  '@[:code @{:bc 1 :bl 1 :bp 0 :ec 10 :el 1 :ep 9}
     (:dl/round @{:bc 1 :bl 1 :bp 0 :ec 10 :el 1 :ep 9}
                (:blob @{:bc 2 :bl 1 :bp 1 :ec 3 :el 1 :ep 2} "+")
                (:ws/horiz @{:bc 3 :bl 1 :bp 2 :ec 4 :el 1 :ep 3} " ")
                (:blank @{:bc 4 :bl 1 :bp 3 :ec 7 :el 1 :ep 6} "a")
                (:ws/horiz @{:bc 7 :bl 1 :bp 6 :ec 8 :el 1 :ep 7} " ")
                (:blob @{:bc 8 :bl 1 :bp 7 :ec 9 :el 1 :ep 8} "2"))]

  (parse-query
    ``
    janet_def(\:...\ "janet/version", \:...\);
    ``)
  # =>
  '@[:code @{:bc 1 :bl 1 :bp 0 :ec 43 :el 1 :ep 42}
     (:blob @{:bc 1 :bl 1 :bp 0 :ec 10 :el 1 :ep 9} "janet_def")
     (:dl/round
       @{:bc 10 :bl 1 :bp 9 :ec 42 :el 1 :ep 41}
       (:blank @{:bc 11 :bl 1 :bp 10 :ec 17 :el 1 :ep 16} ":...")
       (:ws/horiz @{:bc 17 :bl 1 :bp 16 :ec 18 :el 1 :ep 17} " ")
       (:str/dq @{:bc 18 :bl 1 :bp 17 :ec 33 :el 1 :ep 32}
                "\"janet/version\"")
       (:blob @{:bc 33 :bl 1 :bp 32 :ec 34 :el 1 :ep 33} ",")
       (:ws/horiz @{:bc 34 :bl 1 :bp 33 :ec 35 :el 1 :ep 34} " ")
       (:blank @{:bc 35 :bl 1 :bp 34 :ec 41 :el 1 :ep 40} ":..."))
     (:blob @{:bc 42 :bl 1 :bp 41 :ec 43 :el 1 :ep 42} ";")]

  )

(comment

  (def {:parse-blank-data parse-blank-data}
    (idx/jq/make-infra {:safe-delim `\`}))

  (parse-blank-data `:...`)
  # =>
  '[(drop (any :input))]

  (parse-blank-data `'(sequence (range "09") (to "\n"))`)
  # =>
  '[(drop (sequence (range "09") (to "\n")))]

  # '8 -macro-expand-> (quote 8) -eval-> 8
  (parse-blank-data `'8`)
  # =>
  '[(drop 8)]

  (parse-blank-data `12`)
  # =>
  [12]

  (parse-blank-data `"i am a string"`)
  # =>
  ["i am a string"]

  (parse-blank-data `::name ~2`)
  # =>
  '[(constant ::name) 2]

  (parse-blank-data `::name '1`)
  # =>
  '[(constant ::name) 1]

  (parse-blank-data `::name ''1`)
  # =>
  '[(constant ::name) (quote 1)]

  (try
    (parse-blank-data `::name 8`)
    ([e]
      (truthy? (string/find "don't capture" e))))
  # =>
  true

  (try
    (parse-blank-data `::name "fun string"`)
    ([e]
      (truthy? (string/find "don't capture" e))))
  # =>
  true

  (parse-blank-data `::name :form`)
  # =>
  '[(constant ::name) :form]

  (parse-blank-data `:form`)
  # =>
  '[(drop :form)]

  )

# the idea in the following function is to modify a grammar that
# produces a tree of nodes from a string that represents janet code,
# and use peg/match with this modified grammar to execute our query.
#
# instead of using the capture stack to capture the desired result, a
# separate "backstack" is used to collect desired targets as tables.
#
# the ordinary capture stack is not interfered with so it can be used
# in the ordinary fashion to produce the tree of nodes.  this makes
# getting at the desired results easier, but possibly it also doesn't
# mess up the capturing process (though not sure of this latter point).
(defn idx/jq/query
  [query-str src-str &opt opts]
  #
  (def [safe-left-delim safe-right-delim]
    [`\` `\`])
  #
  (def [blank-left blank-right]
    (if-let [[bl br] (get opts :blank-delims)]
      [bl br]
      [safe-left-delim safe-right-delim]))
  # XXX: does this help?  can anything else be done?
  (when (or (and (not= blank-left safe-left-delim)
                 (string/find safe-left-delim query-str))
            (and (not= blank-right safe-right-delim)
                 (string/find safe-right-delim query-str)))
    (eprintf ``
             query-str contains characters that should be avoided:

             query-str:

             %s

             left delim: %s
             right delim: %s
             ``
             query-str safe-left-delim safe-right-delim))
  #
  (def {:lang-grammar l-grammar
        :loc-table loc->node
        :parse-query parse-query
        :make-query-peg make-query-peg
        :query-grammar q-grammar}
    # XXX: only one delim?
    (idx/jq/make-infra {:safe-delim safe-left-delim}))
  # XXX
  (idx/d/deprintf "query-str: %n" query-str)
  #
  (idx/d/deprintf "blank-delims: %n" (get opts :blank-delims))
  # XXX: does this handle all cases?
  (def safe-query-str
    (if-let [[left-delim right-delim] (get opts :blank-delims)]
      (->> query-str
           (string/replace-all left-delim safe-left-delim)
           (string/replace-all right-delim safe-right-delim))
      query-str))
  # XXX
  (idx/d/deprintf "safe-query-str: %n" safe-query-str)
  (def query-tree
    (parse-query safe-query-str))
  # XXX
  (idx/d/deprintf "query-tree: %n" query-tree)
  (def backstack @[])
  (def converted
    (make-query-peg query-tree @[]))
  # XXX
  (idx/d/deprintf "converted: %n" converted)
  # merge successive :s+ to allow more readable queries
  (def massaged
    (reduce (fn [acc item]
              (if (and (= :s+ (last acc))
                       (= :s+ item))
                acc
                (array/push acc item)))
            @[]
            converted))
  # XXX
  (idx/d/deprintf "massaged: %n" massaged)
  (def query-peg
    ~(cmt (sequence ,;massaged)
          ,(fn [& args]
             # XXX
             (if (empty? args)
               (idx/d/deprint "args was empty")
               (idx/d/deprintf "args: %n" args))
             # capture elsewhere, but only if non-empty args
             (when (not (empty? args))
               (array/push backstack (table ;args)))
             # pass-thru -- XXX: but does this really work?
             args)))
  # integrate the query-peg with the language grammar
  (def search-grammar
    (-> (struct/to-table l-grammar)
        (put :main ~(some :input))
        # add our query to the grammar
        (put :query query-peg)
        # make the query one of the items in the choice special for
        # :form so querying works on "interior" forms.  otherwise only
        # top-level captures show up.
        (put :form (let [old-form (get l-grammar :form)]
                     (tuple 'choice
                            :query
                            ;(tuple/slice old-form 1))))))
  # XXX: affects loc->node content
  #(d/deprintf "parsing src-str with l-grammar:\n\n%n"
  #              (peg/match l-grammar src-str))
  #
  [backstack
   (peg/match search-grammar src-str)
   loc->node])

(comment

  (def query-str
    `(def \::name :blob\ \::value :input\)`)

  (def src-str
    ``
    (def a 1)

    (defn b
      [x y]
      (def c [2 3]))

    (b)

    (def x :a)
    ``)

  (def [results _ loc->node]
    (idx/jq/query query-str src-str {:blank-delims [`\` `\`]}))

  (length results)
  # =>
  3

  (length loc->node)
  # =>
  33

  (has-key? loc->node {:bc 8 :bl 5 :bp 34
                       :ec 9 :el 5 :ep 35})
  # =>
  true

  (get loc->node {:bc 8 :bl 5 :bp 34
                  :ec 9 :el 5 :ep 35})
  # =>
  '(:blob @{:bc 8 :bl 5 :bp 34
            :ec 9 :el 5 :ep 35}
          "c")

  results
  # =>
  '@[@{::name
       (:blob @{:bc 6 :bl 1 :bp 5 :ec 7 :el 1 :ep 6} "a")
       ::value
       (:blob @{:bc 8 :bl 1 :bp 7 :ec 9 :el 1 :ep 8} "1")}
     @{::name
       (:blob @{:bc 8 :bl 5 :bp 34 :ec 9 :el 5 :ep 35} "c")
       ::value
       (:dl/square @{:bc 10 :bl 5 :bp 36 :ec 15 :el 5 :ep 41}
                   (:blob @{:bc 11 :bl 5 :bp 37 :ec 12 :el 5 :ep 38} "2")
                   (:ws/horiz @{:bc 12 :bl 5 :bp 38 :ec 13 :el 5 :ep 39} " ")
                   (:blob @{:bc 13 :bl 5 :bp 39 :ec 14 :el 5 :ep 40} "3"))}
     @{::name
       (:blob @{:bc 6 :bl 9 :bp 55 :ec 7 :el 9 :ep 56} "x")
       ::value
       (:blob @{:bc 8 :bl 9 :bp 57 :ec 10 :el 9 :ep 59} ":a")}]

  (get loc->node {:bc 8 :bl 1 :bp 7 :ec 9 :el 1 :ep 8})
  # =>
  '(:blob @{:bc 8 :bl 1 :bp 7
            :ec 9 :el 1 :ep 8}
          "1")

  )



########################################################################

(defn idx/ij/find-janet-tags
  [src]

  '(def src
     (slurp
       (string (os/getenv "HOME") "/src/janet/src/boot/boot.janet")))

  (def query-str
    ``
    (<::type '[capture [choice "defn-" "defn"
                               "defdyn"
                               "defmacro-" "defmacro"
                               "def-" "def"
                               "var-" "var"]]>
     <::name :blob>
     <:...>)
    ``)

  (def [results _ loc->node]
    (idx/jq/query query-str src {:blank-delims [`<` `>`]}))

  (def {:grammar loc-grammar
        :issuer issue-id
        :node-table id->node
        :loc-table loc->id
        :reset reset}
    (idx/jc/make-infra))

  (def m-raw
    (peg/match loc-grammar src))

  # bounds info at indeces 0, 1, 2, and last 3 elements, so slice
  (def m
    (array/slice m-raw 3 (dec (- 3))))

  (def filtered
    (filter (fn [res]
              (def [_ attrs _] (get res ::name))
              (def loc (freeze attrs))
              (def id (loc->id loc))
              (unless id
                (eprintf "no id for loc: %p" loc)
                (break))
              (def parent-tuple
                (idx/jc/up (idx/jc/make-cursor id->node
                                       (get id->node id))))
              (unless parent-tuple (break))
              (def grent-tuple
                (idx/jc/up parent-tuple))
              (unless grent-tuple
                # top-level
                (break true))
              # should succeed given how we got here from below
              (def head-node
                ((idx/jc/down grent-tuple) :node))
              (def [_ _ head-name] head-node)
              # XXX: any other things (e.g. compif)?
              (= "compwhen" head-name))
            results))

  (idx/idx/get-first-lines-and-offsets! src filtered ::name)

  # input:
  #
  # (@{"name" (:symbol @{:bc 6 :bl 10 :ec 10 :el 10} "defn")
  #    :first-line ..
  #    :offset ..
  #    "type" "def"} ...
  #
  # output:
  #
  #  @[["(def defn :macro"
  #    "defn"
  #    (string 10)
  #    (string 106)]
  #    ...]
  #
  (def results
    (seq [tbl :in filtered
          :let [first-line (get tbl :first-line)
                [_ attrs id] (get tbl ::name)
                line-no (get attrs :bl)
                offset (get tbl :offset)]]
      # XXX: hack to capture all ids in an array
      (array/push (dyn :all-ids) id)
      [first-line
       id
       (string line-no)
       (string offset)]))

  results)

########################################################################

(defn idx/ij/index-janet-boot!
  [out-buf]
  (def boot-janet-path "src/boot/boot.janet")
  (def src
    (slurp boot-janet-path))
  #
  (idx/idx/index-file! src boot-janet-path idx/ij/find-janet-tags out-buf))

(comment import ./tags :prefix "")
(comment import ./etags :prefix "")
# TAGS (emacs tags file format)

```

path,line

path,line
search-string,idline,offset-from-start
...
search-string,idline,offset-from-start

```

```
 - 0x01
 - 0x0c
 - 0x7f
```

# SOH - start of heading
(def idx/etags/start-of-heading
  (string/from-bytes 0x01))

# FF - form feed
(def idx/etags/form-feed
  (string/from-bytes 0x0C))

# DEL - delete
(def idx/etags/delete
  (string/from-bytes 0x7F))

(def idx/etags/etags-grammar
  ~{:main (sequence (any (sequence :section-sep :section)) -1)
    :section-sep (sequence ,idx/etags/form-feed :eol)
    :section (cmt (sequence :file-line (any :tag-line))
                  ,(fn [path & rest]
                     (merge ;(keep (fn [m]
                                     # each m has only one key, the id
                                     (when-let [id (first (keys m))
                                                val (get m id)]
                                       (put m
                                            id (array/push val path))))
                                   rest))))
    :file-line (sequence (capture :path) "," :d+ :eol)
    # \r, \n are here to bound the matching to the current line
    :path (some (if-not (set ",\r\n") 1))
    :tag-line (cmt (sequence (capture :search-str)
                             :tag-line-sep-1
                             (capture :id)
                             :tag-line-sep-2
                             (number :d+)
                             ","
                             (opt (number :d+))
                             :eol)
                   # slightly complicated because offset is now optional
                   ,(fn [& caps]
                      @{(get caps 1)
                        @[;(array/slice caps 2) (get caps 0)]}))
    # \r, \n are here to bound the matching to the current line
    :search-str (some (if-not (choice :tag-line-sep-1 :eol) 1))
    # \r, \n are here to bound the matching to the current line
    :id (some (if-not (choice :tag-line-sep-2 :eol) 1))
    :eol (choice "\r\n" "\r" "\n")
    :tag-line-sep-1 ,idx/etags/delete
    :tag-line-sep-2 ,idx/etags/start-of-heading})

(comment

  (def etags
    ```
    
    src/core/pp.c,0
    
    src/core/tuple.c,275
    JANET_CORE_FN(cfun_tuple_brackets,tuple/brackets58,2136
    JANET_CORE_FN(cfun_tuple_slice,tuple/slice66,2433
    JANET_CORE_FN(cfun_tuple_type,tuple/type80,3259
    JANET_CORE_FN(cfun_tuple_sourcemap,tuple/sourcemap96,3928
    JANET_CORE_FN(cfun_tuple_setmap,tuple/setmap108,4432
    
    src/core/regalloc.c,0
    
    src/core/specials.c,0

    ```)

  (peg/match idx/etags/etags-grammar etags)
  # =>
  '@[@{}
     @{"tuple/brackets"
       @[58 2136 "JANET_CORE_FN(cfun_tuple_brackets," "src/core/tuple.c"]
       "tuple/setmap"
       @[108 4432 "JANET_CORE_FN(cfun_tuple_setmap," "src/core/tuple.c"]
       "tuple/slice"
       @[66 2433 "JANET_CORE_FN(cfun_tuple_slice," "src/core/tuple.c"]
       "tuple/sourcemap"
       @[96 3928 "JANET_CORE_FN(cfun_tuple_sourcemap," "src/core/tuple.c"]
       "tuple/type"
       @[80 3259 "JANET_CORE_FN(cfun_tuple_type," "src/core/tuple.c"]}
     @{}
     @{}]

  (def etags
    ```
    
    src/core/pp.c,0
    
    src/core/tuple.c,259
    JANET_CORE_FN(cfun_tuple_brackets,tuple/brackets58,
    JANET_CORE_FN(cfun_tuple_slice,tuple/slice66,
    JANET_CORE_FN(cfun_tuple_type,tuple/type80,
    JANET_CORE_FN(cfun_tuple_sourcemap,tuple/sourcemap96,
    JANET_CORE_FN(cfun_tuple_setmap,tuple/setmap108,
    
    src/core/regalloc.c,0
    
    src/core/specials.c,0

    ```)

  (peg/match idx/etags/etags-grammar etags)
  # =>
  '@[@{}
     @{"tuple/brackets"
       @[58 "JANET_CORE_FN(cfun_tuple_brackets," "src/core/tuple.c"]
       "tuple/setmap"
       @[108 "JANET_CORE_FN(cfun_tuple_setmap," "src/core/tuple.c"]
       "tuple/slice"
       @[66 "JANET_CORE_FN(cfun_tuple_slice," "src/core/tuple.c"]
       "tuple/sourcemap"
       @[96 "JANET_CORE_FN(cfun_tuple_sourcemap," "src/core/tuple.c"]
       "tuple/type"
       @[80 "JANET_CORE_FN(cfun_tuple_type," "src/core/tuple.c"]}
     @{}
     @{}]

  )


(def idx/tags/parse-peg
  '(sequence :s*
             "("
             (capture (to :s))
             :s))

(defn idx/tags/to-tags-kind
  [text]
  (def compiled-peg
    (peg/compile idx/tags/parse-peg))
  (if-let [[extracted] (peg/match compiled-peg text)]
    (case extracted
      "def" "d"
      "def-" "D"
      "defglobal" "g"
      "varglobal" "G"
      "defmacro" "m"
      "defmacro-" "M"
      "defn" "n"
      "defn-" "N"
      "varfn" "r"
      "var" "v"
      "var-" "V"
      "defdyn" "y"
      (errorf "Unexpected item: %p" extracted))
    "f"))

(comment

  (idx/tags/to-tags-kind
    "JANET_CORE_FN(cfun_tuple_brackets,")
  # =>
  "f"

  (idx/tags/to-tags-kind
    "(def defn :macro")
  # =>
  "d"

  (idx/tags/to-tags-kind
    "  (defn .disasm")
  # =>
  "n"

  (idx/tags/to-tags-kind
    (string `  `
            `(defdyn *ffi-context* " `
            `Current native library for ffi/bind and other settings")`))
  # =>
  "y"

  )

(comment

  '@[@{}
     @{"tuple/brackets"
       @[58 2136 "JANET_CORE_FN(cfun_tuple_brackets," "src/core/tuple.c"]
       "tuple/setmap"
       @[108 4432 "JANET_CORE_FN(cfun_tuple_setmap," "src/core/tuple.c"]
       "tuple/slice"
       @[66 2433 "JANET_CORE_FN(cfun_tuple_slice," "src/core/tuple.c"]
       "tuple/sourcemap"
       @[96 3928 "JANET_CORE_FN(cfun_tuple_sourcemap," "src/core/tuple.c"]
       "tuple/type"
       @[80 3259 "JANET_CORE_FN(cfun_tuple_type," "src/core/tuple.c"]}
     @{}
     @{}]

  '@[@{}
     @{"tuple/brackets"
       @[58 "JANET_CORE_FN(cfun_tuple_brackets," "src/core/tuple.c"]
       "tuple/setmap"
       @[108 "JANET_CORE_FN(cfun_tuple_setmap," "src/core/tuple.c"]
       "tuple/slice"
       @[66 "JANET_CORE_FN(cfun_tuple_slice," "src/core/tuple.c"]
       "tuple/sourcemap"
       @[96 "JANET_CORE_FN(cfun_tuple_sourcemap," "src/core/tuple.c"]
       "tuple/type"
       @[80 "JANET_CORE_FN(cfun_tuple_type," "src/core/tuple.c"]}
     @{}
     @{}]

  )

(defn idx/tags/etags-to-tags
  [etags-buf]
  (def out-lines @[])
  (def parsed
    (peg/match idx/etags/etags-grammar etags-buf))
  (each dict parsed
    (eachp [id info] dict
      (def line (first info))
      (def text
        (if (= 3 (length info))
          (get info 1)
          (get info 2)))
      (def path (last info))
      # XXX: tabs in text could cause problems if instead of line
      #      text converted to a regular expression is used
      (array/push out-lines
                  (string id "\t"
                          path "\t"
                          line "\t"
                          `;" ` (idx/tags/to-tags-kind text)))))
  #
  (sort out-lines))

(comment

  (def etags-buf
    @``
     
     src/boot/boot.janet,15056
     (def defn :macrodefn10,106
     (defn defmacro :macrodefmacro45,1087
     (defmacro as-macroas-macro51,1265
     (defmacro defmacro-defmacro-59,1557

     ``)

  (idx/tags/etags-to-tags etags-buf)
  # =>
  '@["as-macro\tsrc/boot/boot.janet\t51\t;\" m"
     "defmacro\tsrc/boot/boot.janet\t45\t;\" n"
     "defmacro-\tsrc/boot/boot.janet\t59\t;\" m"
     "defn\tsrc/boot/boot.janet\t10\t;\" d"]

  )



(def idx/version "DEVEL")

(def idx/usage
  ``
  Usage: idx.janet

  Generate `tags` / `TAGS` file for Janet source code

  Invoke in root of janet source repository directory.

  This handles lookups for:

  * Janet -> Janet  (e.g. defn in boot.janet)
  * Janet -> C      (e.g. set in specials.c)

  For C -> C lookups, consider an LSP server for C such as ccls or
  clangd.

  By default a `tags` file is generated.

  To create a `TAGS` instead (e.g. for use with emacs), set the
  `IJ_OUTPUT_FORMAT` environment variable to have the value `etags`,
  before invoking `idx.janet`.

  For example, on a *nix machine with certain shells, this could be
  something like:

    export IJ_OUTPUT_FORMAT=etags

  Other systems and/or shells may have a different way of setting
  environment variables.
  ``)

########################################################################

(defn idx/in-janet-src-dir?
  []
  (and (os/stat "janet.1")
       (os/stat "src")))

(defn idx/file-newest?
  [file-path dir-path]
  (def tags-mtime
    (get (os/stat file-path) :modified))
  (var newest-path file-path)
  (with [of (file/temp)]
    (def dir (os/cwd))
    (defer (os/cd dir)
      (os/cd dir-path)
      (def proc (os/execute ["git" "ls-files"] :px
                            {:out of}))
      # XXX: unneeded?
      (file/flush of)
      (file/seek of :set 0)
      (def content (string/trim (file/read of :all)))
      (def lines (string/split "\n" content))
      (each res lines
        (def mtime (get (os/stat res) :modified))
        (when (> mtime tags-mtime)
          (set newest-path res)
          (break)))))
  #
  (= newest-path file-path))

(defn idx/all-ids-valid?
  [all-ids]
  (and (array? all-ids)
       (all string? all-ids)))

(comment

  (idx/all-ids-valid? @["alice" "bob" "carol"])
  # =>
  true

  (idx/all-ids-valid? [:a :b :c])
  # =>
  false

  (idx/all-ids-valid? @["tom" :wall "jerry"])
  # =>
  false

  )

########################################################################

(defn idx/main
  [& argv]

  (when (or (not (idx/in-janet-src-dir?))
            (when-let [arg (get argv 1)]
              (= "--help" arg)))
    (print idx/usage)
    (break 0))

  (def opts
    @{:output-format "u-ctags"
      :file-extension ""})

  (when (os/getenv "IJ_C2C")
    (setdyn :ij-c2c true))

  (when (os/getenv "IJ_DEBUG")
    (setdyn :ij-debug true))

  (when-let [fmt (os/getenv "IJ_OUTPUT_FORMAT")]
    (when (nil? (get {"etags" true "u-ctags" true}
                     fmt))
      (errorf "Unrecognized IJ_OUTPUT_FORMAT value: %s" fmt))
    (put opts :output-format fmt))

  (def out-format
    (opts :output-format))

  (when-let [file-ext (os/getenv "IJ_FILE_EXTENSION")]
    (put opts :file-extension file-ext))

  (def file-extension
    (opts :file-extension))

  (def tags-fname
    (case out-format
      "etags"
      (string "TAGS" file-extension)
      #
      "u-ctags"
      (string "tags" file-extension)
      #
      (errorf "Unrecognized output-format: %s" out-format)))

  (def out-buf @"")

  # XXX: eventually index other janet files in source tree too?
  #      only seemed to ever index boot.janet

  # XXX: hack to capture all ids in an array
  (setdyn :all-ids @[])

  (idx/ij/index-janet-boot! out-buf)

  (each name (os/dir "src/core/")
    (def path (string "src/core/" name))
    (def src (slurp path))
    (cond
      (= "io.c" name)
      (idx/ij2c/index-janet-core-def-c! src path out-buf)
      #
      (= "math.c" name)
      (do
        (idx/ij2c/index-math-c! src path out-buf)
        (idx/ij2c/index-janet-core-def-c! src path out-buf))
      #
      (= "specials.c" name)
      (idx/ij2c/index-specials-c! src path out-buf)
      #
      (= "corelib.c" name)
      (idx/ij2c/index-corelib-c! src path out-buf))
    #
    (try
      (idx/ij2c/index-generic-c! src path out-buf)
      ([e]
        (eprintf "%s %s" e path)))
    #
    (when (dyn :ij-c2c)
      (try
        (idx/ic/index-c! src path out-buf)
        ([e]
          (eprintf "%s %s" e path)))))

  (when (dyn :ij-c2c)
    (def path
      "src/include/janet.h")
    (def src
      (slurp path))
    (try
      (idx/ic/index-c! src path out-buf)
      ([e]
        (eprintf "%s %s" e path))))

  (def out-lines
    (if (= out-format "u-ctags")
      (idx/tags/etags-to-tags out-buf)
      (string/split "\n" out-buf)))

  # write the index (u-ctags -> tags, etags -> TAGS)
  (with [tf (file/open tags-fname :w)]
    # XXX: yuck -- if a toggling sorting option is provided, following code
    #      probably needs to change
    (when (= out-format "u-ctags")
      (file/write tf
                  (string "!_TAG_FILE_SORTED\t"
                          "1\t"
                          "/0=unsorted, 1=sorted, 2=foldcase/\n")))
    (each line out-lines
      (when (not= line "") # XXX: not nice to be checking so many times
        (file/write tf line)
        (when (not (or (string/has-suffix? "\r" line)
                       (string/has-suffix? "\n" line)))
          (file/write tf "\n"))))
    (file/flush tf)))

########################################################################

(defn idx/build-index
  [j-src-path file-ext &opt format]
  (default format "etags")
  (def dir (os/cwd))
  (defer (os/cd dir)
    (os/cd j-src-path)
    (os/setenv "IJ_OUTPUT_FORMAT" format)
    (os/setenv "IJ_FILE_EXTENSION" file-ext)
    (idx/main)))


(comment import ./indent :prefix "")
### based on spork/fmt by bakpakin

### hint for comprehension
###
### study the call to `flushwhite` in `fmt-1` and everything
### that exists to support it

(defn indent/pnode
  "Make a capture function for a node."
  [tag]
  (fn [x] [tag x]))

# all nodes except one have the form:
#
#   [:tag-name ...]
#
# the sole exception is the node for a newline which is:
#
#   "\n"
#
# there are 3 kinds of non-newline whitespace:
#
# 1. :ws-bi - before indentation (leading whitespace)
# 2. :ws-tr - after last non-whitespace (trailing whitespace)
# 3. :ws    - there is non-whitespace somewhere to the left and right
#
# example:
#
# bol   (+ 1 1)   eol
#    ^^^  ^    ^^^
#     |   |     |
#     |  :ws    |
#     |      :ws-tr
#  :ws-bi
#
# bol stands for beginning of line
# eol stands for end of line
(defn indent/make-tree
  "Turn a string of source code into a tree that will be printed"
  [source]
  (var bi true)
  #
  (def parse-peg
    "Peg to parse Janet with extra information, namely comments."
    (peg/compile
      ~{:nl "\n"
        :ws (cmt (sequence (capture (some (set " \t\r\f\0\v")))
                           (look 0 (choice -1
                                           (capture 1))))
                 ,(fn [& args]
                    (def ws (get args 0))
                    (cond
                      (and bi
                           (= 2 (length args))
                           (not= "\n" (get args 1)))
                      [:ws-bi ws]
                      #
                      (= 1 (length args))
                      [:ws-tr ws]
                      #
                      (= 2 (length args))
                      (if (= "\n" (get args 1))
                        [:ws-tr ws]
                        [:ws ws])
                      #
                      (do
                        (eprintf "unexpected ws info: %p %p"
                                 args (length args))
                        (error "unexpected input")))))
        :readermac (set "';~,|")
        :symchars (choice (range "09" "AZ" "az" "\x80\xFF")
                          (set "!$%&*+-./:<?=>@^_"))
        :token (some :symchars)
        :escape
        (sequence "\\" (choice (set `"'0?\abefnrtvz`)
                               (sequence "x" (2 :h))
                               (sequence "u" (4 :h))
                               (sequence "U" (6 :h))
                               (error (constant "bad hex escape"))))
        :comment (replace (sequence "#"
                                    (capture (to (choice "\n" -1))))
                          ,(indent/pnode :comment))
        :span (replace (capture :token)
                       ,(indent/pnode :span))
        :bytes (capture (sequence `"`
                                  (any (choice :escape
                                               (if-not `"` 1)))
                                  `"`))
        :string (replace :bytes ,(indent/pnode :string))
        :buffer (replace (sequence "@" :bytes)
                         ,(indent/pnode :buffer))
        :long-bytes
        (capture {:delim (some "`")
                  :open (capture :delim :n)
                  :close (cmt (sequence (not (look -1 "`"))
                                        (backref :n)
                                        (capture :delim))
                              ,=)
                  :main (drop (sequence :open
                                        (any (if-not :close 1))
                                        :close))})
        :long-string (replace :long-bytes ,(indent/pnode :string))
        :long-buffer (replace (sequence "@" :long-bytes)
                              ,(indent/pnode :buffer))
        :ptuple (replace (group (sequence "("
                                          (any :input)
                                          (choice ")" (error))))
                         ,(indent/pnode :ptuple))
        :btuple (replace (group (sequence "["
                                          (any :input)
                                          (choice "]" (error))))
                         ,(indent/pnode :btuple))
        :struct (replace (group (sequence "{"
                                          (any :input)
                                          (choice "}" (error))))
                         ,(indent/pnode :struct))
        :parray (replace (group (sequence "@("
                                          (any :input)
                                          (choice ")" (error))))
                         ,(indent/pnode :array))
        :barray (replace (group (sequence "@["
                                          (any :input)
                                          (choice "]" (error))))
                         ,(indent/pnode :array))
        :table (replace (group (sequence "@{"
                                         (any :input)
                                         (choice "}" (error))))
                        ,(indent/pnode :table))
        :rmform (replace (group (sequence ':readermac
                                          (group (any :non-form))
                                          :form))
                         ,(indent/pnode :rmform))
        :unreadable (replace
                      (capture
                        (sequence "<"
                                  (between 1 32 :symchars)
                                  :s+
                                  (some (if (choice :symchars
                                                    :d)
                                          1))
                                  (look -1 ">")
                                  (look 0 (choice -1
                                                  (not (choice :symchars
                                                               :d))))))
                      ,(indent/pnode :unreadable))
        :form
        (sequence (drop (cmt (constant "smile")
                             ,(fn [& args]
                                (set bi false)
                                true)))
                  (choice :unreadable
                          :rmform
                          :parray :barray :ptuple :btuple :table :struct
                          :buffer :string :long-buffer :long-string
                          :span))
        :non-form
        (choice :ws
                # :nl
                (cmt (capture :nl)
                     ,(fn [& args]
                        (set bi true)
                        (first args)))
                # :comment
                (sequence (drop (cmt (constant "smile")
                                     ,(fn [& args]
                                        (set bi false)
                                        true)))
                          :comment))
        :input
        (choice :non-form
                (cmt (capture :form)
                     ,(fn [& args]
                        (set bi false)
                        (first args))))
        :main (sequence (any :input)
                        (choice -1 (error)))}))
  #
  [:top (peg/match parse-peg source)])

(comment

  (indent/make-tree "# hello\n")
  # =>
  '(:top @[(:comment " hello") "\n"])

  (indent/make-tree "(+ 1 1)")
  # =>
  '(:top
     @[(:ptuple
         @[(:span "+") (:ws " ")
           (:span "1") (:ws " ")
           (:span "1")])])

  (indent/make-tree " (+ 1 1) ")
  # =>
  '(:top
     @[(:ws-bi " ")
       (:ptuple
         @[(:span "+") (:ws " ")
           (:span "1") (:ws " ")
           (:span "1")])
       (:ws-tr " ")])

  (indent/make-tree
    (string "(comment\n"
            "\n"
            "  :hi\n"
            "  #\n"
            "  )"))
  # =>
  '(:top
     @[(:ptuple
         @[(:span "comment") "\n"
           "\n"
           (:ws-bi "  ") (:span ":hi") "\n"
           (:ws-bi "  ") (:comment "") "\n"
           (:ws-bi "  ")])])

  (indent/make-tree
    (string "(do \n"
            "(def _0000by \n"
            "[0 1 2]) \n"
            "(var _0000bx \n"
            "(<function next> _0000by nil)) \n"
            "(while (<function not=> nil _0000bx) \n"
            "(def i \n"
            "(<function in> _0000by _0000bx)) \n"
            "(break) \n"
            "(set _0000bx \n"
            "(<function next> _0000by _0000bx))))"))
  # =>
  '(:top
     @[(:ptuple
         @[(:span "do") (:ws-tr " ") "\n"
           (:ptuple
             @[(:span "def") (:ws " ")
               (:span "_0000by") (:ws-tr " ") "\n"
               (:btuple
                 @[(:span "0") (:ws " ")
                   (:span "1") (:ws " ")
                   (:span "2")])]) (:ws-tr " ") "\n"
           (:ptuple
             @[(:span "var") (:ws " ")
               (:span "_0000bx") (:ws-tr " ") "\n"
               (:ptuple
                 @[(:unreadable "<function next>") (:ws " ")
                   (:span "_0000by") (:ws " ")
                   (:span "nil")])]) (:ws-tr " ") "\n"
           (:ptuple
             @[(:span "while") (:ws " ")
               (:ptuple
                 @[(:unreadable "<function not=>") (:ws " ")
                   (:span "nil") (:ws " ")
                   (:span "_0000bx")]) (:ws-tr " ") "\n"
               (:ptuple
                 @[(:span "def") (:ws " ")
                   (:span "i") (:ws-tr " ") "\n"
                   (:ptuple
                     @[(:unreadable "<function in>") (:ws " ")
                       (:span "_0000by") (:ws " ")
                       (:span "_0000bx")])]) (:ws-tr " ") "\n"
               (:ptuple
                 @[(:span "break")]) (:ws-tr " ") "\n"
               (:ptuple
                 @[(:span "set") (:ws " ")
                   (:span "_0000bx") (:ws-tr " ") "\n"
                   (:ptuple
                     @[(:unreadable "<function next>") (:ws " ")
                       (:span "_0000by") (:ws " ")
                       (:span "_0000bx")])])])])])

  )

# added `comment`
(def indent/indent-2-forms
  "A list of forms that are control forms and should be indented two spaces."
  (invert ["case" "catseq" "comment" "compif" "compwhen" "cond" "coro"
           "def" "def-" "default" "defer" "defglobal" "defmacro" "defmacro-"
           "defn" "defn-" "do"
           "each" "eachp" "eachk" "eachy" "edefer" "ev/do-thread" "ev/spawn"
           "ev/with-deadline"
           "fn" "for" "forever" "forv"
           "generate"
           "if" "if-let" "if-not" "if-with"
           "label" "let" "loop"
           "match"
           "prompt"
           "repeat"
           "seq" "short-fn"
           "tabseq" "try"
           "unless" "upscope"
           "var" "varfn" "varglobal" "var-"
           "when" "when-let" "when-with" "while" "with" "with-dyns"
           "with-syms" "with-vars"]))

(def indent/indent-2-peg
  "Peg to use to fuzzy match certain forms."
  (peg/compile ~(choice "with-" "def" "if-" "when-")))

(defn indent/first-non-ws-is-nl?
  [xs]
  (var result nil)
  (each x xs
    (when (= "\n" x)
      (set result true)
      (break))
    (when-let [[tag _] x]
      (when (and (not= :ws-bi tag)
                 (not= :ws tag)
                 (not= :ws-tr tag))
        (break false))))
  (truthy? result))

(comment

  (indent/first-non-ws-is-nl? ["\n" [:ws " "]])
  # =>
  true

  (indent/first-non-ws-is-nl? [[:ws " "] "\n" [:ws " "]])
  # =>
  true

  (indent/first-non-ws-is-nl? [[:ws-bi " "] "\n" [:ws " "]])
  # =>
  true

  (indent/first-non-ws-is-nl? [[:ws-tr " "] "\n" [:ws " "]])
  # =>
  true

  (indent/first-non-ws-is-nl? [[:comment " hi"] "\n" [:ws " "]])
  # =>
  false

  )

(defn indent/check-indent-2
  "Check if a tuple needs a 2 space indent or not"
  [items]
  (if-let [[tag body] (get items 0)]
    (cond
      (indent/first-non-ws-is-nl? (slice items 1)) true
      (not= tag :span) nil
      (in indent/indent-2-forms body) true
      (peg/match indent/indent-2-peg body) true)))

(defn indent/check-data-indent
  "Check if a tuple should be formatted as data"
  [items]
  (when-let [[head-node] items]
    (match head-node
      "\n" true
      [:comment _] true
      [:ws _] true
      # XXX: can these happen?
      [:ws-bi _] true
      [:ws-tr _] true)))

(defn indent/non-nls
  [xs]
  (filter |(not= $ "\n") xs))

(defn indent/has-nl?
  [xs]
  (truthy? (find |(= $ "\n") xs)))

(defn indent/fmt
  "Emit formatted."
  [tree]

  # tracks current column based on emitted content
  #   modified by `emit` and `newline`
  #   mostly used by `indent`
  #   also used by `emit-body` and `emit-funcall` for some edge cases
  (var col 0)

  # stack for saving / restoring `white`
  #   manipulated by `indent` and `dedent`
  (def ident-stack @[])

  # what `white` is reset to when `newline` is called
  #   also is saved/restored to/from `ident-stack`
  (var ident "")

  # whitespace that will be output via `flushwhite`
  #   manipulated directly by `flushwhite`, `dropwhite`, `newline`
  #   also indirectly via `dropwhite` by:
  #     `newline`
  #     `emit-body`
  #     `emit-funcall`
  #     `emit-string`
  (def white @"")

  # `emit` and `newline` are the only things that output directly
  # (`fmt-1` now directly outputs trailing whitespace)
  #
  # `emit` is called by:
  #   `flushwhite`
  #   `emit-body`
  #   `emit-funcall``
  #   `emit-string`
  #   `emit-rmform`
  #   `fmt-1`
  #
  # `newline` is called by:
  #   `emit-string`
  #   `fmt-1`
  #
  # `fmt-1` is the only caller of:
  #   `flushwhite`
  #   `emit-body`
  #   `emit-funcall`
  #   `emit-string`
  #   `emit-rmform`

  (defn emit [& xs]
    (each x xs
      # parsed content contains delimiters (e.g. strings include "s)
      (+= col (length x))
      (prin x)))

  (defn indent [&opt delta]
    (array/push ident-stack ident)
    (set ident
         (string/repeat " " (+ col (or delta 0)))))

  (defn dedent []
    (set ident
         (array/pop ident-stack)))

  (defn flushwhite []
    (emit white)
    (buffer/clear white))

  (defn dropwhite []
    (buffer/clear white))

  (defn newline []
    (dropwhite)
    (print)
    (buffer/push-string white ident)
    (set col 0))

  # Mutual recursion
  (var fmt-1-recur nil)

  (defn emit-body
    [open xs close &opt delta top]
    (def od-col col)
    (emit open)
    #
    (indent delta)
    (each x xs (fmt-1-recur x))
    (dropwhite)
    (dedent)
    # XXX: messy part
    (when (not top)
      (cond
        # empty container case
        (and (indent/has-nl? xs) (zero? (length (indent/non-nls xs))))
        (emit (tracev (string/repeat " " (+ od-col 1))))
        # XXX: actually want alignment with opening delimiter
        #      of 2nd non-ws, non-comment child?
        (zero? col)
        (emit (string/repeat " "
                             (+ od-col 1 (or delta 0))))))
    #
    (emit close))

  (defn emit-funcall
    [xs]
    (def od-col col)
    (emit "(")
    #
    (def len (length xs))
    (when (pos? len)
      (fmt-1-recur (xs 0))
      (indent 1)
      (for i 1 len (fmt-1-recur (xs i)))
      (dropwhite)
      (dedent))
    # XXX: messy part
    (cond
      # empty tuple case
      (and (indent/has-nl? xs) (zero? (length (indent/non-nls xs))))
      (emit (string/repeat " " (+ od-col 1)))
      # XXX: actually want alignment with opening delimiter
      #      of 2nd non-ws, non-comment child?
      (zero? col)
      (emit (string/repeat " " (+ od-col 1))))
    #
    (emit ")"))

  (defn emit-string
    [x]
    (def parts
      (interpose "\n" (string/split "\n" x)))
    (each p parts
      (if (= p "\n")
        (do (newline) (dropwhite))
        (emit p))))

  (defn emit-rmform
    [rm nfs form]
    (emit rm)
    (each nf nfs
      (fmt-1-recur nf))
    (fmt-1-recur form))

  (defn fmt-1
    [node]
    # insert appropriate whitespace
    (when (and (not= "\n" node)
               (not= :ws-tr (get node 0)))
      (flushwhite))
    # node-specific "emission"
    (match node
      "\n" (newline)
      [:ws-bi x] (prin "")
      [:ws x] (emit x)
      [:ws-tr x] (prin x)
      [:comment x] (emit "#" x)
      [:span x] (emit x)
      [:string x] (emit-string x)
      [:buffer x] (do (emit "@") (emit-string x))
      [:array xs] (emit-body "@[" xs "]")
      [:btuple xs] (emit-body "[" xs "]")
      [:ptuple xs] (cond
                     (indent/check-data-indent xs)
                     (emit-body "(" xs ")")
                     #
                     (indent/check-indent-2 xs)
                     (emit-body "(" xs ")" 1)
                     #
                     (emit-funcall xs))
      [:struct xs] (emit-body "{" xs "}")
      [:table xs] (emit-body "@{" xs "}")
      [:rmform [rm nfs form]] (emit-rmform rm nfs form)
      [:unreadable x] (emit x)
      [:top xs] (emit-body "" xs "" nil true)))

  (set fmt-1-recur fmt-1)
  (fmt-1 tree)
  (flush))

#
# Public API
#

(defn indent/format-print
  "Format a string of source code and print the result."
  [source]
  (-> source indent/make-tree indent/fmt))

(defn indent/format
  "Format a string of source code to a buffer."
  [source]
  (def out @"")
  (with-dyns [:out out]
    (indent/format-print source))
  out)

(comment

  (indent/format
    ``
    (do
    (def _0000by
    [0 1 2])
    (var _0000bx
    (<function next> _0000by nil))
    (while (<function not=> nil _0000bx)
    (def i
    (<function in> _0000by _0000bx))
    (break)
    (set _0000bx
    (<function next> _0000by _0000bx))))
    ``)
  # =>
  @``
   (do
     (def _0000by
       [0 1 2])
     (var _0000bx
       (<function next> _0000by nil))
     (while (<function not=> nil _0000bx)
       (def i
         (<function in> _0000by _0000bx))
       (break)
       (set _0000bx
            (<function next> _0000by _0000bx))))
   ``
  )

(defn indent/format-file
  "Format a file"
  [file]
  (def source (slurp file))
  (def out (indent/format source))
  (spit file out))

(comment import ./print :prefix "")
(comment import ./indent :prefix "")

(comment import ./colorize :prefix "")


(defn pr/print-nicely
  [expr-str]
  (let [buf (indent/format expr-str)
        lines (string/split "\n" (col/colorize buf))]
    (when (zero? (length (last lines)))
      (array/pop lines))
    (each line lines
      (print line))))

(defn pr/print-nicely-mono
  [expr-str]
  (let [buf (indent/format expr-str)
        lines (string/split "\n" buf)]
    (when (zero? (length (last lines)))
      (array/pop lines))
    (each line lines
      (print line))))

(defn pr/print-separator
  []
  (print (string/repeat "#" (dyn :jref-width))))


(comment import ./quiz :prefix "")
(comment import ./location-with-unreadable :prefix "")

(comment import ./jipper :prefix "")

(comment import ./print :prefix "")

(comment import ./random :prefix "")
(defn rnd/choose
  [things]
  (let [idx (math/rng-int (dyn :jref-rng
                               (math/rng (os/cryptorand 8)))
                          (length things))]
    (get things idx)))

(comment

  (do
    (def things
      [:a :b :c :x :y :z])

    (setdyn :jref-rng
            (math/rng (os/cryptorand 8)))

    (var result true)

    (for i 0 100
      (unless (index-of (rnd/choose things) things)
        (set result false)))

    result)
  # =>
  true

  )


(comment import ./tests :prefix "")
(comment import ./location-with-unreadable :prefix "")

(comment import ./jipper :prefix "")


# ti == test indicator, which can look like any of:
#
# # =>
# # before =>
# # => after
# # before => after

(defn tests/find-test-indicator
  [zloc]
  (var label-left nil)
  (var label-right nil)
  [(j/right-until zloc
                  |(match (j/node $)
                     [:comment _ content]
                     (if-let [[l r]
                              (peg/match ~(sequence "#"
                                                    (capture (to "=>"))
                                                    "=>"
                                                    (capture (thru -1)))
                                         content)]
                       (do
                         (set label-left (string/trim l))
                         (set label-right (string/trim r))
                         true)
                       false)))
   label-left
   label-right])

(comment

  (def src
    ``
    (+ 1 1)
    # =>
    2
    ``)

  (let [[zloc l r]
        (tests/find-test-indicator (-> (lwu/par src)
                                 j/zip-down))]
    (and zloc
         (empty? l)
         (empty? r)))
  # =>
  true

  (def src
    ``
    (+ 1 1)
    # before =>
    2
    ``)

  (let [[zloc l r]
        (tests/find-test-indicator (-> (lwu/par src)
                                 j/zip-down))]
    (and zloc
         (= "before" l)
         (empty? r)))
  # =>
  true

  (def src
    ``
    (+ 1 1)
    # => after
    2
    ``)

  (let [[zloc l r]
        (tests/find-test-indicator (-> (lwu/par src)
                                 j/zip-down))]
    (and zloc
         (empty? l)
         (= "after" r)))
  # =>
  true

  )

(defn tests/find-test-expr
  [ti-zloc]
  # check for appropriate conditions "before"
  (def before-zlocs @[])
  (var curr-zloc ti-zloc)
  (var found-before nil)
  (while curr-zloc
    (set curr-zloc
         (j/left curr-zloc))
    (when (nil? curr-zloc)
      (break))
    (match (j/node curr-zloc)
      [:comment]
      (array/push before-zlocs curr-zloc)
      #
      [:whitespace]
      (array/push before-zlocs curr-zloc)
      #
      (do
        (set found-before true)
        (array/push before-zlocs curr-zloc)
        (break))))
  #
  (cond
    (nil? curr-zloc)
    :no-test-expression
    #
    (and found-before
         (->> (slice before-zlocs 0 -2)
              (filter |(not (match (j/node $)
                              [:whitespace]
                              true)))
              length
              zero?))
    curr-zloc
    #
    :unexpected-result))

(comment

  (def src
    ``
    (comment

      (def a 1)

      (put @{} :a 2)
      # =>
      @{:a 2}

      )
    ``)

  (def [ti-zloc _ _]
    (tests/find-test-indicator (-> (lwu/par src)
                             j/zip-down
                             j/down)))

  (j/node ti-zloc)
  # =>
  '(:comment @{:bc 3 :bl 6 :ec 7 :el 6} "# =>")

  (def test-expr-zloc
    (tests/find-test-expr ti-zloc))

  (j/node test-expr-zloc)
  # =>
  '(:tuple @{:bc 3 :bl 5 :ec 17 :el 5}
           (:symbol @{:bc 4 :bl 5 :ec 7 :el 5} "put")
           (:whitespace @{:bc 7 :bl 5 :ec 8 :el 5} " ")
           (:table @{:bc 8 :bl 5 :ec 11 :el 5})
           (:whitespace @{:bc 11 :bl 5 :ec 12 :el 5} " ")
           (:keyword @{:bc 12 :bl 5 :ec 14 :el 5} ":a")
           (:whitespace @{:bc 14 :bl 5 :ec 15 :el 5} " ")
           (:number @{:bc 15 :bl 5 :ec 16 :el 5} "2"))

  (-> (j/left test-expr-zloc)
      j/node)
  # =>
  '(:whitespace @{:bc 1 :bl 5 :ec 3 :el 5} "  ")

  )

(defn tests/find-expected-expr
  [ti-zloc]
  (def after-zlocs @[])
  (var curr-zloc ti-zloc)
  (var found-comment nil)
  (var found-after nil)
  #
  (while curr-zloc
    (set curr-zloc
         (j/right curr-zloc))
    (when (nil? curr-zloc)
      (break))
    (match (j/node curr-zloc)
      [:comment]
      (do
        (set found-comment true)
        (break))
      #
      [:whitespace]
      (array/push after-zlocs curr-zloc)
      #
      (do
        (set found-after true)
        (array/push after-zlocs curr-zloc)
        (break))))
  #
  (cond
    (or (nil? curr-zloc)
        found-comment)
    :no-expected-expression
    #
    (and found-after
         (match (j/node (first after-zlocs))
           [:whitespace _ "\n"]
           true))
    (if-let [from-next-line (drop 1 after-zlocs)
             next-line (take-until |(match (j/node $)
                                      [:whitespace _ "\n"]
                                      true)
                                   from-next-line)
             target (->> next-line
                         (filter |(match (j/node $)
                                    [:whitespace]
                                    false
                                    #
                                    true))
                         first)]
      target
      :no-expected-expression)
    #
    :unexpected-result))

(comment

  (def src
    ``
    (comment

      (def a 1)

      (put @{} :a 2)
      # =>
      @{:a 2}

      )
    ``)

  (def [ti-zloc _ _]
    (tests/find-test-indicator (-> (lwu/par src)
                             j/zip-down
                             j/down)))

  (j/node ti-zloc)
  # =>
  '(:comment @{:bc 3 :bl 6 :ec 7 :el 6} "# =>")

  (def expected-expr-zloc
    (tests/find-expected-expr ti-zloc))

  (j/node expected-expr-zloc)
  # =>
  '(:table @{:bc 3 :bl 7 :ec 10 :el 7}
           (:keyword @{:bc 5 :bl 7 :ec 7 :el 7} ":a")
           (:whitespace @{:bc 7 :bl 7 :ec 8 :el 7} " ")
           (:number @{:bc 8 :bl 7 :ec 9 :el 7} "2"))

  (-> (j/left expected-expr-zloc)
      j/node)
  # =>
  '(:whitespace @{:bc 1 :bl 7 :ec 3 :el 7} "  ")

  (def src
    ``
    (comment

      (butlast @[:a :b :c])
      # => @[:a :b]

      (butlast [:a])
      # => []

    )
    ``)

  (def [ti-zloc _ _]
    (tests/find-test-indicator (-> (lwu/par src)
                             j/zip-down
                             j/down)))

  (j/node ti-zloc)
  # =>
  '(:comment @{:bc 3 :bl 4 :ec 16 :el 4} "# => @[:a :b]")

  (tests/find-expected-expr ti-zloc)
  # =>
  :no-expected-expression

  )

(defn tests/find-test-exprs
  [ti-zloc]
  # look for a test expression
  (def test-expr-zloc
    (tests/find-test-expr ti-zloc))
  (case test-expr-zloc
    :no-test-expression
    (break [nil nil])
    #
    :unexpected-result
    (errorf "unexpected result from `find-test-expr`: %p"
            test-expr-zloc))
  # look for an expected value expression
  (def expected-expr-zloc
    (tests/find-expected-expr ti-zloc))
  (case expected-expr-zloc
    :no-expected-expression
    (break [test-expr-zloc nil])
    #
    :unexpected-result
    (errorf "unexpected result from `find-expected-expr`: %p"
            expected-expr-zloc))
  #
  [test-expr-zloc expected-expr-zloc])

(defn tests/extract-tests-from-comment-zloc
  [comment-zloc]
  # move into comment block
  (var curr-zloc (j/down comment-zloc))
  (def tests @[])
  # process comment block content
  (while (not (j/end? curr-zloc))
    (def [ti-zloc label-left label-right]
      (tests/find-test-indicator curr-zloc))
    (unless ti-zloc
      (break))
    (def [test-expr-zloc expected-expr-zloc]
      (tests/find-test-exprs ti-zloc))
    # found a complete test
    (if (and test-expr-zloc
             expected-expr-zloc)
      (do
        (array/push tests [test-expr-zloc
                           expected-expr-zloc])
        (set curr-zloc
             (j/right expected-expr-zloc)))
      (set curr-zloc
           (j/right curr-zloc))))
  #
  tests)

(comment

  (def src
    ``
    (comment

      (def a 1)

      (put @{} :a 2)
      # left =>
      @{:a 2}

      (+ 1 1)
      # => right
      2

      )
    ``)

  (def tests
    (-> (lwu/par src)
        j/zip-down
        tests/extract-tests-from-comment-zloc))

  (lwu/gen (j/node (get-in tests [0 0])))
  # =>
  "(put @{} :a 2)"

  (lwu/gen (j/node (get-in tests [0 1])))
  # =>
  "@{:a 2}"

  (lwu/gen (j/node (get-in tests [1 0])))
  # =>
  "(+ 1 1)"

  (lwu/gen (j/node (get-in tests [1 1])))
  # =>
  "2"

  )

(defn tests/extract-test-zlocs
  [src]
  (var tests @[])
  (var curr-zloc
    (-> (lwu/par src)
        j/zip-down
        # XXX: leading newline is a hack to prevent very first thing
        #      from being a comment block
        (j/insert-left [:whitespace @{} "\n"])
        # XXX: once the newline is inserted, need to move to it
        j/left))
  #
  (while (not (j/end? curr-zloc))
    # try to find a top-level comment block
    (if-let [comment-zloc
             (j/right-until curr-zloc
                            |(match (j/node $)
                               [:tuple _ [:symbol _ "comment"]]
                               true))]
      (do
        (let [results (tests/extract-tests-from-comment-zloc comment-zloc)]
          (unless (empty? results)
            (array/push tests ;results))
          (set curr-zloc comment-zloc)))
      (break)))
  #
  tests)

(comment

  (def src
    ``
    (comment

      (def a 1)

      (put @{}
           :a 2)
      # left =>
      @{:a 2}

      (+ 1 1)
      # => right
      2

      )

    (comment

      (string/slice "hallo" 1)
      # =>
      "allo"

      )
    ``)

  (def test-zlocs
    (tests/extract-test-zlocs src))

  # XXX: the indentation for all lines after the first one is off by 2
  #      because all lines are indented by 2 within the comment form.
  #      the first part of the test (on the first line) is not
  #      indented because the first non-whitespace character is
  #      what is identified as the starting position
  (lwu/gen (j/node (get-in test-zlocs [0 0])))
  # =>
  ``
  (put @{}
         :a 2)
  ``

  (lwu/gen (j/node (get-in test-zlocs [0 1])))
  # =>
  "@{:a 2}"

  (lwu/gen (j/node (get-in test-zlocs [2 0])))
  # =>
  "(string/slice \"hallo\" 1)"

  (lwu/gen (j/node (get-in test-zlocs [2 1])))
  # =>
  "\"allo\""

  )

# XXX: not perfect, but mostly ok?
(defn tests/get-indentation
  [a-zloc]
  (when-let [left-zloc (j/left a-zloc)]
    (let [[the-type _ content] (j/node left-zloc)]
      (when (= :whitespace the-type)
        # found indentation
        (when (empty? (string/trim content))
          # early return
          (break content)))))
  # no indentation
  "")

(comment

  (def src
    ``
    (comment

      (def a 1)

      (put @{} :a 2)
      # =>
      @{:a 2}

      )
    ``)

  (def [ti-zloc _ _]
    (tests/find-test-indicator (-> (lwu/par src)
                             j/zip-down
                             j/down)))

  (tests/get-indentation (tests/find-test-expr ti-zloc))
  # =>
  "  "

  )

(defn tests/indent-node-gen
  [a-zloc]
  (string (tests/get-indentation a-zloc) (lwu/gen (j/node a-zloc))))

(defn tests/extract-tests
  [src]
  (def test-zlocs
    (tests/extract-test-zlocs src))
  (map |(let [[t-zloc e-zloc] $]
          [(tests/indent-node-gen t-zloc)
           (tests/indent-node-gen e-zloc)])
       test-zlocs))

# only operate on first comment form
(defn tests/extract-first-test-set-zlocs
  [src]
  (var tests @[])
  (var curr-zloc
    (-> (lwu/par src)
        j/zip-down
        # XXX: leading newline is a hack to prevent very first thing
        #      from being a comment block
        (j/insert-left [:whitespace @{} "\n"])
        # XXX: once the newline is inserted, need to move to it
        j/left))
  #
  (while (not (j/end? curr-zloc))
    # try to find a top-level comment block
    (if-let [comment-zloc
             (j/right-until curr-zloc
                            |(match (j/node $)
                               [:tuple _ [:symbol _ "comment"]]
                               true))]
      (do
        (let [results (tests/extract-tests-from-comment-zloc comment-zloc)]
          (unless (empty? results)
            (array/push tests ;results))
          (break)))
      (break)))
  #
  tests)

# only operate on first comment form
(defn tests/extract-first-test-set
  [src]
  (def test-zlocs
    (tests/extract-first-test-set-zlocs src))
  (map |(let [[t-zloc e-zloc] $]
          [(tests/indent-node-gen t-zloc)
           (tests/indent-node-gen e-zloc)])
       test-zlocs))



########################################################################

(defn qu/deprintf
  [fmt & args]
  (when (os/getenv "JREF_VERBOSE")
    (eprintf fmt ;args)))

# outline
#
# * (rewrite-test test-zloc)
#   * (find-things test-zloc)
#     * (rnd/choose things)
#       * (blank-thing thing-zloc)

# XXX: make what types of things to find configurable?
(defn qu/find-things
  [test-zloc]
  (def results @[])
  # compare against this to determine whether still a descendant
  (def test-path-len
    (length (j/path test-zloc)))
  (var curr-zloc test-zloc)
  (while (not (j/end? curr-zloc))
    (match (j/node curr-zloc)
      [:symbol]
      (array/push results curr-zloc)
      [:number]
      (array/push results curr-zloc)
      [:keyword]
      (array/push results curr-zloc)
      [:constant]
      (array/push results curr-zloc)
      [:string]
      (array/push results curr-zloc)
      [:long-string]
      (array/push results curr-zloc))
    (set curr-zloc
         (j/df-next curr-zloc))
    # XXX: not 100% sure whether this is something that can be relied on
    (when (or (j/end? curr-zloc)
              # no longer a descendant of test-zloc
              # XXX: verify relying on this is solid
              (<= (length (j/path curr-zloc))
                  test-path-len))
      (break)))
  #
  results)

(comment

  (def src
    ``
    ~(sequence "#"
               (capture (to "=>"))
               "=>"
               (capture (thru -1)))
    ``)

  (map |(j/node $)
       (qu/find-things (-> (lwu/par src)
                        j/zip-down)))
  # =>
  '@[(:symbol @{:bc 3 :bl 1 :ec 11 :el 1} "sequence")
     (:string @{:bc 12 :bl 1 :ec 15 :el 1} "\"#\"")
     (:symbol @{:bc 13 :bl 2 :ec 20 :el 2} "capture")
     (:symbol @{:bc 22 :bl 2 :ec 24 :el 2} "to")
     (:string @{:bc 25 :bl 2 :ec 29 :el 2} "\"=>\"")
     (:string @{:bc 12 :bl 3 :ec 16 :el 3} "\"=>\"")
     (:symbol @{:bc 13 :bl 4 :ec 20 :el 4} "capture")
     (:symbol @{:bc 22 :bl 4 :ec 26 :el 4} "thru")
     (:number @{:bc 27 :bl 4 :ec 29 :el 4} "-1")]

  )

(defn qu/blank-thing
  [thing-zloc blank-char-str]
  (def node-type
    (get (j/node thing-zloc) 0))
  (var blanked-item nil)
  (var new-thing-zloc nil)
  (cond
    (or (= :symbol node-type)
        (= :constant node-type)
        (= :number node-type)
        (= :string node-type)
        (= :long-string node-type)
        (= :keyword node-type))
    (set new-thing-zloc
         (j/edit thing-zloc
                 |(let [original-item (get $ 2)]
                    (set blanked-item original-item)
                    [node-type
                     (get $ 1)
                     (string/repeat blank-char-str
                                    (length original-item))])))
    #
    (do
      (eprintf "Unexpected node-type: %s" node-type)
      (set new-thing-zloc thing-zloc)))
  [new-thing-zloc blanked-item])

(comment

  (def src
    ``
    ~(sequence "#"
               (capture (to "=>"))
               "=>"
               (capture (thru -1)))
    ``)

  (def thing-zloc
    (first (qu/find-things (-> (lwu/par src)
                            j/zip-down))))

  (def blank-char-str "_")

  (def [new-thing blanked-item]
    (qu/blank-thing thing-zloc blank-char-str))

  (j/node new-thing)
  # =>
  [:symbol @{:bc 3 :bl 1 :ec 11 :el 1} "________"]

  blanked-item
  # =>
  "sequence"

  (->> (qu/blank-thing thing-zloc blank-char-str)
       first
       j/root
       lwu/gen)
  # =>
  ``
  ~(________ "#"
             (capture (to "=>"))
             "=>"
             (capture (thru -1)))
  ``

  )

(defn qu/rewrite-test-zloc
  [test-zloc]
  (qu/deprintf "test:")
  (qu/deprintf (lwu/gen (j/node test-zloc)))
  # find how many "steps" back are needed to "get back" to original spot
  (var steps 0)
  (var chosen-thing-zloc nil)
  (def test-node-type
    (get (j/node test-zloc) 0))
  # might change depending on what symbols the test has in it
  (var blank-char-str "_")
  (cond
    (or (= :string test-node-type)
        (= :long-string test-node-type)
        (= :keyword test-node-type)
        (= :constant test-node-type)
        (= :number test-node-type))
    (do
      (qu/deprintf "test was a %s" test-node-type)
      (set chosen-thing-zloc test-zloc))
    #
    (get {:tuple true
          :bracket-tuple true
          :quote true
          :quasiquote true
          :splice true
          :struct true
          :table true} test-node-type)
    (let [things (qu/find-things test-zloc)]
      # XXX
      (qu/deprintf "test was a %s" test-node-type)
      # XXX
      (qu/deprintf "Number of things found: %d" (length things))
      (when (empty? things)
        # XXX
        (eprint "Failed to find a thing")
        (break [nil nil]))
      # learn the names used to choose good blanking char
      (def names @{})
      (each thng things
        (def a-node
          (j/node thng))
        (def [a-type _ a-name] a-node)
        (when (= :symbol a-type)
          (put names (get thng 2) true))
        (qu/deprintf (lwu/gen a-node)))
      # if necessary, try to find a non-problematic char
      (when (get names blank-char-str)
        (each cand-char-str ["?" "-" "~"]
          (when (not (get names cand-char-str))
            (set blank-char-str cand-char-str)
            (break))))
        (set chosen-thing-zloc
           (rnd/choose things))
      (qu/deprintf "chosen: %s" (lwu/gen (j/node chosen-thing-zloc))))
    #
    (do
      (eprint "Unexpected node-type:" test-node-type)
      (break [nil nil])))
  # find how many steps away we are from test-zloc's node
  (var curr-zloc chosen-thing-zloc)
  # XXX: compare (attrs ...) results instead of gen / node
  (def test-str
    (lwu/gen (j/node test-zloc)))
  (while curr-zloc
    # XXX: expensive?
    # XXX: compare (attrs ...) results instead -- should be faster
    #      attrs should be unique inside the tree(?)
    (when (= (lwu/gen (j/node curr-zloc))
             test-str)
      (break))
    (set curr-zloc
         (j/df-prev curr-zloc))
    (++ steps))
  # XXX
  (qu/deprintf "steps: %d" steps)
  # XXX: check not nil?
  (var [curr-zloc blanked-item]
    (-> chosen-thing-zloc
        (qu/blank-thing blank-char-str)))
  # get back to "test-zloc" position
  (for i 0 steps
    (set curr-zloc
         (j/df-prev curr-zloc)))
  # XXX
  #(deprintf "curr-zloc: %M" curr-zloc)
  #
  [curr-zloc blanked-item blank-char-str])

(defn qu/rewrite-test
  [test-zloc]
  (when-let [[rewritten-zloc blanked-item blank-char-str]
             (qu/rewrite-test-zloc test-zloc)]
    [(->> rewritten-zloc
         j/root
         lwu/gen)
     blanked-item
     blank-char-str]))

(comment

  (def src
    ``
    (peg/match ~(error "a")
               "a")
    ``)

  (def [result blanked-item blank-char-str]
    (qu/rewrite-test (->> (lwu/par src)
                       j/zip-down)))

  (or (= "peg/match" blanked-item)
      (= "error" blanked-item)
      (= "\"a\"" blanked-item))
  # =>
  true

  (or (= result
         ``
         (_________ ~(error "a")
                    "a")
         ``)
      (= result
         ``
         (peg/match ~(_____ "a")
                    "a")
         ``)
      (= result
         ``
         (peg/match ~(error ___)
                    "a")
         ``)
      (= result
         ``
         (peg/match ~(error "a")
                    ___)
         ``))
  # =>
  true

  )

########################################################################

(defn qu/handle-eval-failure
  [resp e]
  (print "Sorry, failed to evaluate your answer.")
  (print)
  (print "The error I got was:")
  (print)
  (printf "%p" e)
  (print)
  (print "I tried to evaluate the following:")
  (print)
  (print resp))

(defn qu/handle-eval-comparison
  [prog-ans user-ans]
  (if (deep= prog-ans user-ans)
    (do
      (print "Nice, our answers both evaluate to:")
      (print)
      (pr/print-nicely (string/format "%m" prog-ans))
      true)
    (do
      (printf "Sorry, our answers evaluate differently.")
      (print)
      (print "My answer evaluates to:")
      (print)
      (pr/print-nicely (string/format "%m" prog-ans))
      (print)
      (print "Your answer evaluates to:")
      (print)
      (pr/print-nicely (string/format "%m" user-ans))
      false)))

(defn qu/handle-plain-response
  [ans resp]
  (print "My answer is:")
  (print)
  (pr/print-nicely ans)
  (print)
  (print "Your answer is:")
  (print)
  (pr/print-nicely resp)
  (print)
  (when (deep= ans resp)
    (print "Yay, the answers agree :)")
    (break true))
  (print "Our answers differ, but perhaps yours works too.")
  (print)
  (try
    (let [evaled-ans (eval-string ans)
          result (eval-string resp)]
      (qu/handle-eval-comparison evaled-ans result))
    ([e]
      (qu/handle-eval-failure resp e)
      false)))

(defn qu/handle-want-to-quit
  [buf]
  (when (empty? (string/trim buf))
    (print "Had enough?  Perhaps on another occasion then.")
    #
    true))

(defn qu/validate-response
  [buf]
  (try
    (do
      (parse buf)
      (string/trim buf))
    ([e]
      (print)
      (printf "Sorry, I didn't understand your response: %s"
              (string/trim buf))
      (print)
      (print "I got the following error:")
      (print)
      (printf "%p" e)
      nil)))

(defn qu/thing-plain-quiz
  [content]
  # extract first set of tests from content
  (def tests
    (tests/extract-first-test-set content))
  (when (empty? tests)
    (print "Sorry, didn't find any material to make a quiz from.")
    (break nil))
  # choose a question and answer pair
  (let [[ques ans] (rnd/choose tests)
        trimmed-ans (string/trim ans)]
    (print "# What does the following evaluate to?")
    (print)
    # show the question
    (pr/print-nicely ques)
    (print "# =>")
    # ask for an answer
    (def buf
      (getline ""))
    (when (qu/handle-want-to-quit buf)
      (break nil))
    # does the response make some sense?
    (def resp
      (qu/validate-response buf))
    (unless resp
      (break nil))
    # improve perceptibility
    (print)
    (pr/print-separator)
    (print)
    #
    (qu/handle-plain-response trimmed-ans resp)))

(defn qu/handle-fill-in-response
  [ques blank-ques blanked-item blank-char-str ans resp]
  (print "One complete picture is: ")
  (print)
  (pr/print-nicely ques)
  (print "# =>")
  (pr/print-nicely ans)
  (print)
  (print "So one value that works is:")
  (print)
  (pr/print-nicely blanked-item)
  (print)
  (print "Your answer is:")
  (print)
  (pr/print-nicely resp)
  (print)
  (when (deep= blanked-item resp)
    (print "Yay, the answers agree :)")
    (break true))
  (print "Our answers differ, but perhaps yours works too.")
  (print)
  # eval both sets of code and compare results
  (let [indeces (string/find-all blank-char-str blank-ques)
        head-idx (first indeces)
        tail-idx (last indeces)]
    (def resp-code
      (string (string/slice blank-ques 0 head-idx)
              resp
              (string/slice blank-ques (inc tail-idx))))
    (try
      (let [evaled-ans (eval-string ans)
            result (eval-string resp-code)]
        (qu/handle-eval-comparison evaled-ans result))
      ([e]
        (qu/handle-eval-failure resp-code e)
        false))))

(defn qu/thing-fill-in-quiz
  [content]
  # extract first set of tests from content
  (def test-zloc-pairs
    (tests/extract-first-test-set-zlocs content))
  (when (empty? test-zloc-pairs)
    (print "Sorry, didn't find any material to make a quiz from.")
    (break nil))
  # choose a question and answer, then make a blanked question
  (let [[ques-zloc ans-zloc]
        (rnd/choose test-zloc-pairs)
        [blank-ques-zloc blanked-item blank-char-str]
        (qu/rewrite-test-zloc ques-zloc)]
    # XXX: a cheap work-around...evidence of a deeper issue?
    (unless blank-ques-zloc
      (print "Sorry, drew a blank...take a deep breath and try again?")
      (break nil))
    (let [ques (tests/indent-node-gen ques-zloc)
          blank-ques (tests/indent-node-gen blank-ques-zloc)
          trimmed-ans (string/trim (tests/indent-node-gen ans-zloc))]
      # show the question
      (pr/print-nicely blank-ques)
      (print "# =>")
      (pr/print-nicely trimmed-ans)
      (print)
      # ask for an answer
      (def buf
        (getline (string/format "What value could work for the `%s`s ? "
                                blank-char-str)))
      (when (qu/handle-want-to-quit buf)
        (break nil))
      # does the response make some sense?
      (def resp
        (qu/validate-response buf))
      (unless resp
        (break nil))
      # improve perceptibility
      (print)
      (pr/print-separator)
      (print)
      #
      (qu/handle-fill-in-response ques blank-ques blanked-item blank-char-str
                               trimmed-ans resp))))

(defn qu/thing-quiz
  [content]
  (def quiz-fn
    (rnd/choose [qu/thing-plain-quiz
                 qu/thing-fill-in-quiz]))
  (quiz-fn content))


(comment import ./src :prefix "")
(comment import ./etags :prefix "")
# TAGS (emacs tags file format)

```

path,line

path,line
search-string,idline,offset-from-start
...
search-string,idline,offset-from-start

```

```
 - 0x01
 - 0x0c
 - 0x7f
```

# SOH - start of heading
(def etags/start-of-heading
  (string/from-bytes 0x01))

# FF - form feed
(def etags/form-feed
  (string/from-bytes 0x0C))

# DEL - delete
(def etags/delete
  (string/from-bytes 0x7F))

(def etags/etags-grammar
  ~{:main (sequence (any (sequence :section-sep :section)) -1)
    :section-sep (sequence ,etags/form-feed :eol)
    :section (cmt (sequence :file-line (any :tag-line))
                  ,(fn [path & rest]
                     (merge ;(keep (fn [m]
                                     # each m has only one key, the id
                                     (when-let [id (first (keys m))
                                                val (get m id)]
                                       (put m
                                            id (array/push val path))))
                                   rest))))
    :file-line (sequence (capture :path) "," :d+ :eol)
    # \r, \n are here to bound the matching to the current line
    :path (some (if-not (set ",\r\n") 1))
    :tag-line (cmt (sequence (capture :search-str)
                             :tag-line-sep-1
                             (capture :id)
                             :tag-line-sep-2
                             (number :d+)
                             ","
                             (opt (number :d+))
                             :eol)
                   # slightly complicated because offset is now optional
                   ,(fn [& caps]
                      @{(get caps 1)
                        @[;(array/slice caps 2) (get caps 0)]}))
    # \r, \n are here to bound the matching to the current line
    :search-str (some (if-not (choice :tag-line-sep-1 :eol) 1))
    # \r, \n are here to bound the matching to the current line
    :id (some (if-not (choice :tag-line-sep-2 :eol) 1))
    :eol (choice "\r\n" "\r" "\n")
    :tag-line-sep-1 ,etags/delete
    :tag-line-sep-2 ,etags/start-of-heading})

(comment

  (def etags
    ```
    
    src/core/pp.c,0
    
    src/core/tuple.c,275
    JANET_CORE_FN(cfun_tuple_brackets,tuple/brackets58,2136
    JANET_CORE_FN(cfun_tuple_slice,tuple/slice66,2433
    JANET_CORE_FN(cfun_tuple_type,tuple/type80,3259
    JANET_CORE_FN(cfun_tuple_sourcemap,tuple/sourcemap96,3928
    JANET_CORE_FN(cfun_tuple_setmap,tuple/setmap108,4432
    
    src/core/regalloc.c,0
    
    src/core/specials.c,0

    ```)

  (peg/match etags/etags-grammar etags)
  # =>
  '@[@{}
     @{"tuple/brackets"
       @[58 2136 "JANET_CORE_FN(cfun_tuple_brackets," "src/core/tuple.c"]
       "tuple/setmap"
       @[108 4432 "JANET_CORE_FN(cfun_tuple_setmap," "src/core/tuple.c"]
       "tuple/slice"
       @[66 2433 "JANET_CORE_FN(cfun_tuple_slice," "src/core/tuple.c"]
       "tuple/sourcemap"
       @[96 3928 "JANET_CORE_FN(cfun_tuple_sourcemap," "src/core/tuple.c"]
       "tuple/type"
       @[80 3259 "JANET_CORE_FN(cfun_tuple_type," "src/core/tuple.c"]}
     @{}
     @{}]

  (def etags
    ```
    
    src/core/pp.c,0
    
    src/core/tuple.c,259
    JANET_CORE_FN(cfun_tuple_brackets,tuple/brackets58,
    JANET_CORE_FN(cfun_tuple_slice,tuple/slice66,
    JANET_CORE_FN(cfun_tuple_type,tuple/type80,
    JANET_CORE_FN(cfun_tuple_sourcemap,tuple/sourcemap96,
    JANET_CORE_FN(cfun_tuple_setmap,tuple/setmap108,
    
    src/core/regalloc.c,0
    
    src/core/specials.c,0

    ```)

  (peg/match etags/etags-grammar etags)
  # =>
  '@[@{}
     @{"tuple/brackets"
       @[58 "JANET_CORE_FN(cfun_tuple_brackets," "src/core/tuple.c"]
       "tuple/setmap"
       @[108 "JANET_CORE_FN(cfun_tuple_setmap," "src/core/tuple.c"]
       "tuple/slice"
       @[66 "JANET_CORE_FN(cfun_tuple_slice," "src/core/tuple.c"]
       "tuple/sourcemap"
       @[96 "JANET_CORE_FN(cfun_tuple_sourcemap," "src/core/tuple.c"]
       "tuple/type"
       @[80 "JANET_CORE_FN(cfun_tuple_type," "src/core/tuple.c"]}
     @{}
     @{}]

  )


(defn src/open-editor-at
  [line full-path]
  (unless (dyn :jref-editor)
    (eprintf "Please specify an editor via JREF_EDITOR")
    (break nil))
  #
  (def editor-filename
    (if-let [editor-filename (dyn :jref-editor-filename)]
      editor-filename
      (if (= :windows (os/which))
        (string (dyn :jref-editor) ".exe")
        (dyn :jref-editor))))
  (def open-at-format
    (dyn :jref-editor-open-at-format))
  (def oaf-len
    (length open-at-format))
  (cond
    # sublimetext uses: path:line
    (= 1 oaf-len)
    (do
      (def open-at-arg
        (string/format ;open-at-format full-path line))
      #
      (os/execute [editor-filename open-at-arg]
                  :p))
    # emacs, kak, nvim, neovim use: +line path
    (= 2 oaf-len)
    (do
      (def [line-fmt path-fmt]
        (dyn :jref-editor-open-at-format))
      (def line-arg
        (string/format line-fmt line))
      (def path-arg
        (string/format path-fmt full-path))
      #
      (os/execute [editor-filename
                   line-arg path-arg]
                  :p))
    #
    (eprintf "Don't know how to handle an open at format with %d parts"
             oaf-len)))

(defn src/definition
  [id-name etags-content j-src-path]
  (def etags-table
    (merge ;(peg/match etags/etags-grammar etags-content)))

  (def result (etags-table id-name))

  (unless result
    (eprintf "Failed to find id: %s" id-name)
    (break nil))

  (def line (first result))

  (def src-path (last result))

  (def full-path
    (string j-src-path "/" src-path))

  (when (not (os/stat full-path))
    (eprintf "Failed to find file: %s" full-path)
    (break nil))

  (src/open-editor-at line full-path)

  true)


(comment import ./things :prefix "")
(comment import ./print :prefix "")

(comment import ./random :prefix "")

(comment import ./tests :prefix "")

(comment import ./usages :prefix "")
(def usages/things
  @{
"++"
````````
(comment

  (do
    (var i 0)
    (++ i)
    i)
  # =>
  1

  (do
    (var i -1)
    (++ i))
  # =>
  0

  (do
    (var i math/inf)
    (++ i))
  # =>
  math/inf

  (do
    (var i math/-inf)
    (++ i))
  # =>
  math/-inf

  (do
    (var i math/nan)
    (++ i)
    (nan? i))
  # =>
  true

  )
````````
"+"
````````
(comment

  (+ 1 2)
  # =>
  3

  (+ 10)
  # =>
  10

  (+)
  # =>
  0

  (+ 1.4 -4.5)
  # =>
  -3.1

  (+ 1 2 3 4 5 6 7 8 9 10)
  # =>
  55

  (+ ;(range 101))
  # =>
  5050

  (= (+ (int/s64 "10") 10)
     20:s)
  # =>
  true

  (def [ok? value] (protect (+ nil 10)))
  # =>
  [false "could not find method :+ for nil"]

  )
````````
"+="
````````
(comment

  (do
    (var i 0)
    (+= i 2)
    i)
  # =>
  2

  (do
    (var i 1)
    (+= i -1)
    i)
  # =>
  0

  (do
    (var j 0)
    (+= j math/nan)
    (nan? j))
  # =>
  true

  (do
    (var k 0)
    (+= k math/inf)
    k)
  # =>
  math/inf

  )
````````
"--"
````````
(comment

  (do
    (var i 0)
    (-- i)
    i)
  # =>
  -1

  (do
    (var i 1)
    (-- i))
  # =>
  0

  (do
    (var i math/inf)
    (-- i))
  # =>
  math/inf

  (do
    (var i math/-inf)
    (-- i))
  # =>
  math/-inf

  (do
    (var i math/nan)
    (-- i)
    (nan? i))
  # =>
  true

  )
````````
"-"
````````
(comment

  (- 1 2)
  # =>
  -1

  (- 10)
  # =>
  -10

  (-)
  # =>
  0

  (- 1.4 -4.5)
  # =>
  5.9

  (- 1 2 3 4 5 6 7 8 9 10)
  # =>
  -53

  (= (- (int/s64 "10") 10)
     0:s)
  # =>
  true

  )
````````
"-="
````````
(comment

  (do
    (var i 3)
    (-= i 2)
    i)
  # =>
  1

  (do
    (var i 1)
    (-= i -1)
    i)
  # =>
  2

  (do
    (var j 0)
    (-= j math/nan)
    (nan? j))
  # =>
  true

  (do
    (var k 0)
    (-= k math/inf)
    k)
  # =>
  math/-inf

  )
````````
"_all-the-things"
````````
#
# Special Forms
#   (break value?)
#   (def name meta... value)
#   (do body...)
#   (fn name? args body...)
#   (if condition when-true when-false?)
#   (quasiquote x)
#   (quote x)
#   (set l-value r-value)
#   (splice x)
#   (unquote x)
#   (upscope & body)
#   (var name meta... value)
#   (while condition body...)
#
# Functions
#   %
#   *
#   +
#   -
#   /
#   accumulate
#   accumulate2
#   all
#   apply
#   array?
#   array/concat
#   asm
#   boolean?
#   buffer?
#   bytes?
#   cfunction?
#   comp
#   compare
#   complement
#   count
#   dec
#   dictionary?
#   drop
#   drop-until
#   drop-while
#   empty?
#   eval-string
#   eval
#   even?
#   extreme
#   fiber?
#   filter
#   find
#   find-index
#   first
#   function?
#   has-key?
#   has-value?
#   identity
#   inc
#   index-of
#   indexed?
#   interpose
#   juxt*
#   keep
#   keyword?
#   last
#   map
#   mapcat
#   max
#   max-of
#   mean
#   min
#   min-of
#   nan?
#   neg?
#   number?
#   odd?
#   one?
#   os/strftime
#   pos?
#   product
#   range
#   reduce
#   reverse
#   slice
#   some
#   sort
#   sort-by
#   sorted
#   string/split
#   string/trim
#   string/triml
#   string/trimr
#   string?
#   struct?
#   sum
#   symbol?
#   table?
#   take
#   take-until
#   take-while
#   tuple?
#   type
#   zero?
#
# Macros
#   %=
#   *=
#   ++
#   +=
#   --
#   -=
#   /=
#   and
#   assert
#   case
#   chr
#   comment
#   cond
#   coro
#   default
#   defdyn
#   defer
#   defn
#   each
#   eachk
#   eachp
#   edefer
#   errorf
#   for
#   forever
#   forv
#   generate
#   if-let
#   if-not
#   if-with
#   juxt
#   label
#   let
#   loop
#   or
#   prompt
#   protect
#   repeat
#   return
#   seq
#   short-fn
#   tabseq
#   toggle
#   try
#   unless
#   when
#   when-let
#   when-with
#   with
#   with-syms
#
# Variables
#   default-peg-grammar
#
# Dynamic Variables
#   *out*
````````
"*"
````````
(comment

  (* 10 20)
  # =>
  200

  (* 10)
  # =>
  10

  (*)
  # =>
  1

  (* 1 2 3 4 5 6 7)
  # =>
  5040

  (* ;(range 1 20))
  # =>
  1.21645100408832e+17

  )
````````
"*="
````````
(comment

  (do
    (var i 0.5)
    (*= i 2)
    i)
  # =>
  1

  (do
    (var i 1)
    (*= i -1)
    i)
  # =>
  -1

  (do
    (var j 0)
    (*= j math/nan)
    (nan? j))
  # =>
  true

  (do
    (var k 0)
    (*= k math/inf)
    (nan? k))
  # =>
  true

  )
````````
"*out*"
````````
(comment

  (do
    (def buf @"")
    (with-dyns [*out* buf]
      (print "greetings"))
    buf)
  # =>
  @"greetings\n"

  (do
    (def buf @"")
    (with-dyns [*out* buf]
      (prin "not quote done"))
    buf)
  # =>
  @"not quote done"

  (do
    (def buf @"")
    (with-dyns [*out* buf]
      (printf "...and then %s" `another`))
    buf)
  # =>
  @"...and then another\n"

  (do
    (def buf @"")
    (with-dyns [*out* buf]
      (prinf "hello %s" `dave`))
    buf)
  # =>
  @"hello dave"

  )
````````
"%"
````````
(comment

  (% 10 3)
  # =>
  1
  
  (% -10 3)
  # =>
  -1
  
  (% 10 -3)
  # =>
  1
  
  (% -10 -3)
  # =>
  -1
  
  (= (% 1.4 1) 
     (- 1.4 1))
  # =>
  true
  
  (= (% -1.4 1)
     (+ -1.4 1))
  # =>
  true
  
  (= (% 1.4 -1)
     (- 1.4 1))
  # =>
  true
  
  (= (% -1.4 -1)
     (+ -1.4 1))
  # =>
  true
  
  (nan? (% 1.4 0))
  # =>
  true
  
  (nan? (% -1.4 0))
  # =>
  true
  
  )
````````
"%="
````````
(comment

  (do
    (var i 3)
    (%= i 2)
    i)
  # =>
  1

  (do
    (var i 17)
    (%= i -7)
    i)
  # =>
  3

  (do
    (var j 1024)
    (%= j math/nan)
    (nan? j))
  # =>
  true

  (do
    (var k 2048)
    (%= k math/inf)
    k)
  # =>
  2048

  )
````````
"/"
````````
(comment

  (/ 10 5)
  # =>
  2

  (/ 10)
  # =>
  0.1

  (/)
  # =>
  1

  (/ 10 5 4)
  # =>
  0.5

  (/ 10 5 4 5)
  # =>
  0.1

  # More arguments is the same as repeated division.
  (= (/ ;(range 1 20))
     (/ 1 2 3 4 5 6 7 8 9 10
        11 12 13 14 15 16 17 18 19))
  # =>
  true

  )
````````
"/="
````````
(comment

  (do
    (var i 1)
    (/= i 2)
    i)
  # =>
  0.5

  (do
    (var i 1)
    (/= i -1)
    i)
  # =>
  -1

  (do
    (var j 0)
    (/= j math/nan)
    (nan? j))
  # =>
  true

  (do
    (var k 0)
    (/= k math/inf)
    k)
  # =>
  0

  )
````````
"accumulate"
````````
(comment

  (accumulate + 0 [1 2 3])
  # =>
  @[1 3 6]

  (accumulate (fn [x y]
                (if (not (empty? x))
                  (string x ", " y)
                  y))
              ""
              [:ant :bee :cheetah])
  # =>
  @[:ant "ant, bee" "ant, bee, cheetah"]

  (accumulate nil nil [])
  # =>
  @[]

  (accumulate nil :garuda [])
  # =>
  @[]

  )
````````
"accumulate2"
````````
(comment

  (accumulate2 + [1 2 3 4])
  # =>
  @[1 3 6 10]

  (accumulate2 + [])
  # =>
  @[]

  (accumulate2 max [1 4 2 3 9 5])
  # =>
  @[1 4 4 4 9 9]

  )
````````
"all"
````````
(comment

  (all pos? [1 2 3])
  # =>
  true

  (all (fn [x y] (pos? (* x y))) 
       [-1 2] [-2 1])
  # =>
  true

  (all |(neg? (+ $0 $1 $2)) 
       [-2 2] [1 -8] [0 1 43])
  # =>
  true

  (all pos? [1 2 -3])
  # =>
  false

  (all pos? [])
  # =>
  true

  (all neg? [])
  # =>
  true

  (all truthy? [1 2 3])
  # =>
  true

  (all truthy? [1 2 nil])
  # =>
  false

  )
````````
"and"
````````
(comment

  (and)
  # =>
  true

  (and 1)
  # =>
  1

  (and 1 nil)
  # =>
  nil

  (and 1 (/ 2 1) false)
  # =>
  false

  (and :fun :play (not true) :dance)
  # =>
  false

  )
````````
"apply"
````````
(comment

  (apply + (range 10))
  # =>
  45

  (apply + [])
  # =>
  0

  (apply + 1 2 3 4 5 6 7 [8 9 10])
  # =>
  55

  (def [ok? value] (protect (apply + 1 2 3 4 5 6 7 8 9 10)))
  # =>
  [false "expected array or tuple, got 10"]

  (let [mx (apply for 'x 0 10 ['(print x)])]
    (and (= (length mx) 4)
         (= (get mx 0) 'do)
         (= (get-in mx [1 0]) 'var)
         (= (get-in mx [2 0]) 'def)
         (= (get-in mx [3 0]) 'while)))
  # =>
  true

  )
````````
"array?"
````````
(comment

  (array? @[:a :b])
  # =>
  true

  (array? @(:x :y :z))
  # =>
  true

  (array? (accumulate + 0 [0 1 2]))
  # =>
  true

  (array? (accumulate2 + [0 1 2]))
  # =>
  true

  (array? (debug/arg-stack (fiber/current)))
  # =>
  true

  (array? (debug/lineage (fiber/root)))
  # =>
  true

  (array? (debug/stack (fiber/current)))
  # =>
  true

  (array? (disasm (fn [] :dolphin) :bytecode))
  # =>
  true

  (array? (disasm (fn [] :dolphin) :constants))
  # =>
  true

  (array? (distinct [1 1 2 2]))
  # =>
  true

  (array? (ev/gather (coro 1) (coro 2)))
  # =>
  true

  (array? (filter odd? [-1 0 1]))
  # =>
  true

  (array? (flatten [:x [:y {:z 1}]]))
  # =>
  true

  (array? (flatten-into @[] [:x [:y {:z 1}]]))
  # =>
  true

  (array? (interleave [1 2 3] [:one :two :three]))
  # =>
  true

  (array? (interpose "," [:a :b :c]))
  # =>
  true

  (array? (keep |(when (odd? $)
                   (string $))
                [1 2 3]))
  # =>
  true

  (array? (kvs {:a 1 :b 2}))
  # =>
  true

  (array? (map inc [-2 -1 0]))
  # =>
  true

  (array? (mapcat sum [[1 8] [2 7] [0 9]]))
  # =>
  true

  (array? (os/dir "."))
  # =>
  true

  (array? (partition 2 [0 1 2 3]))
  # =>
  true

  (array? (partition-by even? [0 1 2 3 7 8 9]))
  # =>
  true

  (array? (peg/find-all "a" "abba"))
  # =>
  true

  (array? (peg/match '(sequence (thru ".")) "hello there."))
  # =>
  true

  (array? (peg/match '(sequence (thru ".")) "hello there?"))
  # =>
  false

  (array? (put @[] 0 1))
  # =>
  true

  (array? (put-in @[@[]] [0 0] :treasure))
  # =>
  true

  (array? (range 0 3))
  # =>
  true

  (array? (reverse @[0 1 2]))
  # =>
  true

  (array? (reverse! @[math/pi math/e]))
  # =>
  true

  (array? (seq [i :in [0 1 2]] i))
  # =>
  true

  (array? (sorted @[3 math/pi math/e]))
  # =>
  true

  (array? (sorted-by math/abs @[-2 1 2 -1 0]))
  # =>
  true

  (array? (string/find-all "/" "/usr/local/src"))
  # =>
  true

  (array? (string/split "/" "/usr/local/src"))
  # =>
  true

  (array? (take 2 (coro
                    (yield :alice)
                    (yield :bob))))
  # =>
  true

  (array? (take-until even?
                      (coro
                        (yield 1)
                        (yield 2))))
  # =>
  true

  (array? (take-while even?
                      (coro
                        (yield 2)
                        (yield 8)
                        (yield 9))))
  # =>
  true

  (array? [])
  # =>
  false

  (array? '())
  # =>
  false

  )
````````
"array/concat"
````````
(comment

  (do
    (def arr @[])
    (array/concat arr @[:a])
    arr)
  # =>
  @[:a]

  (do
    (def arr @[])
    (array/concat arr [:a :b])
    arr)
  # =>
  @[:a :b]

  (do
    (def arr @[])
    (array/concat arr :a)
    arr)
  # =>
  @[:a]

  (do
    (def arr @[])
    (array/concat arr :a :b)
    arr)
  # =>
  @[:a :b]

  (do
    (def arr @[])
    (array/concat arr :a @[:x] [:y])
    arr)
  # =>
  @[:a :x :y]

  (do
    (def arr @[])
    (array/concat arr [[:x] :y])
    arr)
  # =>
  @[[:x] :y]

  )
````````
"asm"
````````
(comment

  (do
    (def code
      '{:bytecode @[(ldi 1 0x2)  # $1 = 2
                    (mul 2 0 1)  # $2 = $0 * $1
                    (ret 2)]     # return $2
        :arity 1})               # arg 0 is $0
    (def double
      (asm code))
    (double 3))
  # =>
  6

  (do
    (def code
      '{:bytecode @[(ldi 1 0x1)  # $1 = 1
                    (add 2 0 1)  # $2 = $0 + $1
                    (ret 2)]     # return $2
        :arity 1})               # arg 0 is $0
    (def my-inc
      (asm code))
    (my-inc 7))
  # =>
  8

  (do
    (def code
      # janet/test/suite-asm.janet
      '{:bytecode @[(ltim 1 0 0x2)    # $1 = $0 < 2
                    (jmpif 1 :done)   # if ($1) goto :done
                    (lds 1)           # $1 = self
                    (addim 0 0 -0x1)  # $0 = $0 - 1
                    (push 0)          # push($0), for next func call
                    (call 2 1)        # $2 = call($1)
                    (addim 0 0 -0x1)  # $0 = $0 - 1
                    (push 0)          # push($0)
                    (call 0 1)        # $0 = call($1)
                    (add 0 0 2)       # $0 = $0 + $2
                    :done
                    (ret 0)]          # return $0
        :arity 1})
    (def fib
      (asm code))
    (fib 6))
  # =>
  8

  # add: $dest = $lhs + $rhs
  ((asm '{:bytecode @[(add 2 0 1)  # $2 = $0 + $1
                      (ret 2)]     # return $2
          :arity 2})               # args 0 and 1 are $0 and $1
    1 2)
  # =>
  3

  # addim: $dest = $lhs + im
  ((asm '{:bytecode @[(addim 1 0 0x1)  # $1 = $0 + 1
                      (ret 1)]         # return $1
          :arity 1})                   # arg 0 is $0
    7)
  # =>
  8

  # band: $dest = $lhs & $rhs
  ((asm '{:bytecode @[(band 0 0 1)
                      (ret 0)]
          :arity 2})
    2r101 2r111)
  # =>
  2r101

  # bnot: $dest = ~$operand
  ((asm '{:bytecode @[(bnot 0 0)
                      (ret 0)]
          :arity 1})
    2r101)
  # =>
  (- (inc 2r101))

  # bor: $dest = $lhs | $rhs
  ((asm '{:bytecode @[(bor 0 0 1)
                      (ret 0)]
          :arity 2})
    2r11110000 2r00001111)
  # =>
  2r11111111

  # bxor: $dest = $lhs ^ $rhs
  ((asm '{:bytecode @[(bxor 0 0 1)
                      (ret 0)]
          :arity 2})
    2r00110011 2r00001111)
  # =>
  2r00111100

  # call: $dest = call($callee, args)
  ((asm ~{:constants [,type]
          :bytecode @[(push 0)
                      (ldc 1 0)
                      (call 0 1)
                      (ret 0)]
          :arity 1})
    :smile)
  # =>
  :keyword

  # clo: $dest = closure(defs[$index])
  ((asm ~{:defs @[,(disasm (asm '{:arity 1
                                  :bytecode @[(addim 1 0 0x8)
                                              (ret 1)]}))]
          :bytecode @[(push 0)
                      (clo 0 0)
                      (call 1 0)
                      (ret 1)]
          :arity 1})
    3)
  # =>
  11

  # cmp: $dest = janet_compare($lhs, $rhs)
  ((asm ~{:bytecode @[(cmp 2 0 1)
                      (ret 2)]
          :arity 2})
    -11 22)
  # =>
  -1

  # cncl: resume $fiber, but raise $error immediately
  (try
    ((asm ~{:bytecode @[(cncl 2 0 1)
                        (ret 2)]
            :arity 2})
      (coro 1) "Oops!")
    ([e]
      (string "Ah..." e)))
  # =>
  "Ah...Oops!"

  # div: $dest = $lhs / $rhs
  ((asm ~{:bytecode @[(div 2 0 1)
                      (ret 2)]
          :arity 2})
    1 0)
  # =>
  math/inf

  # divim: $dest = $lhs / im
  ((asm ~{:bytecode @[(divim 2 0 0x2)
                      (ret 2)]
          :arity 1})
    1)
  # =>
  0.5

  # eq: $dest = $lhs == $rhs
  ((asm ~{:bytecode @[(eq 2 0 1)
                      (ret 2)]
          :arity 2})
    1 0)
  # =>
  false

  # eqim: $dest = $lhs == im
  ((asm ~{:bytecode @[(eqim 2 0 0x1)
                      (ret 2)]
          :arity 1})
    1)
  # =>
  true

  # err: throw $error
  (try
    ((asm ~{:bytecode @[(err 0)]
            :arity 1})
      "at you!")
    ([e]
      (string "Have " e)))
  # =>
  "Have at you!"

  # get: $dest = $ds[$key]
  ((asm ~{:bytecode @[(get 2 0 1)  # (get dest ds key)
                      (ret 2)]
          :arity 2})
    {:a 1} :a)
  # =>
  1

  # geti: $dest = $ds[index]
  ((asm ~{:bytecode @[(geti 2 0 0x2)  # (geti dest ds index)
                      (ret 2)]
          :arity 1})
    [0 1 8])
  # =>
  8

  # gt: $dest = $lhs > $rhs
  ((asm ~{:bytecode @[(gt 2 0 1)
                      (ret 2)]
          :arity 2})
    0 88)
  # =>
  false

  # gte: $dest = $lhs >= $rhs
  ((asm ~{:bytecode @[(gte 2 0 1)
                      (ret 2)]
          :arity 2})
    88 88)
  # =>
  true

  # gtim: $dest = $lhs > im
  ((asm ~{:bytecode @[(gtim 1 0 0x57)
                      (ret 1)]
          :arity 1})
    88)
  # =>
  true

  # in: $dest = $ds[$key] using `in`
  ((asm ~{:bytecode @[(in 2 0 1)
                      (ret 2)]
          :arity 2})
    {:x :spot} :x)
  # =>
  :spot

  # jmp: pc += offset
  ((asm ~{:bytecode @[(jmp 3)
                      (ldi 0 0x8)
                      (ret 0)
                      (ldi 0 0x9)
                      (ret 0)]
          :arity 0}))
  # =>
  9

  # jpmif: if $cond pc += offset else pc++
  ((asm ~{:bytecode @[(jmpif 0 2)
                      (ret 1)
                      (ret 2)]
          :arity 3})
    true :ant :bee)
  # =>
  :bee

  # jmpni: if $cond == nil pc += offset else pc++
  ((asm ~{:bytecode @[(jmpni 0 2)
                      (ret 1)
                      (ret 2)]
          :arity 3})
    true :ant :bee)
  # =>
  :ant

  # jmpnn: if $cond != nil pc += offset else pc++
  ((asm ~{:bytecode @[(jmpnn 0 2)
                      (ret 1)
                      (ret 2)]
          :arity 3})
    true :ant :bee)
  # =>
  :bee

  # jmpno: if $cond pc++ else pc += offset
  ((asm ~{:bytecode @[(jmpno 0 2)
                      (ret 1)
                      (ret 2)]
          :arity 3})
    true :ant :bee)
  # =>
  :ant

  # ldc: $dest = constants[index]
  ((asm ~{:constants [:grin]
          :bytecode @[(ldc 0 0)
                      (ret 0)]
          :arity 0}))
  # =>
  :grin

  # ldf: $dest = false
  ((asm ~{:bytecode @[(ldf 0)
                      (ret 0)]
          :arity 0}))
  # =>
  false

  # ldi: $dest = integer
  ((asm ~{:bytecode @[(ldi 0 0x100)
                      (ret 0)]
          :arity 0}))
  # =>
  256

  # ldn: $dest = nil
  ((asm ~{:bytecode @[(ldn 0)
                      (ret 0)]
          :arity 0}))
  # =>
  nil

  # factorial with accumulator
  # lds: $dest = current closure (self)
  ((asm ~{:bytecode @[(ltim 2 0 0x2)
                      (jmpif 2 :end)
                      (lds 2)
                      (mul 1 0 1)
                      (addim 0 0 -0x1)
                      (push2 0 1)
                      (call 1 2)
                      :end
                      (ret 1)]
          :arity 2})
    5 1)
  # =>
  120

  # ldt: $dest = true
  ((asm ~{:bytecode @[(ldt 0)
                      (ret 0)]
          :arity 0}))
  # =>
  true

  # ldu: $dest = envs[env][index]
  ((asm '{:arity 1
          :bytecode @[(clo 1 0)             # $1 = defs[0]
                      (ldi 2 0x8)           # $2 = 8
                      (push 2)              # push $2 to args
                      (call 2 1)            # $2 = ($1 $2) == (defs[0] $2)
                      (ret 2)]              # return $2
          :defs @[{:arity 1
                   :bytecode @[(ldu 1 0 0)  # $1 = $0 from parent?
                               (add 2 1 0)  # $2 = $1 + $0
                               (ret 2)]     # return $2
                   :environments @[-1]}]})  # (ldu _ 0 _) refers to -1
    3)
  # =>
  11

  # len: $dest = length($ds)
  ((asm ~{:bytecode @[(len 0 0)
                      (ret 0)]
          :arity 1})
    [:ant :bee :cat])
  # =>
  3

  # lt: $dest = $lhs < $rhs
  ((asm ~{:bytecode @[(lt 0 0 1)
                      (ret 0)]
          :arity 2})
    math/-inf math/inf)
  # =>
  true

  # lte: $dest = $lhs <= $rhs
  ((asm ~{:bytecode @[(lte 0 0 1)
                      (ret 0)]
          :arity 2})
    0 1)
  # =>
  true

  # ltim: $dest = $lhs < im
  ((asm ~{:bytecode @[(ltim 0 0 0x1)
                      (ret 0)]
          :arity 1})
    0)
  # =>
  true

  # mkarr: $dest = call(array, args)
  ((asm ~{:bytecode @[(push3 0 1 2)
                      (mkarr 0)
                      (ret 0)]
          :arity 3})
    :elephant :fox :giraffe)
  # =>
  @[:elephant :fox :giraffe]

  # mkbtp: $dest = call(tuple/brackets, args)
  ((asm ~{:bytecode @[(push2 0 1)
                      (mkbtp 0)
                      (ret 0)]
          :arity 2})
    [] {})
  # =>
  '[() {}]

  # mkbuf: $dest = call(buffer, args)
  ((asm ~{:bytecode @[(push2 0 1)
                      (mkbuf 0)
                      (ret 0)]
          :arity 2})
    :hi " there")
  # =>
  @"hi there"

  # mkstr: $dest = call(string, args)
  ((asm ~{:bytecode @[(push2 0 1)
                      (mkstr 0)
                      (ret 0)]
          :arity 2})
    @"gday, m" 8)
  # =>
  "gday, m8"

  # mkstu: $dest = call(struct, args)
  ((asm ~{:bytecode @[(push3 0 1 2)
                      (push3 3 4 5)
                      (mkstu 0)
                      (ret 0)]
          :arity 6})
    :x 10 :y 20 :z 80)
  # =>
  {:x 10 :y 20 :z 80}

  # mktab: $dest = call(table, args)
  ((asm ~{:bytecode @[(push2 0 1)
                      (mktab 0)
                      (ret 0)]
          :arity 2})
    :breathe :slowly)
  # =>
  @{:breathe :slowly}

  # mktup: $dest = call(tuple, args)
  ((asm ~{:bytecode @[(push3 0 1 2)
                      (mktup 0)
                      (ret 0)]
          :arity 3})
    '+ 1 1)
  # =>
  '(+ 1 1)

  # mod: $dest = $lhs mod $rhs
  ((asm ~{:bytecode @[(mod 0 0 1)
                      (ret 0)]
          :arity 2})
    -3 2)
  # =>
  1

  # movf: $dest = $src
  ((asm ~{:bytecode @[(movf 0 1)  # (movf src dest)
                      (ret 1)]
          :arity 1})
    :echo)
  # =>
  :echo

  # movn: $dest = $src
  ((asm ~{:bytecode @[(movn 1 0)  # (movn dest src)
                      (ret 1)]
          :arity 1})
    :again)
  # =>
  :again

  # mul: $dest = $lhs * $rhs
  ((asm ~{:bytecode @[(mul 2 0 1)
                      (ret 2)]
          :arity 2})
    2 3)
  # =>
  6

  # mulim: $dest = $lhs * im
  ((asm ~{:bytecode @[(mulim 1 0 0x8)
                      (ret 1)]
          :arity 1})
    11)
  # =>
  88

  # neq: dest = $lhs != $rhs
  ((asm ~{:bytecode @[(neq 2 0 1)
                      (ret 2)]
          :arity 2})
    0 -0)
  # =>
  false

  # neqim: $dest = $lhs != im
  ((asm ~{:bytecode @[(neqim 2 0 0x23)
                      (ret 2)]
          :arity 1})
    22)
  # =>
  true

  # next: $dest = next($ds, $key)
  ((asm ~{:bytecode @[(next 2 0 1)
                      (ret 2)]
          :arity 2})
    [:a :b :c] 1)
  # =>
  2

  # noop: does nothing
  ((asm ~{:bytecode @[(noop)
                      (noop)
                      (noop)
                      (noop)
                      (noop)
                      (noop)
                      (noop)
                      (noop)
                      (ret 0)]
          :arity 1})
    math/inf)
  # =>
  math/inf

  # prop: propagate (re-raise) a signal that has been caught
  (do
    (def fib (coro :a))
    (resume fib)
    ((asm ~{:bytecode @[(prop 2 0 1)  # (prop dest val fiber)
                        (ldi 0 0x9)   # never reached
                        (ret 0)]
            :arity 2})
      "skip!" fib))
  # =>
  "skip!"

  # put: $ds[$key] = $val
  ((asm ~{:bytecode @[(put 0 1 2)  # (put ds key val)
                      (ret 0)]
          :arity 3})
    @{} :a 1)
  # =>
  @{:a 1}

  # puti: $ds[index] = $val
  ((asm ~{:bytecode @[(puti 0 1 0x0)  # (puti ds val index)
                      (ret 0)]
          :arity 2})
    @[] :smile)
  # =>
  @[:smile]

  # rem: $dest = $lhs % $rhs
  ((asm ~{:bytecode @[(rem 2 0 1)
                      (ret 2)]
          :arity 2})
    -3 2)
  # =>
  -1

  # res: $dest = resume $fiber with $val
  ((asm ~{:bytecode @[(res 2 0 1)
                      (ret 2)]
          :arity 2})
    (fiber/new (fn [x] (* x 8)))
    9)
  # =>
  72

  # ret: return $val
  ((asm ~{:bytecode @[(ret 0)]
          :arity 1})
    :love)
  # =>
  :love

  # retn: return nil
  ((asm ~{:bytecode @[(retn)]
          :arity 0}))
  # =>
  nil

  # setu: envs[env][index] = $val
  ((asm '{:arity 0
          :bytecode @[(clo 0 0)                 # define the closure
                      (ldi 1 0x8)               # prepare $1 for closure
                      (call 2 0)                # calling for side-effect
                      (ret 1)]                  # returned modified value
          :defs @[{:arity 0
                   :bytecode @[(ldu 0 0 1)      # $0 = parent's $1
                               (addim 0 0 0x1)  # increment $0
                               (setu 0 0 1)     # parent's $1 = $0
                               (retn)]          # caller ignores this
                   :environments @[-1]}]}))
  # =>
  (+ 0x8 0x1)

  # enum JanetSignal, JANET_SIGNAL_ERROR is 1
  # sig: $dest = emit $value as sigtype
  (try
    ((asm ~{:bytecode @[(sig 2 0 0x1)  # (sig dest value sigtype)
                        (ldi 1 0xff)   # never reached
                        (ret 1)]
            :arity 1})
      :wocky)
    ([e]
      (string "jabber" e)))
  # =>
  "jabberwocky"

  # sl: $dest = $lhs << $rhs
  ((asm ~{:bytecode @[(sl 2 0 1)
                      (ret 2)]
          :arity 2})
    2r10 3)
  # =>
  16

  # slim: $dest = $lhs << shamt
  ((asm ~{:bytecode @[(slim 1 0 0x3)
                      (ret 1)]
          :arity 1})
    2r10)
  # =>
  16

  # sr: $dest = $lhs >> $rhs
  ((asm ~{:bytecode @[(sr 2 0 1)
                      (ret 2)]
          :arity 2})
    -2r101 2)
  # =>
  -2

  # srim: $dest = $lhs >> shamt
  ((asm ~{:bytecode @[(srim 1 0 0x2)
                      (ret 1)]
          :arity 1})
    -2r101)
  # =>
  -2

  # sru: $dest = $lhs >>> $rhs
  ((asm ~{:bytecode @[(sru 2 0 1)
                      (ret 2)]
          :arity 2})
    2r1100 3)
  # =>
  1

  # sruim: $dest = $lhs >>> shamt
  ((asm ~{:bytecode @[(sruim 1 0 0x3)
                      (ret 1)]
          :arity 1})
    2r1100)
  # =>
  1

  # sub: $dest = $lhs - $rhs
  ((asm ~{:bytecode @[(sub 2 0 1)
                      (ret 2)]
          :arity 2})
    0 1)
  # =>
  -1

  # tcall: return call($callee, args)
  ((asm ~{:bytecode @[(tcall 0)]
          :arity 1})
    +)
  # =>
  0

  # enum JanetType, JANET_KEYWORD is 6, 2 ** 6 == 64
  # tchck: assert $slot matches types
  ((asm ~{:bytecode @[(tchck 0 64)
                      (ret 0)]
          :arity 1})
    :hello)
  # =>
  :hello

  )
````````
"assert"
````````
(comment

  (try
    (assert (= true false))
    ([e]
      :caught))
  # =>
  :caught

  (try
    (assert (= true false)
            "Sorry, no contradictions allowed")
    ([e]
      :caught-2-arg-version))
  # =>
  :caught-2-arg-version

  (assert (= true true)
          "At least some level of consistency")
  # =>
  true

  )
````````
"boolean?"
````````
(comment

  (boolean? true)
  # =>
  true

  (boolean? false)
  # =>
  true

  (boolean? nil)
  # =>
  false

  (boolean? 0)
  # =>
  false

  (boolean? (< 0 1))
  # =>
  true

  (boolean? (<= 2 1))
  # =>
  true

  (boolean? (= math/pi math/e))
  # =>
  true

  (boolean? (> math/inf math/-inf))
  # =>
  true

  (boolean? (>= 0 0))
  # =>
  true

  (boolean? (abstract? nil))
  # =>
  true

  (boolean? (all even? [0 2 8]))
  # =>
  true

  (boolean? (all |(when (even? $))
                 [0 3 8]))
  # =>
  false

  (boolean? (and true false))
  # =>
  true

  (boolean? (and true nil))
  # =>
  false

  (boolean? (any? [true nil]))
  # =>
  true

  (boolean? (any? [nil]))
  # =>
  false

  (boolean? (array? @[]))
  # =>
  true

  (boolean? (array? :a))
  # =>
  true

  (boolean? (buffer/bit @"1" 0))
  # =>
  true

  (boolean? (buffer/bit @"1" 1))
  # =>
  true

  (boolean? (buffer? @""))
  # =>
  true

  (boolean? (bytes? []))
  # =>
  true

  (boolean? (cfunction? :a))
  # =>
  true

  (boolean? (compare< 1 2))
  # =>
  true

  (boolean? (compare<= -1 -2))
  # =>
  true

  (boolean? (compare= 0 0.0))
  # =>
  true

  (boolean? (compare> -0 1))
  # =>
  true

  (boolean? (compare>= math/-inf math/inf))
  # =>
  true

  (boolean? (deep-not= [:a] [:b]))
  # =>
  true

  (boolean? (deep= [:a] [:b]))
  # =>
  true

  (boolean? (dictionary? "hello"))
  # =>
  true

  (boolean? (disasm (fn [] 9) :vararg))
  # =>
  true

  (boolean? (empty? :smile))
  # =>
  true

  (boolean? (even? math/nan))
  # =>
  true

  (boolean? (false? false))
  # =>
  true

  (boolean? (false? true))
  # =>
  true

  (boolean? (fiber/can-resume? (coro 1)))
  # =>
  true

  (boolean? (fiber? (coro :breathe)))
  # =>
  true

  (boolean? (function? map))
  # =>
  true

  (boolean? (idempotent? false))
  # =>
  true

  (boolean? (keyword? 'fun))
  # =>
  true

  (boolean? (nan? 0))
  # =>
  true

  (boolean? (nat? math/nan))
  # =>
  true

  (boolean? (neg? math/inf))
  # =>
  true

  (boolean? (nil? 1))
  # =>
  true

  (boolean? (not 1))
  # =>
  true

  (boolean? (not= 0.0 0))
  # =>
  true

  (boolean? (number? "hi"))
  # =>
  true

  (boolean? (odd? 2))
  # =>
  true

  (boolean? (one? 1.1))
  # =>
  true

  (boolean? (parse "true"))
  # =>
  true

  (boolean? (parse "nil"))
  # =>
  false

  (boolean? (pos? -3))
  # =>
  true

  (boolean? (string/check-set "abcdr " "abra cadabra"))
  # =>
  true

  (boolean? (string/has-prefix? "/" "/tmp"))
  # =>
  true

  (boolean? (string/has-suffix? ".txt" "README.txt"))
  # =>
  true

  (boolean? (string? "my my"))
  # =>
  true

  (boolean? (struct? {:ant :zebra}))
  # =>
  true

  (boolean? (symbol? :a-keyword))
  # =>
  true

  (boolean? (table? @{:x 1080 :y 720}))
  # =>
  true

  (boolean? (do
              (var x nil)
              (toggle x)))
  # =>
  true

  (boolean? (true? false))
  # =>
  true

  (boolean? (truthy? nil))
  # =>
  true

  (boolean? (tuple? @[:an :array]))
  # =>
  true

  (boolean? (zero? 0.1))
  # =>
  true

  )
````````
"break"
````````
```
special form

`(break value?)`

Break from a `while` loop or return early from a function.

The `break` special form can only break from the inner-most loop.

Since a `while` loop always returns `nil`, the optional value
parameter has no effect when used in a `while` loop, but when
returning from a function, the value parameter is the function's
return value.

The `break` special form is most useful as a low level construct for
macros. You should try to avoid using it in handwritten code, although
it can be very useful for handling early exit conditions without
requiring deeply indented code (try the `cond` macro first, though).

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  (while true
    (break))
  # =>
  nil

  (do
    (def arr @[])
    (for i 0 2
      (array/push arr i)
      (when (pos? i)
        (break)))
    arr)
  # =>
  @[0 1]

  (do
    (var tot 0)
    (each i [-1 0 1]
      (+= tot i)
      (when (zero? i)
        (break)))
    tot)
  # =>
  -1

  (do
    (var r nil)
    (for i 0 2
      (for j 0 2
        (when (and (pos? i) (pos? j))
          (break)))
      (set r i))
    r)
  # =>
  1

  (do
    (defn a-fn
      []
      (when (> (math/random) 0.5)
        (break 1))
      (when (> (math/random) 0.5)
        (break 2))
      3)
    (get {1 true 2 true 3 true}
         (a-fn)))
  # =>
  true

  )
````````
"buffer?"
````````
(comment

  (buffer? @"hello")
  # =>
  true

  (buffer?
    @``
     even long-buffers
     are buffers
     ``)
  # =>
  true

  (buffer? "")
  # =>
  false

  (buffer? (buffer "hi"))
  # =>
  true

  )
````````
"bytes?"
````````
(comment

  (bytes? "a-string")
  # =>
  true

  (bytes? 'a-symbol)
  # =>
  true

  (bytes? :a-keyword)
  # =>
  true

  (bytes? @"a-buffer")
  # =>
  true

  (bytes? nil)
  # =>
  false

  (bytes? math/nan)
  # =>
  false

  (bytes? [:a :b :c])
  # =>
  false

  )
````````
"case"
````````
(comment

  (case (+ 1 2)
    1
    :nope
    #
    2
    :try-again
    #
    3
    :yay!)
  # =>
  :yay!

  (case :fun)
  # =>
  nil

  (case :odd-trivial
    :highlander)
  # =>
  :highlander

  (case :odd-for-real
    3.1415926535
    :approximate
    #
    2.71828
    :still-not-quite
    #
    0)
  # =>
  0

  )
````````
"cfunction?"
````````
(comment

  (cfunction? getline)
  # =>
  true

  (cfunction? inc)
  # =>
  false

  [(cfunction? print) (function? print)]
  # =>
  [true false]

  )
````````
"chr"
````````
(comment

  (chr "a")
  # =>
  97

  (chr "\0")
  # =>
  0

  (chr "\e")
  # =>
  27

  (chr "\v")
  # =>
  11

  )
````````
"comment"
````````
(comment

  (comment "a fine string")
  # =>
  nil

  (comment

    (def a 1)

    a

    )
  # =>
  nil

  )
````````
"comp"
````````
(comment

  (do
    (def g inc)
    (def f |(math/pow $ 2))
    (def h (comp g f))
    (h 3))
  # =>
  10

  ((comp inc |(math/pow $ 2))
    3)
  # =>
  10

  (do
    (def g inc)
    (def f dec)
    (def h (comp g f))
    (h 42))
  # =>
  42

  ((comp inc dec)
    42)
  # =>
  42

  ((comp (fn g [xs]
           (map inc xs))
         (fn f [xs]
           (map |(math/pow $ 3) xs)))
    [0 1 2])
  # =>
  @[1 2 9]

  )
````````
"compare"
````````
(comment

  (do
    (defn a-cmp
      [x y]
      (let [x-val (get x :value)
            y-val (get y :value)]
        (cond
          (< x-val y-val) -1
          (= x-val y-val) 0
          (> x-val y-val) 1)))
    (compare {:compare a-cmp :value 1}
             {:compare a-cmp :value 2}))
  # =>
  -1

  (do
    (defn a-cmp
      [x y]
      (let [x-val (get x :value)
            y-val (get y :value)]
        (cond
          (< x-val y-val) -1
          (= x-val y-val) 0
          (> x-val y-val) 1)))
    (compare {:compare a-cmp :value 1}
             {:compare a-cmp :value 1}))
  # =>
  0

  (do
    (defn a-cmp
      [x y]
      (let [x-val (get x :value)
            y-val (get y :value)]
        (cond
          (< x-val y-val) -1
          (= x-val y-val) 0
          (> x-val y-val) 1)))
    (compare {:compare a-cmp :value 1}
             {:value 2}))
  # =>
  -1

  (do
    (defn a-cmp
      [x y]
      (let [x-val (get x :value)
            y-val (get y :value)]
        (cond
          (< x-val y-val) -1
          (= x-val y-val) 0
          (> x-val y-val) 1)))
    (compare {:value 1}
             {:compare a-cmp :value 2}))
  # =>
  -1

  (do
    (defn a-cmp
      [x y]
      (let [x-val (or (get x :value) x)
            y-val (or (get y :value) y)]
        (cond
          (< x-val y-val) -1
          (= x-val y-val) 0
          (> x-val y-val) 1)))
    (compare 1
             {:compare a-cmp :value 2}))
  # =>
  -1

  (compare -1 1)
  # =>
  -1

  )
````````
"complement"
````````
(comment

  (do
    (def f (complement pos?))
    (f 1))
  # =>
  false

  (do
    (def f (complement zero?))
    (f 1))
  # =>
  true

  ((complement even?) 1)
  # =>
  true

  )
````````
"cond"
````````
(comment

  (cond
    true
    :hi)
  # =>
  :hi

  (cond
    false
    :not-reached
    #
    true
    :hello)
  # =>
  :hello

  (cond
    :why)
  # =>
  :why

  (cond
    (= 1 2)
    :not-today
    #
    (= 2 3)
    :not-ever
    #
    :because)
  # =>
  :because

  (cond
    false
    :not-returned)
  # =>
  nil

  )
````````
"coro"
````````
(comment

  (do
    (def fib
      (coro
        (for i 0 3
          (yield i))))
    (resume fib)
    [(resume fib) (resume fib)])
  # =>
  [1 2]

  (do
    (var j 0)
    (def fib
      (coro
        (for i 1 5
          (yield (+ j i)))))
    [(resume fib)
     (set j 6)
     (resume fib) (resume fib)])
  # =>
  [1 6 8 9]

  (do
    (def fib-1
      (coro
        (yield :a)))
    (def fib-2
      (coro
        (yield fib-1)))
    (->> fib-2
         resume
         resume))
  # =>
  :a

  (do
    (var f1 nil)
    (var f2 nil)
    (set f1
      (coro
        (yield :a)
        (yield (resume f2))))
    (set f2
      (coro
        (yield :b)
        (yield (resume f1))))
    [(resume f1) (resume f1)])
  # =>
  [:a :b]

  (do
    (def to-f1 @[:your :to :be])
    (def to-f2 @[nil :drink :sure])
    (def to-f3 @[])
    (def f1
      (coro
        (forever
          (def msg (array/pop to-f1))
          (array/push to-f3 msg)
          (yield true))))
    (def f2
      (coro
        (forever
          (def msg (array/pop to-f2))
          (array/push to-f3 msg)
          (yield true))))
    (resume f1)
    (resume f2)
    (resume f1)
    (resume f2)
    (resume f1)
    (resume f2)
    to-f3)
  # =>
  @[:be :sure :to :drink :your nil]

  )
````````
"count"
````````
(comment

  (count number? [1 :a "hello" [0 1 2] 0])
  # =>
  2

  (count (fn [x y] (neg? (+ x y)))
         [-1 -1 -1] [-1 0 1])
  # =>
  2

  (count |(pos? (* $0 $1 $2))
         [-3 -2] [-1 0 99] [3 2])
  # =>
  1

  (count even? [2r111 0x08 8r11 10])
  # =>
  2

  (count (fn [x]
            (>= x (math/pow x 2)))
         [0 0.5 1 2 6 8 math/inf])
  # =>
  4

  (count nil [])
  # =>
  0

  (count pos? [math/-inf -1 0 1 math/pi])
  # =>
  2

  (count pos?
          (coro
            (for i -3 3
              (yield i))))
  # =>
  2

  (->> [0 1 2 3 7 8 9]
       (map |(math/pow $ 2))
       (count odd?))
  # =>
  4

  )
````````
"dec"
````````
(comment

  (do
    (def i 0)
    (dec i))
  # =>
  -1

  )
````````
"def"
````````
```
special form

`(def name meta... value)`

`def` binds a value to a symbol.

The symbol can be substituted for the value in subsequent expressions
for the same result.

A binding made by `def` is a constant and cannot be updated.  A symbol
can be redefined to a new value, but previous uses of the binding will
refer to the previous value of the binding.

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  (do
    (def a 1)
    a)
  # =>
  1

  (do
    (def a 1)
    (def a 2)
    a)
  # =>
  2

  (do
    (def a 1)
    (do
      (def a 2))
    a)
  # =>
  1

  (do
    (def [a b]
      [1 2])
    a)
  # =>
  1

  (do
    (def [x y & rest]
      [1 2 3 8 9])
    rest)
  # =>
  '(3 8 9)

  (do
    (def {:a a
          :b b}
      (table :a 1
             :b 2))
    b)
  # =>
  2

  )
````````
"default-peg-grammar"
````````
(comment

  (table? default-peg-grammar)
  # =>
  true

  (>= (length default-peg-grammar) 20)
  # =>
  true

  (default-peg-grammar :s)
  # =>
  '(set " \t\r\n\0\f\v")

  (default-peg-grammar :s+)
  # =>
  '(some :s)

  (default-peg-grammar :s*)
  # =>
  '(any :s)

  (default-peg-grammar :S)
  # =>
  '(if-not :s 1)

  (default-peg-grammar :j)
  # =>
  nil

  )
````````
"default"
````````
(comment

  (do
    (defn a-fn
      [&opt arg]
      (default arg 2)
      (+ arg 1))

    (a-fn))
  # =>
  3

  (do
    (defn a-fn
      [&opt arg]
      (default arg 2)
      (+ arg 1))

    (a-fn 7))
  # =>
  8

  (do
    (defn a-fn
      [arg]
      (default arg 2)
      (+ arg 1))

    (a-fn nil))
  # =>
  3

  (do
    (defn a-fn
      [arg]
      (default arg 2)
      (+ arg 1))

    (a-fn 8))
  # =>
  9

  )
````````
"defdyn"
````````
(comment

  (do
    (defdyn *special-flag*
      "A special flag for ...")
    (setdyn *special-flag* (math/random))
    (= (dyn :special-flag)
       (dyn *special-flag*)))
  # =>
  true

  )
````````
"defer"
````````
(comment

  (do
    (var state nil)
    (defer (set state :altered)
      (for i 0 2
        (inc i)))
    state)
  # =>
  :altered

  (do
    (var box nil)
    (try
      (defer (set box :hope)
        (for i 0 3
          (when (pos? i)
            (error "must have goofed up somewhere..."))))
      ([e]
        box)))
  # =>
  :hope

  )
````````
"defglobal"
````````
(comment

  (do
    (defn my-fn
      []
      (defglobal 'a 1))

    (my-fn)

    # note: after the enclosing `do`, `a` will evaluate to 1
    ((dyn 'a) :value))
  # =>
  1

  )
````````
"defn"
````````
(comment

  (do
    (defn my-fn
      [x]
      (+ x 1))

    (my-fn 2))
  # =>
  3

  (do
    (defn my-documented-fn
      "What a nice doc-string..."
      [x]
      (+ x 11))

    (my-documented-fn 0))
  # =>
  11

  (do
    (defn outer-fn
      [x]
      (defn inner-fn
        [y]
        (+ x y))

      (inner-fn 1))

    (outer-fn 2))
  # =>
  3

  )
````````
"dictionary?"
````````
(comment

  (dictionary? {:animal "penguin"
                :drink "green tea"})
  # =>
  true

  (dictionary? @{:x 640 :y 480})
  # =>
  true

  (dictionary? (from-pairs [:color "yellow"
                            :shape "star"]))
  # =>
  true

  (dictionary? (freeze @{:x 1080 :y 720}))
  # =>
  true

  (dictionary? (struct/to-table {:a 1 :b 2}))
  # =>
  true

  (dictionary? (table/to-struct @{:a 1 :b 2}))
  # =>
  true

  (dictionary?
    (tabseq [i :range-to [0 3]]
      i (math/pow i 3)))
  # =>
  true

  (dictionary? nil)
  # =>
  false

  (dictionary? @[])
  # =>
  false

  (dictionary? [])
  # =>
  false

  )
````````
"distinct"
````````
(comment

  (distinct @[1 2 3 2 1])
  # =>
  @[1 2 3]

  (distinct "bookkeeper")
  # =>
  @[98 111 107 101 112 114]

  (distinct :hello)
  # =>
  @[104 101 108 111]

  (sort (map string/from-bytes
             (distinct "bookkeeper")))
  # =>
  @["b" "e" "k" "o" "p" "r"]

  )
````````
"do"
````````
```
special form

`(do body...)`

Execute a series of forms for side effects and evaluates to the final
form.

Also introduces a new lexical scope without creating or calling a
function.

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  (do)
  # =>
  nil

  (do
    true)
  # =>
  true

  (do
    (print "hi")
    (+ 1 1))
  # =>
  2

  (do
    (do
      :fun))
  # =>
  :fun

  (do
    (def a 1)
    a)
  # =>
  1

  (do
    (def a 1)
    (do
      (def a 2))
    a)
  # =>
  1

  )
````````
"drop-until"
````````
(comment

  (drop-until even? [1 2 3])
  # =>
  [2 3]

  (drop-until |(number? (scan-number $))
              ["2r111" "0x08" "8r11" "10"])
  # =>
  ["2r111" "0x08" "8r11" "10"]

  (drop-until odd? "hi")
  # =>
  "i"

  (drop-until even? :smilet)
  # =>
  "let"

  (drop-until nil [])
  # =>
  []

  )
````````
"drop-while"
````````
(comment

  (drop-while even? [1 2 3])
  # =>
  [1 2 3]

  (drop-while |(number? (scan-number $))
              ["2r111" "0x08" "8r11" "10"])
  # =>
  []

  (drop-while odd? "aaaaatract")
  # =>
  "tract"

  (drop-while even? ":foo!")
  # =>
  "oo!"

  (drop-while nil [])
  # =>
  []

  )
````````
"drop"
````````
(comment

  (drop 2 [:ant :bee :cheetah])
  # =>
  [:cheetah]

  (drop -2 [0 1 2])
  # =>
  [0]

  (drop 2 "spice")
  # =>
  "ice"

  (drop 0 :oops)
  # =>
  "oops"

  (drop -1 :oops)
  # =>
  "oop"

  (drop -1 'print)
  # =>
  "prin"

  (drop 0 @[0 1 2])
  # =>
  [0 1 2]

  (drop 0 [])
  # =>
  []

  (drop 1 [])
  # =>
  []

  )
````````
"each"
````````
(comment

  (each i [])
  # =>
  nil

  (let [arr @[]
        tup [:a :b :c]]
    (each elt tup
      (array/push arr elt))
    arr)
  # =>
  @[:a :b :c]

  (do
    (def arr @[])
    (each v {:a 2 :e 6}
      (array/push arr v))
    (sort arr))
  # =>
  @[2 6]

  (do
    (def tbl @{})
    (def tup [:a :b :c])
    (each elt tup
      (put tbl elt true))
    tbl)
  # =>
  @{:a true :b true :c true}

  (do
    (def buf @"")
    (def zoo [:ant :bee :cat])
    (each animal zoo
      (when (= animal :cat)
        (break))
      (buffer/push buf animal "!"))
    buf)
  # =>
  @"ant!bee!"

  )
````````
"eachk"
````````
(comment

  (do
    (def arr @[])
    (def a-struct {:a 1 :b 2})
    (eachk k a-struct
      (array/push arr (get a-struct k)))
    (sort arr))
  # =>
  @[1 2]

  (let [arr @[]
        tbl @{:x 1 :y 2 :z 3}]
    (eachk k tbl
      (when (= k :z) (break))
      (array/push arr k))
    (not= (length arr) (length tbl)))
  # =>
  true

  )
````````
"eachp"
````````
(comment

  (let [arr @[]]
    (eachp [k v] {:ant 1 :bee 2}
      (array/push arr [k v]))
    (sort arr))
  # =>
  @[[:ant 1] [:bee 2]]

  (let [two-legs @[]
        six-legs @[]
        wings @[]]
    (eachp [k v] {:ant :insect :bee :insect :magpie :bird}
      (cond
        (= v :insect) (array/push six-legs k)
        (= v :bird) (array/push two-legs k))
      (when (or (= k :bee) (= k :magpie))
        (array/push wings k)))
    (map sort [two-legs six-legs wings]))
  # =>
  @[@[:magpie]
    @[:ant :bee]
    @[:bee :magpie]]

  )
````````
"edefer"
````````
(comment

  (do
    (var state :untouched)
    (edefer (set state :altered)
      (for i 0 2
        (inc i)))
    state)
  # =>
  :untouched

  (do
    (var box nil)
    (try
      (edefer (set box :errored)
        (for i 0 3
          (when (pos? i)
            (error "must have goofed up somewhere..."))))
      ([e]
        box)))
  # =>
  :errored

  )
````````
"empty?"
````````
(comment

  (empty? [])
  # =>
  true

  (empty? @{})
  # =>
  true

  (empty? "")
  # =>
  true

  (empty? [1])
  # =>
  false

  (empty? @[])
  # =>
  true

  (def [ok? value] (protect (empty? 0)))
  # =>
  [false "expected iterable type, got 0"]

  )
````````
"errorf"
````````
(comment

  (try
    (errorf "%s" "captured")
    ([e]
      e))
  # =>
  "captured"

  )
````````
"eval-string"
````````
(comment

  (eval-string "(+ 1 2 3 4)")
  # =>
  10

  (def [ok? value]
    (-> (eval-string ")")
        protect))
  # =>
  [false "unexpected closing delimiter )"]

  (def [ok? value]
    (-> (eval-string "(bloop)")
        protect))
  # =>
  [false "unknown symbol bloop"]

  (def [ok? value]
    (-> (eval-string "(+ nil nil)")
        protect))
  # =>
  [false "could not find method :+ for nil or :r+ for nil"]

  )
````````
"eval"
````````
(comment

  (eval '(+ 1 2 3)) 
  # =>
  6

  (def [ok? value] 
    (-> (eval '(error :oops))
        protect))
  # =>
  [false :oops]

  (def [ok? value] 
    (-> (eval '(+ nil nil))
        protect))
  # =>
  [false "could not find method :+ for nil or :r+ for nil"]

  )
````````
"even?"
````````
(comment

  (even? 0)
  # =>
  true

  (even? 1)
  # =>
  false

  (even? 2.0)
  # =>
  true

  (do
    (defn a-cmp
      [x y]
      (let [x-val (or (get x :value) x)
            y-val (or (get y :value) y)]
        (cond
          (< x-val y-val) -1
          (= x-val y-val) 0
          (> x-val y-val) 1)))
    (defn a-mod
      [x y]
      (let [x-val (or (get x :value) x)
            y-val (or (get y :value) y)]
        (mod x-val y-val)))
    (even? {:compare a-cmp :mod a-mod :value 2}))
  # =>
  true

  )
````````
"extreme"
````````
(comment

  (extreme < [1 0 -1])
  # =>
  -1

  (extreme > [-1 0 1])
  # =>
  1

  (extreme (fn [x y]
             (> (math/pow x 3) (math/pow y 3)))
           [-1 -0.5 0 0.3 0.6])
  # =>
  0.6

  (extreme < [])
  # =>
  nil

  (extreme > [math/int32-max math/inf])
  # =>
  math/inf

  (extreme > [math/int32-max math/inf nil])
  # =>
  nil

  )
````````
"fiber?"
````````
(comment

  (fiber? (coro
            (for i 0 3
              (yield i))))
  # =>
  true

  (fiber? (ev/cancel (ev/spawn
                       (for i 0 2
                         (yield i)))
                     "fiber cancelled"))
  # =>
  true

  (fiber? (fiber/new (fn [] 1)))
  # =>
  true

  (fiber? (fiber-fn :yi
                    (yield :smile)))
  # =>
  true

  (fiber? (fiber/current))
  # =>
  true

  (try
    (error "oops")
    ([e f]
      (fiber? f)))
  # =>
  true

  )
````````
"filter"
````````
(comment

  (filter pos? [1 2 3 0 -4 5 6])
  # =>
  @[1 2 3 5 6]

  (filter |(> (length $) 3)
          ["hello" "goodbye" "hi"])
  # =>
  @["hello" "goodbye"]

  (filter |(< (chr "A") $) "foo01bar")
  # =>
  @[102 111 111 98 97 114]

  (filter number? [1 :a "hello" [0 1 2] 0])
  # =>
  @[1 0]

  (filter even? [2r111 0x08 8r11 10])
  # =>
  @[8 10]

  (filter (fn [x]
            (>= x (math/pow x 2)))
          [0 0.5 1 2 6 8 math/inf])
  # =>
  @[0 0.5 1 math/inf]

  (filter nil [])
  # =>
  @[]

  (string/from-bytes ;(filter |(< (chr "A") $) "foo01bar"))
  # =>
  "foobar"

  (filter pos?
          (coro
            (for i -3 3
              (yield i))))
  # =>
  @[1 2]

  (->> [0 1 2 3 7 8 9]
       (map |(math/pow $ 2))
       (filter odd?)
       (map math/sqrt))
  # =>
  @[1 3 7 9]

  )
````````
"find-index"
````````
(comment

  (find-index number? [1 2 3])
  # =>
  0

  (find-index string? [0 1 "2r111"])
  # =>
  2

  (find-index keyword?
              [0 "fun" [:x :y] {:a 1}]
              :nothing-here)
  # =>
  :nothing-here

  (find-index (fn gachou [x]
                (= x :goose))
              [:duck :duck :duck :goose])
  # =>
  3

  )
````````
"find"
````````
(comment

  (find number? [1 2 3])
  # =>
  1

  (find string? [0 1 "2r111"])
  # =>
  "2r111"

  (find keyword?
        [0 "fun" [:x :y] {:a 1}]
        :nothing-here)
  # =>
  :nothing-here

  (find (fn gachou [x]
          (= x :goose))
        [:duck :duck :duck :goose])
  # =>
  :goose

  )
````````
"first"
````````
(comment

  (first [:a :b :c])
  # =>
  :a

  (first [])
  # =>
  nil

  (first @[0 1 2])
  # =>
  0

  (first {:a 1 :b 2})
  # =>
  nil

  (first "hello")
  # =>
  (chr "h")

  (first nil)
  # =>
  nil

  (first :hooooo)
  # =>
  (chr "h")

  (first 32767)
  # =>
  nil

  )
````````
"fn"
````````
```
special form

`(fn name? args body...)`

Compile a function literal (closure).

A function literal consists of an optional `name`, an argument list,
and a function `body`.

The optional `name` is allowed so that functions can more easily be
recursive.

The argument list is a tuple of named parameters, and `body` is 0 or
more forms.

The function will evaluate to the last form in `body`. The other forms
will only be evaluated for side effects.

Functions also introduce a new lexical scope, meaning the defs and
vars inside a function `body` will not escape outside the `body`.

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  (function? (fn [] 1))
  # =>
  true

  ((fn [] 1))
  # =>
  1

  ((fn [x] x) ((fn [] 1)))
  # =>
  1

  (do
    (def a
      (fn [] 8))
    (a))
  # =>
  8

  (do
    (def a 9)

    (def b
      (fn [] a))

    (b))
  # =>
  9

  (do
    (def my-caller
      (fn [f]
        (f)))
    (my-caller (fn [] :fun)))
  # =>
  :fun

  )

(comment

  (do
    (var n 3)
    (var b nil)
    (def stack @[])

    (def a
      (fn []
        (if (pos? n)
          (do
            (array/push stack (keyword (string "a-" n)))
            (set n (dec n))
            (b))
          (array/push stack :a-done))))

    (set b
         (fn []
           (if (pos? n)
             (do
               (array/push stack (keyword (string "b-" n)))
               (set n (dec n))
               (a))
             (array/push stack :b-done))))

    (a)

    stack)
  # =>
  @[:a-3 :b-2 :a-1 :b-done]

  )
````````
"for"
````````
(comment

  (do
    (def arr @[])
    (for i 0 7
      (array/push arr (math/pow i 2)))
    arr)
  # =>
  @[0 1 4 9 16 25 36]

  (do
    (def arr @[])
    (for i 0 3
      (for j 0 3
        (array/push arr [i j])))
    arr)
  # =>
  '@[(0 0) (0 1) (0 2)
     (1 0) (1 1) (1 2)
     (2 0) (2 1) (2 2)]

  )
````````
"forever"
````````
(comment

  (do
    (var i 0)
    (forever
      (when (pos? i)
        (break))
      (++ i))
    i)
  # =>
  1

  )
````````
"forv"
````````
(comment

  (do
    (def coll @[])
    (forv i 0 9
      (array/push coll i)
      (+= i 2))
    coll)
  # =>
  @[0 3 6]

  (do
    (def coll @[])
    (forv i 0 9
      (array/push coll i)
      (*= i -2))
    coll)
  # =>
  @[0 1 -1 3 -5]


  )
````````
"function?"
````````
(comment

  (function? inc)
  # =>
  true

  (function? (fn [] :hi))
  # =>
  true

  (function? |(/ $ 3))
  # =>
  true

  (function? |[$ :tagged])
  # =>
  true

  (function? (partial + 2))
  # =>
  true

  (function? (juxt zero? one? even? odd? nan?))
  # =>
  true

  (and (function? defn)
       ((dyn 'defn) :macro))
  # =>
  true

  [(function? print) (cfunction? print)]
  # =>
  [false true]

  (function? (compile '(+ 1 1)))
  # =>
  true

  )
````````
"generate"
````````
(comment

  (do
    (var tot 3)
    (def fib
      (generate [i :iterate (when (pos? (-- tot)) tot)]
        (math/pow i 3)))
    [(resume fib) (resume fib)])
  # =>
  [8 1]

  (do
    (def fib
      (generate [i :range [0 4]]
        (math/pow i 2)))
    (resume fib)
    @[(resume fib)
      (resume fib)
      (resume fib)])
  # =>
  @[1 4 9]

  (do
    (def fib
      (generate [i :range [0 4 2]]
        (* -1 i)))
    (resume fib)
    (resume fib))
  # =>
  -2

  (do
    (def fib
      (generate [i :range-to [8 12]]
        i))
    (resume fib)
    (filter even? fib))
  # =>
  @[10 12]

  (do
    (def fib
      (generate [i :range-to [8 12 2]]
        i))
    (resume fib)
    (resume fib))
  # =>
  10

  (do
    (def fib
      (generate [j :down [10 0]]
        j))
    (resume fib)
    (resume fib)
    (resume fib))
  # =>
  8

  (do
    (def fib
      (generate [j :down [10 0 2]]
        j))
    (resume fib)
    (resume fib))
  # =>
  8

  (do
    (def fib
      (generate [j :down-to [3 -3]]
        j))
    (resume fib)
    (resume fib))
  # =>
  2

  (do
    (def fib
      (generate [j :down-to [3 -3 3]]
        j))
    (resume fib)
    (resume fib))
  # =>
  0

  (do
    (def fib
      (generate [k :keys {:a 1 :b 2}]
        (keyword (string/ascii-upper k))))
    (sort @[(resume fib) (resume fib)]))
  # =>
  @[:A :B]

  (do
    (def fib
      (generate [[k v] :pairs {:a 1 :b 2}]
        [v k]))
    (table ;(resume fib) ;(resume fib)))
  # =>
  @{1 :a
    2 :b}

  (do
    (def fib
      (generate [i :in [0 1 2]]
        (math/pow i 3)))
    (resume fib)
    [(resume fib) (resume fib)])
  # =>
  [1 8]

  (do
    (def fib
      (generate [i :in (fiber/new
                         |(each x (range 3)
                            (yield x)))]
        (math/pow i 3)))
    (resume fib)
    (+ (resume fib) (resume fib)))
  # =>
  9

  (do
    (def fib
      (generate [i :range [-3 3 0.5]
                 :while (not (pos? i))]
        (math/pow i 2)))
    (resume fib)
    [(resume fib) (+ (resume fib) (resume fib))])
  # =>
  [6.25 6.25]

  (do
    (def fib
      (generate [i :range [-3 3 0.5]
                 :until (pos? i)]
        (math/pow i 2)))
    (resume fib)
    [(resume fib) (+ (resume fib) (resume fib))])
  # =>
  [6.25 6.25]

  (do
    (def fib
      (generate [i :range [0 6]
                 :let [c (math/pow i 3)]]
        c))
    (resume fib)
    (+ (resume fib) (resume fib)
       (* 0 (resume fib))
       (resume fib)))
  # =>
  73

  (do
    (def buf @"")
    (def fib
      (generate [i :range [0 3]
                 :before (buffer/push-string buf "!")]
        (string buf)))
    (def [head _ tail]
      [(resume fib) (resume fib) (resume fib)])
    [head tail])
  # =>
  ["!" "!!!"]

  (do
    (def buf @"")
    (def fib
      (generate [i :range [0 3]
                 :after (buffer/push-string buf "!")]
        (string buf)))
    (def [head _ tail]
      [(resume fib) (resume fib) (resume fib)])
    [head tail])
  # =>
  ["" "!!"]

  (do
    (def fib
      (generate [i :range-to [1 3]
                 :repeat i]
        i))
    (repeat 4
      (resume fib))
    (resume fib))
  # =>
  3

  )
````````
"has-key?"
````````
(comment

  (has-key? @{:key1 "foo" :key2 "bar"} :key1)
  # =>
  true

  (has-key? "a" 0)
  # =>
  true

  (has-key? ["a" "b" "c"] 1)
  # =>
  true

  (has-key? @{} 0)
  # =>
  false

  (has-key? @{:key1 "foo" :key2 "bar"} :key3)
  # =>
  false

  (has-key? {} 0)
  # =>
  false

  (has-key? {:key1 "foo" :key2 "bar"} :key1)
  # =>
  true

  (has-key? {:key1 "foo" :key2 "bar"} :key3)
  # =>
  false

  (has-key? "" 0)
  # =>
  false

  (has-key? "a" 1)
  # =>
  false

  (has-key? [] 0)
  # =>
  false

  (has-key? ["a" "b" "c"] 4)
  # =>
  false

  (has-key? @[] 0)
  # =>
  false

  (has-key? @["a" "b" "c"] 1)
  # =>
  true

  (has-key? @["a" "b" "c"] 4)
  # =>
  false

  )
````````
"has-value?"
````````
(comment

  (has-value? @{:key1 "foo" :key2 "bar"} "foo")
  # =>
  true

  (has-value? "abc" 97)
  # =>
  true

  (has-value? ["a" "b" "c"] "a")
  # =>
  true

  (has-value? @{} 0)
  # =>
  false

  (has-value? @{:key1 "foo" :key2 "bar"} "hello")
  # =>
  false

  (has-value? @{:key1 "foo" :key2 "bar"} nil)
  # =>
  false

  (has-value? {} 0)
  # =>
  false

  (has-value? {:key1 "foo" :key2 "bar"} "foo")
  # =>
  true

  (has-value? {:key1 "foo" :key2 "bar"} "hello")
  # =>
  false

  (has-value? {:key1 "foo" :key2 "bar"} nil)
  # =>
  false

  (has-value? "" 0)
  # =>
  false

  (has-value? "" nil)
  # =>
  false

  (has-value? "abc" "a")
  # =>
  false

  (has-value? "abc" 'a)
  # =>
  false

  # tuples
  (has-value? [] 0)
  # =>
  false

  (has-value? ["a" "b" "c"] 'a)
  # =>
  false

  (has-value? ["a" "b" "c"] 97)
  # =>
  false

  (has-value? @[] 0)
  # =>
  false

  (has-value? @["a" "b" "c"] "a")
  # =>
  true

  (has-value? @["a" "b" "c"] 'a)
  # =>
  false

  (has-value? @["a" "b" "c"] 97)
  # =>
  false

  )
````````
"identity"
````````
(comment

  (identity 3)
  # =>
  3

  (nan? (identity math/nan))
  # =>
  true

  (identity math/inf)
  # =>
  math/inf

  (= identity
     (identity identity))
  # =>
  true

  )
````````
"if-let"
````````
(comment

  (if-let [x 1]
    true
    false)
  # =>
  true

  (if-let [x 1]
    true)
  # =>
  true

  (if-let [a (even? 3)]
    a
    false)
  # =>
  false

  (if-let [a (even? 3)]
    a)
  # =>
  nil

  (if-let [a (odd? 3)]
    a
    false)
  # =>
  true

  (if-let [a (odd? 3)]
    a)
  # =>
  true

  (if-let [a (odd? 3)
           b (even? 3)]
    b
    false)
  # =>
  false

  (if-let [a (odd? 3)
           b (even? 3)]
    b)
  # =>
  nil

  (if-let [a (+ 1 6)
           b (- 2 1)]
    (+ a b)
    false)
  # =>
  8

  (if-let [a (+ 1 6)
           b (- 2 1)]
    (+ a b))
  # =>
  8

  )
````````
"if-not"
````````
(comment

  (if-not true
    :then
    :else)
  # =>
  :else

  (if-not false
    :then
    :else)
  # =>
  :then

  )
````````
"if-with"
````````
(comment

  (if-with [f (file/open `/\`)]
    (eprint "Unexpected success")
    :an-ordinary-system)
  # =>
  :an-ordinary-system

  )
````````
"if"
````````
```
special form

`(if condition when-true when-false?)`

Introduce a branching construct.

The first form is the condition, the second form is the form to
evaluate when the condition is `true`, and the optional third form
is the form to evaluate when the condition is `false`. If no third
form is provided it defaults to `nil`.

The `if` special form will not evaluate the `when-true` or
`when-false` forms unless it needs to - it is a lazy form, which is
why it cannot be a function.

The condition is considered `false` only if it evaluates to `nil` or
`false` - all other values are considered `true`.

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  (if true
    1
    2)
  # =>
  1

  (if false
    :green
    :blue)
  # =>
  :blue

  (if (= 1 1) :clever)
  # =>
  :clever

  (if (= 0 1)
    :anything-is-possible
    :nothing-to-see-here)
  # =>
  :nothing-to-see-here

  )
````````
"inc"
````````
(comment

  (do
    (def i 0)
    (inc i))
  # =>
  1

  )
````````
"index-of"
````````
(comment

  (index-of 2 [1 2 3])
  # =>
  1

  (index-of 7 [0 1 2r111])
  # =>
  2

  (index-of :arthur
            [0 "fun" [:x :y] {:a 1}]
            :nothing-here)
  # =>
  :nothing-here

  )
````````
"indexed?"
````````
(comment

  (indexed? @[:a :b])
  # =>
  true

  (indexed? [8 9 11])
  # =>
  true

  (indexed? (freeze @["one" "step" "at" "a"]))
  # =>
  true

  (indexed? (seq [i :range [0 3]]
              (math/pow i 2)))
  # =>
  true

  (indexed? "a string")
  # =>
  false

  (indexed? @"a buffer")
  # =>
  false

  (indexed? :a-keyword)
  # =>
  false

  (indexed? 'a-symbol)
  # =>
  false

  (indexed? nil)
  # =>
  false

  (indexed? @{})
  # =>
  false

  (indexed? {})
  # =>
  false


  )
````````
"interpose"
````````
(comment

  (interpose ", " ["ant" "bee" "cheetah"])
  # =>
  @["ant" ", " "bee" ", " "cheetah"]

  (interpose ":" ["/usr/local/bin" "/usr/bin" "/bin"])
  # =>
  @["/usr/local/bin" ":" "/usr/bin" ":" "/bin"]

  )
````````
"juxt"
````````
(comment

  (function? (juxt inc dec))
  # =>
  true

  ((juxt inc dec zero?) 2)
  # =>
  [3 1 false]

  )
````````
"juxt*"
````````
(comment

  (function? (juxt* inc dec))
  # =>
  true

  ((juxt* inc dec zero?) 2)
  # =>
  [3 1 false]

  )
````````
"keep"
````````
(comment

  (keep identity [false :x nil true])
  # =>
  @[:x true]

  (keep (fn [x] (when (> x 1) x))
        @[0 1 2 3])
  # =>
  @[2 3]

  (keep (fn [x] (when (> x 2) (* x x)))
        [0 1 3 4 5])
  # =>
  @[9 16 25]

  (keep |(when (pos? (+ ;$&)) $0)
        [1 2 3] [-1 1 1])
  # =>
  @[2 3]

  (keep |(when (neg? (+ ;$&)) $0)
        [-1 -2 -3] [-1 1])
  # =>
  @[-1]

  (keep (fn [elt]
          (when (number? elt)
            elt))
        [1 :a "hello" [0 1 2] 0])
  # =>
  @[1 0]

  (keep (fn [elt]
          (when (number? elt)
            (string elt)))
        [1 :a "hello" [0 1 2] 0])
  # =>
  @["1" "0"]

  (keep (fn [elt]
            (when (even? elt)
              (symbol (string "fun-" elt))))
          [2r111 0x08 8r11 10])
  # =>
  '@[fun-8 fun-10]

  (keep (fn [x]
            (when (>= x (math/pow x 2))
              (math/sqrt x)))
          [0 0.5 1 2 6 8 math/inf])
  # =>
  @[0 (math/sqrt 0.5) 1 math/inf]

  (keep nil [])
  # =>
  @[]

  (keep (fn [x]
          (when (pos? x)
            (string x)))
        (coro
          (for i -3 3
            (yield i))))
  # =>
  @["1" "2"]

  (->> [0 1 2 3 7 8 9]
       (map |(math/pow $ 2))
       (keep (fn [x]
               (when (odd? x)
                 (math/sqrt x)))))
  # =>
  @[1 3 7 9]

  )
````````
"keyword?"
````````
(comment

  (keyword? :hello)
  # =>
  true

  (keyword? 'a-symbol)
  # =>
  false

  (keyword? "a string")
  # =>
  false

  )
````````
"label"
````````
(comment

  (label here
    (for i 0 2
      (when (pos? i)
        (return here i))))
  # =>
  1

  (label here
    (def x :unreturned)
    (for i 0 2
      (for j 0 2
        (when (and (pos? i) (pos? j))
          (return here [i j]))))
    x)
  # =>
  [1 1]

  )
````````
"last"
````````
(comment

  (last [:a :b :c])
  # =>
  :c

  (last [])
  # =>
  nil

  (last @[0 1 2])
  # =>
  2

  (last {:a 1 :b 2})
  # =>
  nil

  (last "hello")
  # =>
  (chr "o")

  (->> (try
         (last nil)
         ([e]
           e))
       (string/find "expected")
       truthy?)
  # =>
  true

  (last :hooooo)
  # =>
  (chr "o")

  (->> (try
         (last 32767)
         ([e]
           e))
       (string/find "expected")
       truthy?)
  # =>
  true

  )
````````
"let"
````````
(comment

  (let [x 1]
    x)
  # =>
  1

  (let []
    2)
  # =>
  2

  (let [a (+ 2 3)
        b (inc a)]
    b)
  # =>
  6

  (do
    (var x 1)
    (let [a 1
          _ (set x (inc a))
          b (inc x)]
      b))
  # =>
  3

  )
````````
"loop"
````````
(comment

  (do
    (var tot 3)
    (def arr @[])
    (loop [i :iterate (when (pos? (-- tot)) tot)]
      (array/push arr i))
    arr)
  # =>
  @[2 1]

  (do
    (def arr @[])
    (loop [i :range [0 4]]
      (array/push arr i))
    arr)
  # =>
  @[0 1 2 3]

  (do
    (def arr @[])
    (loop [i :range [0 4 2]]
      (array/push arr i))
    arr)
  # =>
  @[0 2]

  (do
    (def arr @[])
    (loop [i :range-to [8 12]]
      (array/push arr i))
    arr)
  # =>
  @[8 9 10 11 12]

  (do
    (def arr @[])
    (loop [i :range-to [8 12 2]]
      (array/push arr i))
    arr)
  # =>
  @[8 10 12]

  (do
    (def arr @[])
    (loop [j :down [10 0]]
      (array/push arr j))
    arr)
  # =>
  @[10 9 8 7 6 5 4 3 2 1]

  (do
    (def arr @[])
    (loop [j :down [10 0 2]]
      (array/push arr j))
    arr)
  # =>
  @[10 8 6 4 2]

  (do
    (def arr @[])
    (loop [j :down-to [3 -3]]
      (array/push arr j))
    arr)
  # =>
  @[3 2 1 0 -1 -2 -3]

  (do
    (def arr @[])
    (loop [j :down-to [3 -3 3]]
      (array/push arr j))
    arr)
  # =>
  @[3 0 -3]

  (do
    (def arr @[])
    (loop [k :keys {:a 1 :b 2}]
      (array/push arr k))
    (sort arr))
  # =>
  @[:a :b]

  (do
    (def arr @[])
    (loop [[k v] :pairs {:a 1 :b 2}]
      (array/push arr v)
      (array/push arr k))
    (table ;arr))
  # =>
  @{1 :a 2 :b}

  (do
    (def arr @[])
    (def nums [0 1 2])
    (loop [i :in nums]
      (array/push arr (math/pow i 3)))
    (sort arr))
  # =>
  @[0 1 8]

  (do
    (def arr @[])
    (def fib
      (fiber/new
        |(each x (range 3)
           (yield x))))
    (loop [i :in fib]
      (array/push arr (math/pow i 3)))
    arr)
  # =>
  @[0 1 8]

  (do
    (def arr @[])
    (loop [i :range [-3 3 0.5]
           :while (not (pos? i))]
      (array/push arr i))
    arr)
  # =>
  @[-3 -2.5 -2 -1.5 -1 -0.5 0]

  (do
    (def arr @[])
    (loop [i :range [-3 3 0.5]
           :until (pos? i)]
      (array/push arr i))
    arr)
  # =>
  @[-3 -2.5 -2 -1.5 -1 -0.5 0]

  (do
    (def arr @[])
    (loop [i :range [0 6]
           :let [y (math/pow i 3)]]
      (array/push arr y))
    arr)
  # =>
  @[0 1 8 27 64 125]

  (do
    (def arr @[])
    (def buf @"")
    (loop [i :range [0 3]
           :before (buffer/push-string buf "!")]
      (array/push arr (string buf))
      (array/push arr i))
    arr)
  # =>
  @["!" 0 "!!" 1 "!!!" 2]

  (do
    (def arr @[])
    (def buf @"")
    (loop [i :range [0 3]
           :after (buffer/push-string buf "!")]
      (array/push arr (string buf))
      (array/push arr i))
    arr)
  # =>
  @["" 0 "!" 1 "!!" 2]

  (do
    (def arr @[])
    (loop [i :range-to [1 3]
           :repeat i]
      (array/push arr i))
    arr)
  # =>
  @[1 2 2 3 3 3]

  )
````````
"map"
````````
(comment

  (map string [1 2 3])
  # =>
  @["1" "2" "3"]

  (map scan-number ["2r111" "0x08" "8r11" "10"])
  # =>
  @[7 8 9 10]

  (map identity [["alice" 1] ["bob" 2] ["carol" 3]])
  # =>
  @[["alice" 1] ["bob" 2] ["carol" 3]]

  (->> [[:a 1 ":)"] [:b 2 ":("] [:c 3 ":o"]]
       (map (fn [[k _ v]]
              [k v]))
       flatten
       splice
       table)
  # =>
  @{:a ":)"
    :b ":("
    :c ":o"}

  (map array [:x :y] [-1 1])
  # =>
  @[@[:x -1] @[:y 1]]

  (map |(pos? (+ ;$&)) [1 2 3] [-1 -2 -3] [0 1])
  # =>
  @[false true]

  )
````````
"mapcat"
````````
(comment

  (mapcat string [1 2 3])
  # =>
  @["1" "2" "3"]

  (mapcat scan-number ["2r111" "0x08" "8r11" "10"])
  # =>
  @[7 8 9 10]

  (mapcat identity [["alice" 1] ["bob" 2] ["carol" 3]])
  # =>
  @["alice" 1 "bob" 2 "carol" 3]

  (mapcat tuple [:x :y] [-1 1])
  # =>
  @[:x -1 :y 1]

  (mapcat |(tuple $0 $1 $2) [:a :b] [:x :y :z] [0 1])
  # =>
  @[:a :x 0 :b :y 1]

  (->> [[:a 1] [:b 2] [:c 3]]
       (mapcat identity)
       splice
       table)
  # =>
  @{:a 1 :b 2 :c 3}

  )
````````
"max-of"
````````
(comment

  (max-of [-1 -2 -3])
  # =>
  -1

  (max-of [-2 0 3])
  # =>
  3

  (max-of [])
  # =>
  nil

  (max-of [nil 1])
  # =>
  nil

  (max-of [nil math/inf])
  # =>
  nil

  (max-of [nil math/int32-max math/inf])
  # =>
  nil

  (max-of [math/nan nil])
  # =>
  nil

  (nan? (max-of [math/nan math/inf]))
  # =>
  true

  )
````````
"max"
````````
(comment

  (max -1 -2 -3)
  # =>
  -1

  (max -2 0 3)
  # =>
  3

  (max)
  # =>
  nil

  (max nil 1)
  # =>
  nil

  (max nil math/inf)
  # =>
  nil

  (max nil math/int32-max math/inf)
  # =>
  nil

  (max math/nan nil)
  # =>
  nil

  (nan? (max math/nan math/inf))
  # =>
  true

  )
````````
"mean"
````````
(comment

  (mean [1 2 3 4 5])
  # =>
  3

  (nan? (mean []))
  # =>
  true

  (mean (range 0 1001))
  # =>
  500

  (mean {:a 2 :e 6})
  # =>
  4

  )
````````
"min-of"
````````
(comment

  (min-of [-1 -2 -3])
  # =>
  -3

  (min-of [-2 0 3])
  # =>
  -2

  (min-of [])
  # =>
  nil

  (min-of [nil 1])
  # =>
  1

  (min-of [nil math/inf])
  # =>
  math/inf

  (min-of [nil math/int32-max math/inf])
  # =>
  math/int32-max

  (nan? (min-of [math/nan nil]))
  # =>
  true

  (nan? (min-of [math/nan math/inf]))
  # =>
  true

  )
````````
"min"
````````
(comment

  (min -1 -2 -3)
  # =>
  -3

  (min -2 0 3)
  # =>
  -2

  (min)
  # =>
  nil

  (min nil 1)
  # =>
  1

  (min nil math/inf)
  # =>
  math/inf

  (min nil math/int32-max math/inf)
  # =>
  math/int32-max

  (nan? (min math/nan nil))
  # =>
  true

  (nan? (min math/nan math/inf))
  # =>
  true

  )
````````
"nan?"
````````
(comment

  (nan? math/nan)
  # =>
  true

  (nan? (/ 0 0))
  # =>
  true

  (nan? (inc math/nan))
  # =>
  true

  (nan? (dec math/nan))
  # =>
  true

  (nan? (/ math/nan math/nan))
  # =>
  true

  (nan? (* 0 math/nan))
  # =>
  true

  (nan? nil)
  # =>
  false

  )
````````
"neg?"
````````
(comment

  (neg? 0)
  # =>
  false

  (neg? -1)
  # =>
  true

  (neg? 1)
  # =>
  false

  (neg? math/inf)
  # =>
  false

  (neg? math/-inf)
  # =>
  true

  (neg? math/nan)
  # =>
  false

  (do
    (defn a-cmp
      [x y]
      (let [x-val (or (get x :value) x)
            y-val (or (get y :value) y)]
        (cond
          (< x-val y-val) -1
          (= x-val y-val) 0
          (> x-val y-val) 1)))
  (neg? {:compare a-cmp :value -1}))
  # =>
  true

  )
````````
"number?"
````````
(comment

  (number? 1)
  # =>
  true

  (number? 2.0)
  # =>
  true

  (number? 2e-1)
  # =>
  true

  (number? 0xF_F__F___F____)
  # =>
  true

  (number? 3r01&02)
  # =>
  true

  (number? 2r0101010001)
  # =>
  true

  (number? 2_3_1__._1_2_e-1)
  # =>
  true

  (number? 0x09.1F)
  # =>
  true

  (number? 1_3__0890__100__)
  # =>
  true

  (number? 0x0_9_.1_f__)
  # =>
  true

  (number? -0xFF)
  # =>
  true

  (number? -36r20)
  # =>
  true

  (number? 1E9)
  # =>
  true

  (number? -2.71828)
  # =>
  true

  (number? 0xaB)
  # =>
  true

  (number? 3e8)
  # =>
  true

  (number? math/nan)
  # =>
  true

  (number? (/ 0 0))
  # =>
  true

  (number? (inc math/nan))
  # =>
  true

  (number? (dec math/nan))
  # =>
  true

  (number? (/ math/nan math/nan))
  # =>
  true

  (number? (* 0 math/nan))
  # =>
  true

  (number? nil)
  # =>
  false

  )
````````
"odd?"
````````
(comment

  (odd? 0)
  # =>
  false

  (odd? 1)
  # =>
  true

  (odd? 3.0)
  # =>
  true

  (do
    (defn a-cmp
      [x y]
      (let [x-val (or (get x :value) x)
            y-val (or (get y :value) y)]
        (cond
          (< x-val y-val) -1
          (= x-val y-val) 0
          (> x-val y-val) 1)))
    (defn a-mod
      [x y]
      (let [x-val (or (get x :value) x)
            y-val (or (get y :value) y)]
        (mod x-val y-val)))
    (odd? {:compare a-cmp :mod a-mod :value -3}))
  # =>
  true

  )
````````
"one?"
````````
(comment

  (one? 0)
  # =>
  false

  (one? 1)
  # =>
  true

  (one? 1.0)
  # =>
  true

  (do
    (defn a-cmp
      [x y]
      (let [x-val (or (get x :value) x)
            y-val (or (get y :value) y)]
        (cond
          (< x-val y-val) -1
          (= x-val y-val) 0
          (> x-val y-val) 1)))
    (one? {:compare a-cmp :value 1}))
  # =>
  true

  )
````````
"or"
````````
(comment

  (or)
  # =>
  nil

  (or 1)
  # =>
  1

  (or nil 1)
  # =>
  1

  (or nil (/ 2 1) false)
  # =>
  2

  (or false false false nil)
  # =>
  nil

  )
````````
"os/strftime"
````````
(comment

  (os/strftime "%a" 0)
  # =>
  "Thu"

  (os/strftime "%A" 0)
  # =>
  "Thursday"

  (os/strftime "%b" 0)
  # =>
  "Jan"

  (os/strftime "%B" 0)
  # =>
  "January"

  (os/strftime "%c" 0)
  # =>
  "Thu Jan  1 00:00:00 1970"

  (os/strftime "%d" 0)
  # =>
  "01"

  (os/strftime "%H" 0)
  # =>
  "00"

  (os/strftime "%I" 0)
  # =>
  "12"

  (os/strftime "%j" 0)
  # =>
  "001"

  (os/strftime "%m" 0)
  # =>
  "01"

  (os/strftime "%M" 0)
  # =>
  "00"

  (os/strftime "%p" 0)
  # =>
  "AM"

  (os/strftime "%S" 0)
  # =>
  "00"

  (os/strftime "%U" 0)
  # =>
  "00"

  (os/strftime "%w" 0)
  # =>
  "4"

  (os/strftime "%W" 0)
  # =>
  "00"

  (os/strftime "%x" 0)
  # =>
  "01/01/70"

  (os/strftime "%X" 0)
  # =>
  "00:00:00"

  (os/strftime "%y" 0)
  # =>
  "70"

  (os/strftime "%Y" 0)
  # =>
  "1970"

  (os/strftime "%%")
  # =>
  "%"

  )

#  (os/strftime "%Z" 0)
#  "GMT"

```
  Some conversion specifications can be modified by preceding the conver
  sion specifier character by the E or O modifier to indicate that an al
  ternative format should be used.  If the alternative format or specifi
  cation  does  not exist for the current locale, the behavior will be as
  if the unmodified conversion specification were used. (SU)  The  Single
  UNIX  Specification  mentions  %Ec,  %EC, %Ex, %EX, %Ey, %EY, %Od, %Oe,
  %OH, %OI, %Om, %OM, %OS, %Ou, %OU, %OV, %Ow, %OW, %Oy, where the effect
  of the O modifier is to use alternative numeric symbols (say, roman nu
  merals), and that of the E modifier is to use a locale-dependent alter
  native  representation.   The  rules governing date representation with
  the E modifier can be obtained by supplying ERA as  an  argument  to  a
  nl_langinfo(3).   One example of such alternative forms is the Japanese
  era calendar scheme in the ja_JP glibc locale.
```

#  (os/strftime "%E" 0)
#  "%E"

#  (os/strftime "%O")
#  "%O"

#  (os/strftime "%+")
#  "%+"
````````
"pos?"
````````
(comment

  (pos? 0)
  # =>
  false

  (pos? -1)
  # =>
  false

  (pos? 1)
  # =>
  true

  (pos? math/inf)
  # =>
  true

  (pos? math/-inf)
  # =>
  false

  (pos? math/nan)
  # =>
  true

  (do
    (defn a-cmp
      [x y]
      (let [x-val (or (get x :value) x)
            y-val (or (get y :value) y)]
        (cond
          (< x-val y-val) -1
          (= x-val y-val) 0
          (> x-val y-val) 1)))
  (pos? {:compare a-cmp :value 1}))
  # =>
  true

  )
````````
"product"
````````
(comment

  (product [1 2 3])
  # =>
  6

  (product [])
  # =>
  1

  (product (range 1 (inc 3)))
  # =>
  6

  (product {:a 2 :e 6})
  # =>
  12

  (product "hello")
  # =>
  13599570816

  )
````````
"prompt"
````````
(comment

  (prompt :fun
    (for i 0 2
      (when (pos? i)
        (return :fun i))))
  # =>
  1

  (prompt :here
    (for i 0 2
      (for j 0 2
        (when (and (pos? i) (pos? j))
          (return :here [i j])))))
  # =>
  [1 1]

  (do
    (defn l
      []
      (return :label :left))

    (defn r
      []
      (return :label :right))

    (defn m
      []
      (if true
        (l)
        (r))
      :never-reached)

    (prompt :label
      (m)))
  # =>
  :left

  )
````````
"protect"
````````
(comment

  (protect (+ 1 1))
  # =>
  [true 2]

  (protect (error "oops"))
  # =>
  [false "oops"]

  )
````````
"quasiquote"
````````
```
special form

`(quasiquote x)`

Similar to `(quote x)`, but allows for unquoting within `x`.

This makes `quasiquote` useful for writing macros, as a macro
definition often generates a lot of templated code with a few custom
values.

The shorthand for `quasiquote` is a leading tilde `~` before a form.
So `(quasiquote x)` is equivalent to `~x`.

Within that form, `(unquote x)` will evaluate and insert `x` into the
`unquote` form.

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  ~x
  # =>
  'x

  (quasiquote x)
  # =>
  'x

  (do
    (def a 1)
    (quasiquote (unquote a)))
  # =>
  1

  ~{:main (sequence "a" "b")}
  # =>
  '{:main (sequence "a" "b")}

  (do
    (def a 1)
    ~{:main (choice "a" ,a)})
  # =>
  '{:main (choice "a" 1)}

  )
````````
"quote"
````````
```
special form

`(quote x)`

Evaluates to the literal value of the first argument.

The argument is not compiled and is simply used as a constant value in
the compiled code.

Preceding a form with a single quote is shorthand for `(quote form)`.
Thus `'form` and `(quote form)` are equivalent.

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  (quote x)
  # =>
  'x

  'x
  # =>
  'x

  '(:a :b :c)
  # =>
  '(:a :b :c)

  (quote (+ 1 1))
  # =>
  '(+ 1 1)

  )
````````
"range"
````````
(comment

  (range 10)
  # =>
  @[0 1 2 3 4 5 6 7 8 9]

  (range 0 3)
  # =>
  @[0 1 2]

  (range -1 2)
  # =>
  @[-1 0 1]

  (range 0 9 3)
  # =>
  @[0 3 6]

  (range 9 0 -3)
  # =>
  @[9 6 3]

  (range 0 0)
  # =>
  @[]

  (range 0 -10)
  # =>
  @[]

  )
````````
"reduce"
````````
(comment

  (reduce + 0 [1 2 3])
  # =>
  6

  (reduce (fn [x y]
            (if (not (empty? x))
              (string x ", " y)
              y))
          ""
          [:ant :bee :cheetah])
  # =>
  "ant, bee, cheetah"

  (reduce nil nil [])
  # =>
  nil

  (reduce nil :garuda [])
  # =>
  :garuda

  )
````````
"repeat"
````````
(comment

  (do
    (def arr @[])
    (var i 0)
    (repeat 3
      (array/push arr i)
      (++ i))
    arr)
  # =>
  @[0 1 2]

  )
````````
"return"
````````
(comment

  (prompt :there
    (for i 0 2
      (for j 0 2
        (when (and (pos? i) (pos? j))
          (return :there [i j])))))
  # =>
  [1 1]

  (label there
    (def z :not-returned)
    (for i 0 2
      (for j 0 2
        (when (and (pos? i) (pos? j))
          (return there [i j]))))
    z)
  # =>
  [1 1]

  )
````````
"reverse"
````````
(comment

  (reverse [1 2 3]) 
  # => 
  @[3 2 1]

  (reverse "abcdef") 
  # => 
  @"fedcba"

  )
````````
"seq"
````````
(comment

  (do
    (var tot 3)
    (seq [i :iterate (when (pos? (-- tot)) tot)]
      i))
  # =>
  @[2 1]

  (seq [i :range [0 4]]
    i)
  # =>
  @[0 1 2 3]

  (seq [i :range [0 4 2]]
    i)
  # =>
  @[0 2]

  (seq [i :range-to [8 12]]
    i)
  # =>
  @[8 9 10 11 12]

  (seq [i :range-to [8 12 2]]
    i)
  # =>
  @[8 10 12]

  (seq [j :down [10 0]]
    j)
  # =>
  @[10 9 8 7 6 5 4 3 2 1]

  (seq [j :down [10 0 2]]
    j)
  # =>
  @[10 8 6 4 2]

  (seq [j :down-to [3 -3]]
    j)
  # =>
  @[3 2 1 0 -1 -2 -3]

  (seq [j :down-to [3 -3 3]]
    j)
  # =>
  @[3 0 -3]

  (sort
    (seq [k :keys {:a 1 :b 2}]
      k))
  # =>
  @[:a :b]

  (sort
    (seq [[k v] :pairs {:a 1 :b 2}]
      [v k]))
  # =>
  @[[1 :a] [2 :b]]

  (seq [i :in [0 1 2]]
    (math/pow i 3))
  # =>
  @[0 1 8]

  (seq [i :in (fiber/new
                |(each x (range 3)
                   (yield x)))]
    (math/pow i 3))
  # =>
  @[0 1 8]

  (seq [i :range [-3 3 0.5]
        :while (not (pos? i))]
    i)
  # =>
  @[-3 -2.5 -2 -1.5 -1 -0.5 0]

  (seq [i :range [-3 3 0.5]
        :until (pos? i)]
    i)
  # =>
  @[-3 -2.5 -2 -1.5 -1 -0.5 0]

  (seq [i :range [0 6]
        :let [y (math/pow i 3)]]
    y)
  # =>
  @[0 1 8 27 64 125]

  (do
    (def buf @"")
    (flatten
      (seq [i :range [0 3]
            :before (buffer/push-string buf "!")]
        [(string buf) i])))
  # =>
  @["!" 0 "!!" 1 "!!!" 2]

  (do
    (def buf @"")
    (flatten
      (seq [i :range [0 3]
            :after (buffer/push-string buf "!")]
        [(string buf) i])))
  # =>
  @["" 0 "!" 1 "!!" 2]

  (seq [i :range-to [1 3]
        :repeat i]
    i)
  # =>
  @[1 2 2 3 3 3]

  )
````````
"set"
````````
```
special form

`(set l-value r-value)`

Update the value of the var `l-value` with the new `r-value`.

The `set` special form will then evaluate to `r-value`.

The `r-value` can be any expression, and the `l-value` should be a
bound var or a pair of a data structure and key. This allows `set` to
behave like `setf` or `setq` in Common Lisp.

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  (do
    (var x 1)
    (set x 2))
  # =>
  2

  (do
    (set (@{:a 1} :a)
         3))
  # =>
  3

  (do
    (def tbl @{:x 8})
    (set (tbl :x)
         9)
    tbl)
  # =>
  @{:x 9}

  (do
    (def arr @[0 1])
    (set (arr 1)
         3)
    arr)
  # =>
  @[0 3]

  (do
    (def buf @"hello")
    (set (buf 1)
         (chr "a"))
    buf)
  # =>
  @"hallo"

  )
````````
"short-fn"
````````
(comment

  ((fn [n] (+ n n)) 10)
  # =>
  20

  ((short-fn (+ $ $)) 10)
  # =>
  20

  (|(+ $ $) 10)
  # =>
  20

  (|(+ $0 $0) 10)
  # =>
  20

  (|(string $0 $1) "hi" "ho")
  # =>
  "hiho"

  (|(apply + $&) 1 2 3)
  # =>
  6

  (|{:a 1})
  # =>
  {:a 1}

  (|(= $ 1) 1)
  # =>
  true

  (|[1 2])
  # =>
  [1 2]

  (|@[8 9])
  # =>
  @[8 9]

  (|@(:fun :time))
  # =>
  @[:fun :time]

  (|{:a 1})
  # =>
  {:a 1}

  (|@{:pose :sit})
  # =>
  @{:pose :sit}

  (|'(0))
  # =>
  [0]

  (|~(:x))
  # =>
  [:x]

  (|:kwd)
  # =>
  :kwd

  (let [a-sym 1]
    (|a-sym))
  # =>
  1

  (|"a-str")
  # =>
  "a-str"

  (|@"buffer")
  # =>
  @"buffer"

  (|``long-string``)
  # =>
  "long-string"

  (|@``long-buffer``)
  # =>
  @"long-buffer"

  (|false)
  # =>
  false

  (|nil)
  # =>
  nil

  (|8)
  # =>
  8

  ((||8))
  # =>
  8

  (((|||8)))
  # =>
  8

  (|())
  # =>
  []

  )
````````
"slice"
````````
(comment

  (slice @[1 2 3])
  # =>
  [1 2 3]

  (slice @[:a :b :c] 1)
  # =>
  [:b :c]

  (slice [:a :b :c :d :e] 2 4)
  # =>
  [:c :d]

  (slice [:a :b :c :d :e] 2 -1)
  # =>
  [:c :d :e]

  (slice [:a :b :c :d :e] 2 -2)
  # =>
  [:c :d]

  (slice [:a :b :c :d :e] 2 -4)
  # =>
  []

  (def [ok? value]
    (-> (slice [:a :b :c :d :e] 2 -10)
        protect))
  # =>
  [false "end index -10 out of range [-6,5]"]

  (slice "abcdefg" 0 2)
  # =>
  "ab"

  (slice @"abcdefg" 0 2)
  # =>
  "ab"

  (slice :hallo 0 2)
  # =>
  "ha"

  (slice 'marshmallow 0 5)
  # =>
  "marsh"

  )
````````
"some"
````````
(comment

  (some pos? [math/-inf 0])
  # =>
  nil

  (some (fn [x] (when (pos? x) x)) [1 0 -1])
  # =>
  1

  (some pos? [])
  # =>
  nil

  (some (fn [x y] (neg? (* x y))) [1 1] [1 -2])
  # =>
  true

  (some |(zero? (* $0 $1 $2)) [1 2] [7 8] [-2 -1 0])
  # =>
  nil

  (some |(pos? (+ $0 $1 $2)) [1 2 3] [7 8 9] [])
  # =>
  nil

  )
````````
"sort-by"
````````
(comment

  (do
    (def arr @[2 0 1])
    (sort-by - arr)
    arr)
  # =>
  @[2 1 0]

  (do
    (def arr @[-2 0 -1])
    (sort-by math/abs arr)
    arr)
  # =>
  @[0 -1 -2]

  (do
    (def arr @[[:fun 0] [:swim 2] [:play -1]])
    (sort-by |(get $ 1) arr)
    arr)
  # =>
  '@[(:play -1) (:fun 0) (:swim 2)]

  )
````````
"sort"
````````
(comment

  (do
    (def arr @[2 0 1])
    (sort arr)
    arr)
  # =>
  @[0 1 2]

  (do
    (def arr @[2 0 1])
    (sort arr >)
    arr)
  # =>
  @[2 1 0]

  (do
    (def arr @[[:fun 0] [:swim 2] [:play -1]])
    (sort arr (fn [[_ x] [_ y]]
                (< x y)))
    arr)
  # =>
  '@[(:play -1) (:fun 0) (:swim 2)]

  )
````````
"sorted"
````````
(comment

  (do
    (def arr @[2 0 1])
    [(sorted arr) arr])
  # =>
  [@[0 1 2] @[2 0 1]]

  (do
    (def arr @[2 0 1])
    [(sorted arr >) arr])
  # =>
  [@[2 1 0] @[2 0 1]]

  (do
    (def arr @[[:fun 0] [:swim 2] [:play -1]])
    [(sorted arr (fn [[_ x] [_ y]]
                  (< x y)))
     arr])
  # =>
  '(@[(:play -1) (:fun 0) (:swim 2)]
     @[(:fun 0) (:swim 2) (:play -1)])

  )
````````
"splice"
````````
```
special form

`(splice x)`

The `splice` special form is an interesting form that allows an array
or tuple to be put into another form inline.

It only has an effect in two places - as an argument in a function
call or literal constructor, or as the argument to the `unquote` form.

Outside of these two settings, the `splice` special form simply
evaluates directly to its argument `x`.

The shorthand for `splice` is prefixing a form with a semicolon.  So
`(splice form)` is equivalent to `;form`.

The `splice` special form has no effect on the behavior of other
special forms, except as an argument to `unquote`.

In the context of a function call, `splice` will insert the contents
of `x` in the parameter list.

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  (+ (splice [1 2 3]))
  # =>
  6

  (* ;[1 2 3])
  # =>
  6

  )
````````
"string?"
````````
(comment

  (string? "hello")
  # =>
  true

  (string?
    ``
    even long-strings
    are strings
    ``)
  # =>
  true

  (string? @"")
  # =>
  false

  (string? (string @"hi"))
  # =>
  true

  )
````````
"string/split"
````````
(comment

  (string/split " " "hello there friend")
  # =>
  @["hello" "there" "friend"]

  (string/split "," "ant,bee,fox,elephant")
  # =>
  @["ant" "bee" "fox" "elephant"]

  (string/split "," "ant,bee,fox,elephant" 7)
  # =>
  @["ant,bee" "fox" "elephant"]

  (string/split "," "ant,bee,fox,elephant" 7 2)
  # =>
  @["ant,bee" "fox,elephant"]

  )
````````
"string/trim"
````````
(comment

  (string/trim "  foo ")
  # =>
  "foo"

  (string/trim "\t bar\n\r\f")
  # =>
  "bar"

  (string/trim "_.foo_bar. \n" " ._\n")
  # =>
  "foo_bar"

  )
````````
"string/triml"
````````
(comment

  (string/triml "  foo ")
  # =>
  "foo "

  (string/triml "\t bar\n\r\f")
  # =>
  "bar\n\r\f"

  (string/triml "_.foo_bar. \n" " ._\n")
  # =>
  "foo_bar. \n"

  )
````````
"string/trimr"
````````
(comment

  (string/trimr "  foo ")
  # =>
  "  foo"

  (string/trimr "\t bar\n\r\f")
  # =>
  "\t bar"

  (string/trimr "_.foo_bar. \n" " ._\n")
  # =>
  "_.foo_bar"

  )
````````
"struct?"
````````
(comment

  (struct? {:animal "penguin"
            :drink "green tea"})
  # =>
  true

  (struct? @{:x 640 :y 480})
  # =>
  false

  (struct? (freeze @{:x 1080 :y 720}))
  # =>
  true

  (struct? (table/to-struct @{:a 1 :b 2}))
  # =>
  true

  )
````````
"sum"
````````
(comment

  (sum [])
  # =>
  0

  (sum [1 2])
  # =>
  3

  (sum @[1])
  # =>
  1

  (sum (range 1 100))
  # =>
  4950

  (sum @{:a 2 :e 6})
  # =>
  8

  (sum {:a 1 :b 2 :c 4})
  # =>
  7

  )
````````
"symbol?"
````````
(comment

  (symbol? 'print)
  # =>
  true

  (symbol? (symbol "my-sym"))
  # =>
  true

  (symbol? '*out*)
  # =>
  true

  (symbol? :keyword)
  # =>
  false

  (symbol? "i am a string")
  # =>
  false

  )
````````
"table?"
````````
(comment

  (table? @{:x 640 :y 480})
  # =>
  true

  (table? {:animal "penguin"
           :drink "green tea"})
  # =>
  false

  (table? (from-pairs [:color "yellow"
                       :shape "star"]))
  # =>
  true

  (table? (struct/to-table {:a 1 :b 2}))
  # =>
  true

  (table? (tabseq [i :range-to [0 3]]
            i (math/pow i 3)))
  # =>
  true

  )
````````
"tabseq"
````````
(comment

  (do
    (var tot 3)
    (tabseq [i :iterate (when (pos? (-- tot)) tot)]
      i (math/pow i 3)))
  # =>
  @{1 1
    2 8}

  (tabseq [i :range [0 4]]
    i (math/pow i 2))
  # =>
  @{0 0
    1 1
    2 4
    3 9}

  (tabseq [i :range [0 4 2]]
    i (* -1 i))
  # =>
  @{0 0
    2 -2}

  (tabseq [i :range-to [8 12]]
    i (even? i))
  # =>
  @{8 true
    9 false
    10 true
    11 false
    12 true}

  (tabseq [i :range-to [8 12 2]]
    i (even? i))
  # =>
  @{8 true
    10 true
    12 true}

  (tabseq [j :down [10 0]]
    (even? j) j)
  # =>
  @{false 1
    true 2}

  (tabseq [j :down [10 0 2]]
    (even? j) j)
  # =>
  @{true 2}

  (tabseq [j :down-to [3 -3]]
    (pos? j) j)
  # =>
  @{false -3
    true 1}

  (tabseq [j :down-to [3 -3 3]]
    (pos? j) j)
  # =>
  @{false -3
    true 3}

  (tabseq [k :keys {:a 1 :b 2}]
    k (keyword (string/ascii-upper k)))
  # =>
  @{:a :A
    :b :B}

  (tabseq [[k v] :pairs {:a 1 :b 2}]
    v k)
  # =>
  @{1 :a
    2 :b}

  (tabseq [i :in [0 1 2]]
    i (math/pow i 3))
  # =>
  @{0 0
    1 1
    2 8}

  (tabseq [i :in (fiber/new
                   |(each x (range 3)
                      (yield x)))]
    i (math/pow i 3))
  # =>
  @{0 0
    1 1
    2 8}

  (tabseq [i :range [-3 3 0.5]
           :while (not (pos? i))]
    i (math/pow i 2))
  # =>
  @{-3   9
    -2.5 6.25
    -2   4
    -1.5 2.25
    -1   1
    -0.5 0.25
    -0   0}

  (tabseq [i :range [-3 3 0.5]
           :until (pos? i)]
    i (math/pow i 2))
  # =>
  @{-3   9
    -2.5 6.25
    -2   4
    -1.5 2.25
    -1   1
    -0.5 0.25
    -0   0}

  (tabseq [i :range [0 6]
           :let [c (math/pow i 3)]]
    i c)
  # =>
  @{0 0
    1 1
    2 8
    3 27
    4 64
    5 125}

  (do
    (def buf @"")
    (tabseq [i :range [0 3]
             :before (buffer/push-string buf "!")]
      i (string buf)))
  # =>
  @{0 "!"
    1 "!!"
    2 "!!!"}

  (do
    (def buf @"")
    (tabseq [i :range [0 3]
             :after (buffer/push-string buf "!")]
      i (string buf)))
  # =>
  @{0 ""
    1 "!"
    2 "!!"}

  (tabseq [i :range-to [1 3]
           :repeat i]
    (even? i) i)
  # =>
  @{false 3
    true 2}

  )
````````
"take-until"
````````
(comment

  (take-until even? [-1 1 3 8])
  # =>
  [-1 1 3]

  (take-until odd? @[2 6 8 12 13])
  # =>
  [2 6 8 12]

  (take-until odd? "zzzzz!")
  # =>
  "zzzzz"

  (take-until even? @"ooooooh")
  # =>
  "oooooo"

  (take-until even? 'my-symbol)
  # =>
  "my-sym"

  (take-until even? 'my-keyword)
  # =>
  "my-keywo"

  (take-until number? (coro
                        (each elt [:a "fun" @"thing" 0]
                          (yield elt))))
  # =>
  @[:a "fun" @"thing"]

  (take-until nil [])
  # =>
  []


  )
````````
"take-while"
````````
(comment

  (take-while even? [2 6 8 -1])
  # =>
  [2 6 8]

  (take-while odd? @[1 3 7 9 12])
  # =>
  [1 3 7 9]

  (take-while odd? "!zzzzz")
  # =>
  "!"

  (take-while even? @"hhhhha")
  # =>
  "hhhhh"

  (take-while odd? 'my-symbol)
  # =>
  "my-sym"

  (take-while odd? 'my-keyword)
  # =>
  "my-keywo"

  (take-while number? (coro
                        (each elt [1 2 3 :boo!]
                          (yield elt))))
  # =>
  @[1 2 3]

  (take-while nil [])
  # =>
  []


  )
````````
"take"
````````
(comment

  (take 2 [0 1 2 3])
  # =>
  [0 1]

  (take 3 (range -3 0))
  # =>
  [-3 -2 -1]

  (take 2 "hiya")
  # =>
  "hi"

  (take 3 (coro
            (each i (range 10)
              (yield i))))
  # =>
  @[0 1 2]

  (take 0 "hiya")
  # =>
  ""

  (take 0 (range 100))
  # =>
  []

  (take 0 (coro (yield :a)))
  # =>
  @[]

  )
````````
"toggle"
````````
(comment

  (do
    (var a true)
    (toggle a))
  # =>
  false

  (do
    (var b false)
    (toggle b))
  # =>
  true

  (do
    (var c nil)
    (toggle c))
  # =>
  true

  (do
    (var x 1)
    (toggle x))
  # =>
  false

  )
````````
"try"
````````
(comment

  (try
    :success
    ([_]
      nil))
  # =>
  :success

  (try
    (error "ouch")
    ([err]
      err))
  # =>
  "ouch"

  (try
    (error "extra")
    ([_ fib]
      (type fib)))
  # =>
  :fiber

  )
````````
"tuple?"
````````
(comment

  (tuple? [:a :b])
  # =>
  true

  (tuple? '(:x :y :z))
  # =>
  true

  (tuple? (freeze @[:ant :bee]))
  # =>
  true

  (tuple? (drop 1 [-1 0 1]))
  # =>
  true

  (tuple? (drop-until even? [-1 1 3 8]))
  # =>
  true

  (tuple? (drop-while odd? [-1 1 3 8]))
  # =>
  true

  (tuple? (take 2 @[-2 -1 0]))
  # =>
  true

  (tuple? (take-until even? [-3 -1 0]))
  # =>
  true

  (tuple? (take-while odd? [-5 -3 -1 8]))
  # =>
  true

  (tuple? (protect (error :hey)))
  # =>
  true

  (tuple? (string/bytes "smile"))
  # =>
  true

  (tuple? (-> (disasm (fn [] :a))
              (get :bytecode)
              first))
  # =>
  true

  (tuple? @[])
  # =>
  false

  (tuple? @())
  # =>
  false

  )
````````
"type"
````````
(comment

  (type nil)
  # =>
  :nil

  (type true)
  # =>
  :boolean

  (type false)
  # =>
  :boolean

  (type 1)
  # =>
  :number

  (type :key)
  # =>
  :keyword

  (type (int/s64 "100"))
  # =>
  :core/s64

  )
````````
"unless"
````````
(comment

  (unless false
    :was-in-unless)
  # =>
  :was-in-unless

  (unless true
    :unrevealed-mystery)
  # =>
  nil

  )
````````
"unquote"
````````
```
special form

`(unquote x)`

Unquote a form within a `quasiquote`. Outside of a `quasiquote`,
`unquote` is invalid.

The shorthand for `(unquote x)` is `,x`.

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  (do
    (def a 1)
    (quasiquote (unquote a)))
  # =>
  1

  (do
    (def b 2)
    ~,b)
  # =>
  2

  )
````````
"upscope"
````````
```
special form

`(upscope & body)`

Similar to `do`, `upscope` evaluates a number of forms in sequence and
evaluates to the result of the last form.

However, `upscope` does not create a new lexical scope, which means
that bindings created inside it are visible in the scope where
`upscope` is declared. This is useful for writing macros that make
several `def` and `var` declarations at once.

In general, use this macro as a last resort. There are other, often
better ways to do this, including using destructuring.

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  (do
    (def a 1)
    (upscope
      (def a 2))
    a)
  # =>
  2

  )
````````
"var"
````````
```
special form

`(var name meta... value)`

`var` binds a value to a symbol.

The symbol can be substituted for the value in subsequent expressions
for the same result.

A binding made by `var` can be updated using `set`.

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  (do
    (var a 1)
    a)
  # =>
  1

  (do
    (var a 1)
    (var a 2)
    a)
  # =>
  2

  (do
    (var a 1)
    (set a 3)
    a)
  # =>
  3

  (do
    (var a 1)
    (do
      (var a 2))
    a)
  # =>
  1

  (do
    (var [a b]
      [1 2])
    a)
  # =>
  1

  (do
    (var [x y & rest]
      [1 2 3 8 9])
    rest)
  # =>
  '(3 8 9)

  (do
    (var {:a a
          :b b}
      (table :a 1
             :b 2))
    b)
  # =>
  2

  )
````````
"when-let"
````````
(comment

  (when-let [x 1]
    true)
  # =>
  true

  (when-let [a (even? 3)]
    a)
  # =>
  nil

  (when-let [a (odd? 3)]
    a)
  # =>
  true

  (when-let [a (odd? 3)
             b (even? 3)]
    b)
  # =>
  nil

  (when-let [a (+ 1 6)
             b (- 2 1)]
    (+ a b))
  # =>
  8

  )
````````
"when-with"
````````
(comment

  (when-with [f (file/open `/\`)]
    :mysterious-setup)
  # =>
  nil


  )
````````
"when"
````````
(comment

  (when true
    :fun)
  # =>
  :fun

  (when false
    :i-am-invisible)
  # =>
  nil

  )
````````
"while"
````````
```
special form

`(while condition body...)`

The `while` special form compiles to a C-like while loop.

The `body` of the form will be continuously evaluated until the
condition is `false` or `nil`.  Therefore, it is expected that the
`body` will contain some side effects or the loop will go on forever.

The `while` loop always evaluates to `nil`.

For further info, see:

  https://janet-lang.org/docs/specials.html
```

(comment

  (while true
    (break))
  # =>
  nil

  (do
    (var i 3)
    (while (pos? i)
      (-- i)))
  # =>
  nil

  )
````````
"with-syms"
````````
(comment

  (eval (with-syms [$my-sym]
          ~(do
             (def ,$my-sym 1)
             ,$my-sym)))
  # =>
  1

  (eval (with-syms [$my-a $my-i]
          ~(do
             (def ,$my-a @[])
             (for ,$my-i 0 2
               (array/push ,$my-a ,$my-i))
             ,$my-a)))
  # =>
  @[0 1]

  )
````````
"with"
````````
(comment

  (do
    (def closed-file
      (with [f (file/temp)]
        (file/write f "a")))
    (->> (try
           (file/read closed-file :all)
           ([e]
             e))
         (string/find "file is closed")
         truthy?))
  # =>
  true

  (do
    (def source @[:a :b :c])
    (with [arr
           source
           array/clear]
      (array/push arr :x))
    (empty? source))
  # =>
  true

  )
````````
"zero?"
````````
(comment

  (zero? 0)
  # =>
  true

  (zero? -0)
  # =>
  true

  (zero? 0.0)
  # =>
  true

  (zero? math/nan)
  # =>
  false

  (zero? math/inf)
  # =>
  false

  (do
    (defn a-cmp
      [x y]
      (let [x-val (or (get x :value) x)
            y-val (or (get y :value) y)]
        (cond
          (< x-val y-val) -1
          (= x-val y-val) 0
          (> x-val y-val) 1)))
    (zero? {:compare a-cmp :value 0}))
  # =>
  true

  )
````````
  })


# wanted an escaping scheme that satisfied the following constraints:
#
# * works with janet symbols
# * works with windows and *nix
# * can be easily adapted for use in urls
# * relatively readable / typable
# * relatively brief
#
# result was:
#
# * use square brackets to surround abbreviated character entity ref names
# * thus:
#   * / -> [sol]
#   * < -> [lt]
#   * > -> [gt]
#   * * -> [ast]
#   * % -> [per]
#   * : -> [col]
#   * ? -> [que]
(def things/sym-char-escapes
  {"/" "sol"
   "<" "lt"
   ">" "gt"
   "*" "ast"
   "%" "per"
   ":" "col"
   "?" "que"})

(defn things/escape-sym-name
  [sym-name]
  (def esc-grammar
    (peg/compile
      ~(accumulate
         (some
           (choice (replace (capture (set "/<>*%:?"))
                            ,(fn [char-str]
                               (string "["
                                       (get things/sym-char-escapes char-str)
                                       "]")))
                   (capture 1))))))
  (first (peg/match esc-grammar sym-name)))

(comment

  (things/escape-sym-name "string/replace")
  # =>
  "string[sol]replace"

  (things/escape-sym-name "<")
  # =>
  "[lt]"

  (things/escape-sym-name "->")
  # =>
  "-[gt]"

  (things/escape-sym-name "import*")
  # =>
  "import[ast]"

  (things/escape-sym-name "%=")
  # =>
  "[per]="

  (things/escape-sym-name "uncommon:symbol")
  # =>
  "uncommon[col]symbol"

  (things/escape-sym-name "nan?")
  # =>
  "nan[que]"

  )

(def things/sym-char-unescapes
  (invert things/sym-char-escapes))

(defn things/unescape-file-name
  [file-name]
  (def unesc-grammar
    (peg/compile
      ~(accumulate
         (some
           (choice (replace (sequence "["
                                      (capture (to "]"))
                                      "]")
                            ,things/sym-char-unescapes)
                   (capture 1))))))
  (first (peg/match unesc-grammar file-name)))

(comment

  (things/unescape-file-name "string[sol]replace")
  # =>
  "string/replace"

  (things/unescape-file-name "[lt]")
  # =>
  "<"

  (things/unescape-file-name "-[gt]")
  # =>
  "->"

  (things/unescape-file-name "import[ast]")
  # =>
  "import*"

  (things/unescape-file-name "[per]=")
  # =>
  "%="

  (things/unescape-file-name "uncommon[col]symbol")
  # =>
  "uncommon:symbol"

  (things/unescape-file-name "nan[que]")
  # =>
  "nan?"

  )

(def things/aliases-table
  # XXX: what's missing?
  {"|" "fn"
   "~" "quasiquote"
   "'" "quote"
   ";" "splice"
   "," "unquote"})

(defn things/all-things
  []
  (filter |(not (string/has-prefix? "_" $))
          (keys usages/things)))

(defn things/choose-random-thing
  []
  (rnd/choose (things/all-things)))

# XXX: not sure if this quoting will work on windows...
(defn things/print-escaped-maybe
  [a-str]
  (if (peg/match ~(to (set "'*;<>|~")) a-str)
    (printf `"%s"` a-str)
    (print a-str)))

(comment

  (do
    (def buf @"")
    (with-dyns [*out* buf]
      (things/print-escaped-maybe "'"))
    buf)
  # =>
  @``
   "'"

   ``

  (do
    (def buf @"")
    (with-dyns [*out* buf]
      (things/print-escaped-maybe "*out*"))
    buf)
  # =>
  @``
   "*out*"

   ``

  (do
    (def buf @"")
    (with-dyns [*out* buf]
      (things/print-escaped-maybe "map"))
    buf)
  # =>
  @``
   map

   ``

  )

(def things/special-forms-table
  {"def" true
   "var" true
   "fn" true
   "do" true
   "quote" true
   "if" true
   "splice" true
   "while" true
   "break" true
   "set" true
   "quasiquote" true
   "unquote" true
   "upscope" true})

(defn things/usages
  [content &opt limit]
  # extract first set of tests from content
  (def tests
    (tests/extract-first-test-set content))
  (when (empty? tests)
    (break [nil
            "Sorry, didn't find any material to make a quiz from."]))
  (default limit (length tests))
  (def buf @"")
  (with-dyns [*out* buf]
      # question and answer pairs
      (each [ques ans] (array/slice tests 0
                                    (min limit (length tests)))
        (def trimmed-ans (string/trim ans))
        # show the question
        (pr/print-nicely-mono ques)
        (print "# =>")
        (pr/print-nicely-mono ans)
        (print)))
  #
  [true buf])


(comment import ./usages :prefix "")


(def version "2026-01-30_04-27-09")

(def usage
  `````
  usage: jref [THING] [OPTION]..
         jref [OPTION]... [THING]

  View Janet information for things such as functions,
  macros, special forms, etc.

  Parameters:

    thing    name of function, macro, special form, etc.

  Options:

    -h, --help               show this output

    -d, --doc                show doc
    -q, --quiz               show quiz question
    -s, --src                show source [1]
    -u, --usage              show usages

    -p, --pprint             pretty-print data

    -f, --format             format code
    -i, --indent             indent code
    -e, --eval               evaluate code
    -m, --macex1             macroexpand code

    -r, --repl               run a repl

        --env-vars           show tweakable environment vars

        --bash-completion    output bash-completion bits
        --fish-completion    output fish-completion bits
        --zsh-completion     output zsh-completion bits

        --raw-all            show all things to help completion

        --bindings

    -g, --grep
    -t, --todo

  With THING, but no options, show docs and usages.

  With the `-d` or `--doc` option, show docs for THING, or if
  none specified, for a randomly chosen one.

  With the `-q` or `--quiz` option, show quiz question for
  specified THING, or if none specified, for a randonly
  chosen one.

  With the `-s` or `--src` option, show source code for
  specified THING, or if none specified, for a randonly
  chosen one [1] in an editor [2].

  With the `-u` or `--usage` option, show usages for
  specified THING, or if none specified, for a randomly
  chosen one.

  With no arguments, lists all things.

  Be careful to quote shortnames (e.g. *, ->, >, <-, etc.)
  appropriately so the shell doesn't process them in an
  undesired fashion.

  ---

  [1] Lookups are performed via an index of the Janet source
  code. The index (a file named `TAGS.jref`) is built from a
  local copy of the Janet source code and placed in the same
  directory.

  The location of a local copy of the Janet source code can
  be specified via a configuration file or an environment
  variable.

  For the configuration file approach, create a file named
  `.jref.janet` in your `HOME` / `USERPROFILE` directory. The
  content should be something like:

  ```
  {:janet-src-path
   (string (os/getenv "HOME") "/src/janet")}
  ```

  That is, the file should end with a struct that has at
  least the key `:janet-src-path` and its associated value
  should evaluate to a full path to Janet source code.

  For the environment variable approach, set
  `JREF_JANET_SRC_PATH` to a full path of a local copy of the
  Janet source code.

  [2] The default editor is `nvim`. Other supported editors
  include: `emacs`, `hx`, `kak`, `subl`, and `vim`.

  A particular editor other than the default can be
  configured via a file (see info about `.jref.janet` above)
  or via an environment variable.

  For the configuration file approach, in a file named
  `.jref.janet` in your `HOME` / `USERPROFILE` directory, add
  an appropriate key-value pair to a struct which ends up as
  the last value to be evaluated in the file.

  The key should be `:editor` and the value should be one of:
  `emacs`, `hx`, `kak`, `nvim`, `subl`, or `vim`.

  An example `.jref.janet` might look like:

  ```
  {:editor "emacs"
   :janet-src-path
   (string (os/getenv "HOME") "/src/janet")}
  ```

  For the environment variable approach, `JREF_EDITOR` should
  be set to one of: `emacs`, `hx`, `kak`, `nvim`, `subl`, or
  `vim`.
  `````)

(defn all-the-sharp-things
  [content]
  (def m-lines @[])
  (def lines
    (string/split "\n" content))
  (when (empty? (array/peek lines))
    (array/pop lines))
  (each line lines
    (array/push m-lines
                (->> line
                     (peg/match ~(sequence "# "
                                           (capture (to -1))))
                     first)))
  #
  m-lines)

(defn main
  [& argv]

  (d/init-dyns)

  (def [opts rest errs] (av/parse-argv argv))

  (when (not (empty? errs))
    (each err errs
      (eprint "jref: " err))
    (eprint "Try 'jref -h' for usage text.")
    (os/exit 1))

  # the code beyond here is longish, but it's straight-forward, mostly
  # just dispatching based on key-value pair existence in opts

  # usage
  (when (get opts :help)
    (print usage)
    (os/exit 0))

  # show tweakable env vars
  (when (get opts :env-vars)
    (print evars/docstring)
    (os/exit 0))

  # possibly handle dumping completion bits
  (when (compl/maybe-handle-dump-completion opts)
    (os/exit 0))

  # help completion by showing a raw list of relevant things
  (when (or (get opts :raw-all) (get opts :todo))
    (def things (sort (things/all-things)))
    (cond
      (get opts :raw-all)
      (each thing things
        (things/print-escaped-maybe thing))
      #
      (get opts :todo)
      (let [tbl (table ;(interpose true
                                   (map symbol things))
                       true)]
        (each item (all-bindings)
          (when (not (get tbl item))
            (print item))))
      #
      (do
        (eprintf "Should not have gotten here...opts: %p" opts)
        (os/exit 1)))
    (os/exit 0))

  # check if there was a thing specified
  (var thing
    (let [cand (first rest)]
      (if-let [alias (get things/aliases-table cand)]
        alias
        cand)))

  # XXX: organize this later
  (when (get opts :repl)
    (eval-string "(import janet-ref/lib/repl) (repl/cli-main @[])")
    (os/exit 0))

  # XXX: organize this later
  (when (get opts :pprint)
    (->> (or thing (file/read stdin :all))
         data/fmt
         col/colorize
         print)
    (os/exit 0))

  # XXX: organize this later
  (when (get opts :macex1)
    (->> (or thing (file/read stdin :all))
         (string/format "(macex1 '%s)")
         eval-string
         (string/format "%n")
         code/fmt
         bind/process-binding-forms
         indent/format
         col/colorize
         print)
    (os/exit 0))

  # XXX: organize this later
  (when (get opts :eval)
    (->> (or thing (file/read stdin :all))
         eval-string
         (string/format "%n")
         data/fmt
         col/colorize
         print)
    (os/exit 0))

  # XXX: organize this later
  (when (get opts :format)
    (->> (or thing (file/read stdin :all))
         code/fmt
         bind/process-binding-forms
         indent/format
         col/colorize
         print)
    (os/exit 0))

  # XXX: organize this later
  (when (get opts :indent)
    (->> (or thing (file/read stdin :all))
         indent/format
         col/colorize
         print)
    (os/exit 0))

  (when (get opts :bindings)
    (def binding-tbl @{:macro @[]})
    (each name (all-bindings root-env true)
      (def info (dyn (symbol name)))
      # order is important here
      (if (get info :macro)
        (array/push (binding-tbl :macro) name)
        (let [the-type (type (get info :value))]
          (if (nil? (binding-tbl the-type))
            (put binding-tbl the-type @[name])
            (array/push (binding-tbl the-type) name)))))
    (if thing
      (when-let [vals (get binding-tbl (keyword thing))]
        (each elt (sort vals)
          (print elt)))
      (eachp [k v] binding-tbl
        (when (not (= k :nil))
          (print k)
          (each elt (sort v)
            (print "  " elt))
          (print))))
    (os/exit 0))

  # if no thing found and no options, show info about all things
  (when (and (nil? thing)
             (empty? opts))
    (def content (get usages/things "_all-the-things"))
    (each line (all-the-sharp-things content)
      (print line))
    (os/exit 0))

  # ensure a thing beyond this form by choosing one if needed
  (when (not thing)
    (set thing (things/choose-random-thing)))

  # XXX: organize this later
  (when (get opts :grep)
    (def repos-path (dyn :jref-repos-root))
    (def cmd-line ["rg"
                   thing
                   "--max-columns" "120"
                   "--max-columns-preview"
                   "--glob" "*.janet"
                   "--glob" "*.jdn"
                   "--glob" "*.cgen"
                   repos-path])
    (def code (os/execute cmd-line :p))
    # ripgrep exits with 1 if no match was found and there were no errors
    (if (or (zero? code) (one? code))
      (os/exit 0)
      (os/exit 1)))

  # XXX: organize this later
  (when (get opts :src)
    (def j-src-path (dyn :jref-janet-src-path))
    (when (or (nil? j-src-path)
              (not= :directory (os/stat j-src-path :mode)))
      (eprint "Failed to find Janet source directory.")
      (eprint "Please set the env var JREF_JANET_SRC_PATH to a")
      (eprint "full path of Janet source or arrange for an")
      (eprint "appropriate config file.  Please see the program")
      (eprint "usage text for details.")
      (os/exit 1))

    (def file-ext ".jref")
    (def tags-fname (string "TAGS" file-ext))
    (def etags-file-path (string j-src-path "/" tags-fname))

    (when (or (not (os/stat etags-file-path))
              (not (idx/file-newest? etags-file-path j-src-path)))
      (eprintf "Index file might be stale or failed to find it in: %s"
               j-src-path)
      (eprintf "Trying to create fresh index file at: %s"
               etags-file-path)
      (idx/build-index j-src-path file-ext)
      (when (not (os/stat etags-file-path))
        (eprintf "Failed to create index file at: %s" etags-file-path)
        (os/exit 1))
      #
      (printf "Created index file at: `%s`" etags-file-path))
    #
    (def etags-content
      (try
        (slurp etags-file-path)
        ([e]
          (eprintf "Failed to read index file: %s" etags-file-path)
          (os/exit 1))))
    (src/definition thing etags-content j-src-path)
    (os/exit 0))

  # show docs, usages, or quizzes for a thing
  (def content (get usages/things thing))

  (when (empty? opts)
    (put opts :doc true)
    (put opts :usage true))

  (when (get opts :doc)
    (def lines (if (get things/special-forms-table thing)
                 (doc/special-form-doc content)
                 (doc/thing-doc thing)))
    (each line lines
      (print line)))

  (when (get opts :usage)
    (var limit nil)
    # some special behavior
    (when (get opts :doc)
      (set limit 3)
      (print)
      (pr/print-separator)
      (print))
    #
    (def [res buf] (things/usages content limit))
    (if res
      (print (col/colorize buf))
      (do
        (eprint buf)
        (os/exit 1))))

  (when (get opts :quiz)
    (qu/thing-quiz content)))

